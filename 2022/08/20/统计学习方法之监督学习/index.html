
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>统计学习方法之监督学习 - Welcome</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="PeiGiZhu&#39;s Blog,概述本文围绕李航《统计学习方法》第一版无监督学习中的部分章节撰写学习笔记，
并将学习过程中个人遇到的问题与思考以及相应的解答进行记录总结。
阅读《统计学习方法》的初衷是给之后深度学习作为铺垫，
因此,"> 
    <meta name="author" content="PeiGiZhu"> 
    <link rel="alternative" href="atom.xml" title="Welcome" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
<script type="text/javascript">

var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1d0c9785f225d93a308476f4d526c441";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();

</script>

<meta name="generator" content="Hexo 4.2.1"></head>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





















<body class="loading">
    <span id="config-title" style="display:none">Welcome</span>
    <div id="loader"></div>
    <div id="single">
    
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://peigizhu.gitee.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">统计学习方法之监督学习</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>


    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">统计学习方法之监督学习</h1>
        <div class="stuff">
            <span>八月 20, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Machine-Learning/" rel="tag">Machine Learning</a></li></ul>


        </div>

        <div class="content markdown">
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文围绕李航《统计学习方法》第一版无监督学习中的部分章节撰写学习笔记，</p>
<p>并将学习过程中个人遇到的问题与思考以及相应的解答进行记录总结。</p>
<p>阅读《统计学习方法》的初衷是给之后深度学习作为铺垫，</p>
<p>因此本文也将重点关注一些较为相关的基础理论算法内容。</p>
<p>具体包括原书以下章节:</p>
<p><strong>第1章，统计学习及监督学习概论</strong></p>
<p><strong>第2章，感知机</strong></p>
<p><strong>第4章，朴素贝叶斯法</strong></p>
<p><strong>第6章，逻辑斯蒂回归与最大熵模型</strong></p>
<p>未来可能会根据个人学习需求在陆续添加其他章节内容。</p>
<h1 id="统计学习及监督学习概论"><a href="#统计学习及监督学习概论" class="headerlink" title="统计学习及监督学习概论"></a>统计学习及监督学习概论</h1><blockquote>
<p>个人认为的本章重点:</p>
<p>1.统计学习三要素(1.3节)</p>
<p>2.模型评估与模型选择(1.4节)</p>
<p>3.正则化与交叉验证(1.5节)</p>
<p>4.生成模型与判别模型(1.7节)</p>
<p>5.分类问题，标注问题，回归问题(1.8节-1.10节)</p>
</blockquote>
<h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><blockquote>
<p>感知机是经典的线性二分类模型，是神经网络的基础。</p>
<p>输入为实例的特征向量$x\in X$ 输出为$y\in Y={+1,-1}$</p>
</blockquote>
<h1 id="朴素贝叶斯法"><a href="#朴素贝叶斯法" class="headerlink" title="朴素贝叶斯法"></a>朴素贝叶斯法</h1><blockquote>
<p>朴素贝叶斯法是经典的生成模型算法，是基于贝叶斯定理与特征条件独立假设的分类方法。</p>
<p>对于某一问题设计朴素贝叶斯法模型关键是得到朴素贝叶斯法的参数估计。</p>
</blockquote>
<h1 id="逻辑斯谛回归"><a href="#逻辑斯谛回归" class="headerlink" title="逻辑斯谛回归"></a>逻辑斯谛回归</h1><blockquote>
<p>逻辑斯谛回归模型与最大熵模型都属于对数线性模型。</p>
<p>逻辑斯蒂回归虽然有回归二字但其实并非用于线性回归问题。</p>
<p>最典型的逻辑斯蒂回归应用于输出值离散的二分类或多分类问题上。</p>
<p>相关引用: <a href="https://www.cnblogs.com/pinard/p/6029432.html" target="_blank" rel="noopener">刘建平Pinard-逻辑回归原理小结</a></p>
</blockquote>
<h2 id="从线性回归到逻辑回归"><a href="#从线性回归到逻辑回归" class="headerlink" title="从线性回归到逻辑回归"></a>从线性回归到逻辑回归</h2><p>线性回归的模型是求出输出值 $y$ 和输入向量$x$之间的线性关系 $y=wx+b$，或者将偏置$b$并入特征矩阵$w$，记作$\hat{w}=(w^{T},b)^{T}$，</p>
<p>同样也将输入向量加以扩充，加进常数 1，记作$\hat{x}=(x^{T},1)^{T}$，显然有$\hat{w}\hat{x}=wx+b$。</p>
<p>对于线性回归问题，输入输出被映射成一个线性函数的关系，因此对于输出值 $y$ 是连续的。</p>
<p>如果 $y$ 是离散值怎么办？一个想法是对 $y$ 在做一次函数转化，变为$g(y)$。</p>
<p>如果我们令 $g(y)$ 的值在某个实数区间的时候是类别A，在另一个实数区间的时候是类别B，</p>
<p>以此类推就得到了一个分类模型，这也是逻辑斯谛回归要做的。</p>
<h2 id="逻辑斯谛分布到逻辑回归模型"><a href="#逻辑斯谛分布到逻辑回归模型" class="headerlink" title="逻辑斯谛分布到逻辑回归模型"></a>逻辑斯谛分布到逻辑回归模型</h2><p>在引入逻辑斯谛回归之前首先介绍逻辑斯谛分布。</p>
<p>设 $X$ 是连续随机变量，$X$ 服从逻辑斯谛分布是指 $X$ 具有下列分布函数$F(x)$和密度函数$f(x)$:<br>$$<br>F(x)=P(X\leq x)= {1\over 1+e^{-(x-\mu)/\lambda} }\<br>f(x)=F’(X)= {e^{-(x-\mu)/\lambda}\over \lambda(1+e^{-(x-\mu)/\lambda})^2}<br>$$<br>这里顺便回顾一下分布函数与概率密度函数的含义。粗略的说概率密度函数$f(x)$就是$P(X=x)$的概率。</p>
<p>对于离散事件$x$而言， $F(m) = P(X\leq m) = \sum_{x = -\infty}^m P(X=x)$。</p>
<p>对于连续变量$x$而言，$F(m) = P(X\leq m) = \int_{x = -\infty}^m P(X=x)$。</p>
<p>而逻辑斯谛分布的密度函数与分布函数形如下图所示。</p>
<p><img src="/.io//timg.gif" data-original="LogisticDistribution.png"></p>
<p>密度函数图像(左图)反映了逻辑斯谛分布模型中随机事件 $x$ 符合以均值 $\mu $ 为对称轴的，类似正态分布的触发概率。</p>
<p>而分布函数图像(右图)就是经典的sigmoid函数的原型。</p>
<p>假如我们规定随机事件 $x$ 的概率分布以$F(x)&gt;0.5$ 和$F(x)&lt;0.5$分为两类来分别对应二分类中输出$y$ 的值，</p>
<p>那么就能够应对输出值是离散值的情况，并用于求解分类问题。</p>
<p>而这里分布函数$F$ 就是上文 <strong>从线性回归到逻辑回归</strong> 指代的函数 $g$ 的原型。<br>$$<br>g(z) = {1 \over 1+e^z}\<br>z = wx+b = \hat{w}\hat{x}\<br>\hat{w} = (w^{(1)},w^{(2)},\cdots, w^{(n)}, d)\<br>\hat{x} = (x^{(1)},x^{(2)},\cdots, x^{(n)}, 1)\<br>$$<br>(关于函数 $g$ 此处刘建平老师的博客和李航老师书中所记略有不同但本质一样)</p>
<p>函数 $g$ 有个非常好的性质: $g’(z)=g(z)(g(z)-1)$ </p>
<p>这让sigmoid函数在神经网络算法中反向传播更新计算更简便。</p>
<h3 id="二项逻辑斯谛回归模型"><a href="#二项逻辑斯谛回归模型" class="headerlink" title="二项逻辑斯谛回归模型"></a>二项逻辑斯谛回归模型</h3><p>具体的二项逻辑斯谛回归模型是如下的条件概率分布:<br>$$<br>P(Y=1|x)={e^{wx+b} \over 1 + e^{wx+b} }\<br>P(Y=0|x)= 1 - P(Y=1|x) = {1 \over 1 + e^{wx+b} }\<br>$$<br>而逻辑回归模型所需要学习的就是权值向量 $w$ 以及偏置 $b$，</p>
<p>刘建平老师的博客中将权值向量和偏置合并记作线性关系系数 $\theta$ (等同于此处的 $\hat{w}$)。</p>
<p>计算二元逻辑回归模型中事件$x$发生的对数几率: $log{P(Y=1|x) \over P(Y=0|x)} = wx+b$</p>
<p>这就是说，在逻辑斯谛回归模型中，输出 $Y=1$  的对数几率是输入 $x$ 的线性函数。</p>
<p>或者说，输出 $Y=1$ 的对数几率是由输入 $x$ 的线性函数表示的模型，即逻辑斯谛回归模型。</p>
<h3 id="多项逻辑斯谛回归模型"><a href="#多项逻辑斯谛回归模型" class="headerlink" title="多项逻辑斯谛回归模型"></a>多项逻辑斯谛回归模型</h3><p>二项逻辑回归可以推广到多项逻辑回归模型。假设输出离散值$Y = {1,2,\cdots,K }$，那么多项逻辑回归模型是:<br>$$<br>P(Y=k|x)={e^{\hat{w_k}x} \over 1 + \sum_{k=1}^{K-1} e^{\hat{w_k}x} }, \quad k = 1,2,\cdots, K-1\<br>P(Y=0|x)= 1 - P(Y=1|x) = {1 \over 1 + \sum_{k=1}^{K-1} e^{\hat{w_k}x} }\<br>$$<br>需要注意到$\hat{w_k}$ 是不同分类 $y$ 对应的一个向量参数。</p>
<h2 id="模型参数估计"><a href="#模型参数估计" class="headerlink" title="模型参数估计"></a>模型参数估计</h2><blockquote>
<p>相关参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/26614750" target="_blank" rel="noopener">一文搞懂极大似然估计</a></p>
<p><a href="https://blog.csdn.net/u011508640/article/details/72815981" target="_blank" rel="noopener">详解最大似然估计（MLE）最大后验概率估计（MAP）以及贝叶斯公式的理解</a></p>
</blockquote>
<p>现在已经知道了逻辑回归模型，即上述条件概率分布。</p>
<p>然而要使用逻辑回归模型去判断输入 $x$ 所对应的 $y$ 还需要求得模型中的参数$\hat{w}$ 。</p>
<p>为了求得参数$\hat{w}$ 需要用到极大似然估计的思想。</p>
<h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><p>通俗理解来说，<strong>就是利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值，</strong></p>
<p><strong>即：“模型和样本已定，参数未知”</strong>。</p>
<p><strong>极大似然估计中采样需满足一个重要的假设，就是所有的样本都是互相独立且服从同一概率分布规则的</strong>。</p>
<p>一个比较好的例子是硬币的质地是否均匀，即想知道抛这枚硬币，正面出现的概率 $\theta$ 是多少。</p>
<p>假设投掷硬币5次得到的训练数据集，即已知的样本结果信息 $T= {(x_1, 1),(x_2, 1),(x_3, 0),(x_4, 1),(x_5, 0)}$，其中$x_i$表示第i次投掷行为，输出为$y_i\in {0,1}$ ，0为反面，1为正面。</p>
<p>我们想求的正面概率 $\theta$ 是模型参数，而抛硬币模型我们可以假设是二项分布。</p>
<p>那么，出现实验结果 $T$ 的似然函数是 : $P(T|\theta) = \theta^3(1-\theta)^2 $，</p>
<p>当 $P(T|\theta)$ 最大时，此时的 $\theta$ 才是最有可能导致出现样本结果 $T$ 的参数。</p>
<p>找到函数 $P(T|\theta) = \theta^3(1-\theta)^2$  的最大值处的 $\theta$ :</p>
<p>$\theta_{best} = \underset{ {\theta} }{argmax}\ P(T|\theta)$ ，求得对应的 $\theta_{best} = 0.6$ 。</p>
<p>通常我们会对似然函数取对数从而将乘法改为 $log$ 项相加更方便讨论最大值。</p>
<p>如果从经验角度来说，根据这个样本结果$T$ 很容易计算出投掷正面的概率为$\theta = 0.6$，也符合极大似然估计结果。</p>
<h3 id="使用极大似然估计求二项逻辑回归中的参数-hat-w"><a href="#使用极大似然估计求二项逻辑回归中的参数-hat-w" class="headerlink" title="使用极大似然估计求二项逻辑回归中的参数$\hat{w}$"></a>使用极大似然估计求二项逻辑回归中的参数$\hat{w}$</h3><p>在逻辑斯蒂回归中，我们已经知道了概率分布模型是:<br>$$<br>P(Y=1|x)={e^{wx+b} \over 1 + e^{wx+b} }\<br>P(Y=0|x)= 1 - P(Y=1|x) = {1 \over 1 + e^{wx+b} }\<br>$$<br>我们需要求得的参数是$w$ 与 $b$ 或者说 $\hat{w}$，</p>
<p>假设训练数据集，即已知的样本结果信息 $T = {(x_1, y_1), (x_2, y_2),\cdots, (x_N, y_N)}$ 其中$x_i\in R^n, y_i \in {0,1}$</p>
<p>由于二项逻辑回归模型的输出$y\in{1,0}$ 符合二项分布。</p>
<p>那么对应的似然函数为:<br>$$<br>\prod_{i=1}^N[P(Y=1|x_i)]^{y_i}[1-P(Y=1|x_i)]^{1-y_i}<br>$$<br>当样本 $y_i$ 输出为0，那么第 $i$ 个连乘项为 $P(Y=0|x_i)$，</p>
<p>当样本 $y_i$ 输出为1，那么第 $i$ 个连乘项为 $P(Y=1|x_i)$，</p>
<p>对似然函数取对数，并将结果化简得到二项逻辑回归的关于参数 $\hat{w}$ 的损失函数 $L(\hat{w})$:<br>$$<br>L(\hat{w}) = \sum_{i=1}^N[y_i(\hat{w}x_i)-log(1+e^{\hat{w}x_i})]\<br>\hat{w}<em>{best} = \underset{ {\hat{w} } }{argmax}\ L(\hat{w})<br>$$<br>可以使用梯度下降法或者拟牛顿法进行迭代更新计算得到$\hat{w}</em>{best}$。</p>
<h1 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h1><blockquote>
<p>最大熵是概率模型学习的一个准则，最大熵原理认为，学习概率模型时，</p>
<p>在所有可能的概率模型（分布）中，熵最大的模型是最好的模型。</p>
<p>相关参考:</p>
<p><a href="https://www.cnblogs.com/pinard/p/6093948.html" target="_blank" rel="noopener">最大熵模型原理小结 - 刘建平Pinard</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/83765331" target="_blank" rel="noopener">李航《统计学习方法》最大熵模型p(y|x)推导的正确过程</a></p>
</blockquote>
<h2 id="信息熵与条件熵"><a href="#信息熵与条件熵" class="headerlink" title="信息熵与条件熵"></a>信息熵与条件熵</h2><blockquote>
<p>相关参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/26486223" target="_blank" rel="noopener">通俗理解信息熵</a></p>
</blockquote>
<p>在学习最大熵模型之前，先要了解信息学中信息熵的概念。</p>
<p>熵：表示随机变量的不确定性。</p>
<p>假设 $P(X=x_i)$ 代表随机事件 $X$ 为 $x_i$ 的概率，则其熵为:<br>$$<br>H(X) = -\sum_{i=1}^n P(X=x_i)logP(X=x_i)<br>$$<br>在李航的书中此处的 $log$ 以 $e$ 为底数。</p>
<p>公式中的 $log\ P(X=x_i)$ 用来衡量随机事件 $X$ 为 $x_i$ 时的信息量。</p>
<p>那么信息熵公式就可以被理解成随机事件 $X$ 所含信息量的期望，即: 各项概率 × 对应信息量的总和。</p>
<p>根据熵的定义，我们可以推广到两个变量 $X,Y$ 的联合熵:<br>$$<br>H(X,Y) = -\sum_{x_i\in X}\sum_{y_j \in Y} P(X=x_i,Y=y_j)logP(X=x_i,Y=y_j)<br>$$<br>在本节中我们需要使用条件熵来帮助进行推导最大熵模型。</p>
<p>条件熵是指在一个条件下，随机变量的不确定性:<br>$$<br>\begin{aligned}<br>H(Y|X=x_j) &amp;= \sum_{y_i \in Y} P(Y=y_i|X=x_j)logP(Y=y_i|X=x_i)\<br>H(Y|X) &amp;= \sum_{x_j\in X}P(X=x_j)H(Y|X=x_j)\<br>&amp;= -\sum_{x_i\in X}\sum_{y_j \in Y}P(Y=y_i,X=x_j)logP(Y=y_i|X=x_j)<br>\end{aligned}<br>$$</p>
<h2 id="最大熵原理以及最大熵模型"><a href="#最大熵原理以及最大熵模型" class="headerlink" title="最大熵原理以及最大熵模型"></a>最大熵原理以及最大熵模型</h2><p>最大熵原理认为要选择的概率模型首先必须满足已有的事实，即约束条件。</p>
<p>在没有更多信息的情况下，那些不确定的部分都是“等可能的”。最大熵原理通过熵的最大化来表示等可能性。</p>
<p>用一个例子解释一下这段话。</p>
<p>假设随机变量$X$ 有4个取值 ${A,B,C,D}$ ，取各个值的概率为$P(A),\cdots,P(D)$。</p>
<p>这些概率值满足以下约束条件: $P(A)+\cdots+P(D) = 1$</p>
<p>满足这个约束条件的概率分布有无穷多个。如果没有任何其他信息，仍要对概率分布进行估计，</p>
<p>一个办法就是认为这个分布中取各个值的概率是相等的，因为此时$H(X)$最大，符合最大熵准则。</p>
<p>即: 熵最大的模型是最好的模型。</p>
<p>根据最大熵原理得到最大熵模型定义。</p>
<p><strong>下面需要先定义一系列函数</strong></p>
<p>给定一个数据集 $T = {(x_1, y_1), (x_2, y_2),\cdots, (x_N, y_N)}$</p>
<p>定义联合分布$P(X=x,Y=y)$ 的经验分布为 $\tilde{P}(X=x,Y=y)$</p>
<p>定义边缘分布$P(X=x)$ 的经验分布为 $\tilde{P}(X=x)$<br>$$<br>\tilde{P}(X=x,Y=y) = {v(X=x,Y=y)\over N}\<br>\tilde{P}(X=x) = {v(X=x)\over N}\<br>$$<br>其中 $v(X=x,Y=y)$ 表示样本中出现 $(x,y)$ 的频数，$v(X=x)$ 表示训练数据中输入 $x$ 出现的频数。</p>
<p>定义特征函数 $f(x,y)$ 描述输入 $x$ 和输出 $y$ 是否存在联系。</p>
<p>可以认为只要出现在训练集中出现 $(x_i,y_j)$， 其$f(x_i,y_j)=1$， 否则 $f(x_i,y_j)=0$</p>
<p>特征函数$f(x,y)$ 关于经验分布$\tilde{P}(X,Y)$ 的期望，用$E_{\tilde{P} }(f)$ 表示:<br>$$<br>E_{\tilde{P} }(f) = \sum_{x_i\in X}\sum_{y_j\in Y}\tilde{P}(X=x_i,Y=y_j)f(x_i,y_j)<br>$$<br>特征函数$f(x,y)$ 关于<strong>模型$P(Y|X)$ </strong>与经验分布$\tilde{P}(X)$的期望，用$E_{P}(f)$ 表示:<br>$$<br>E_{P}(f) = \sum_{x_i\in X}\sum_{y_j\in Y}\tilde{P}(X=x_i)P(Y=y_j|X=x_i)f(x_i,y_j)<br>$$<br>如果模型能够获取训练数据中的信息，那么就可以假设这两个期望值相等，即$E_{\tilde{P} }(f) = E_{P}(f)$。</p>
<p>这个等式将作为模型学习的约束条件，假设存在n个特征函数$f_i(x,y),i=1,\cdots,n$ 那么就有n个约束条件。</p>
<p><strong>最后根据以上公式给出最大熵模型</strong></p>
<p>假设我们需要获得的最优模型是$P(Y|X)$ 简记为 $P$ ，也就是最终通过学习得到的结果。</p>
<p>定义在条件概率分布$P(Y|X)$ 上的条件熵$H(P)$为<br>$$<br>H(P) =  -\sum_{x_i\in X}\sum_{y_j \in Y}\tilde{P}(X=x_i)P(Y=y_j|X=x_i)logP(Y=y_j|X=x_i)<br>$$<br>假设最大熵模型符合约束条件集合 $C$ ，那么最大熵模型的定义为:<br>$$<br>C={P| E_{\tilde{P} }(f_i) = E_{P}(f_i), i= 1,2,\cdots,n}\<br>P_{best} = \underset{P}{argmax} = H(P)<br>$$</p>
<h2 id="最大熵模型的学习"><a href="#最大熵模型的学习" class="headerlink" title="最大熵模型的学习"></a>最大熵模型的学习</h2><p>最大熵模型的学习过程就是求解符合最大熵模型的$P(Y|X)$的过程，</p>
<p>由于不容易直接根据最大熵模型的定义求解，需要将问题通过拉格朗日函数转化为约束最优问题。</p>
<p>因此在展开讲解最大熵模型的学习之前需要先介绍一下拉格朗日函数以及拉格朗日对偶性。</p>
<h3 id="拉格朗日函数与拉格朗日对偶性"><a href="#拉格朗日函数与拉格朗日对偶性" class="headerlink" title="拉格朗日函数与拉格朗日对偶性"></a>拉格朗日函数与拉格朗日对偶性</h3><blockquote>
<p>相关参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/99945521" target="_blank" rel="noopener">10幅图帮助理解拉格朗日乘数法的原理</a></p>
<p><a href="https://blog.csdn.net/frostime/article/details/90291392" target="_blank" rel="noopener">从0到完全理解拉格朗日函数的对偶函数</a></p>
<p><a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">“拉格朗日对偶问题”如何直观理解？“KKT条件” “Slater条件” “凸优化”打包理解</a></p>
</blockquote>
<p><strong>首先拉格朗日函数能做什么?</strong></p>
<p>拉格朗日函数能够将约束最优化问题变为无约束优化问题并进行求解。</p>
<p><strong>拉格朗日函数如何求解约束最优化问题?</strong></p>
<p>假设$f(x),c_i(x),h_j(x)$ 是定义在$R^n$ 上的连续可微函数，考虑约束最优化问题:<br>$$<br>\begin{aligned}<br>\underset{x\in R^n}{min}\quad &amp; f(x)\<br>s.t \quad &amp; c_i(x) \leq 0, i=1,2,\cdots,k\<br>&amp; h_j(x) = 0, j=1,2,\cdots,l<br>\end{aligned}<br>$$<br>存在 $k$ 个不等式约束条件 $c_i(x)$ ，以及 $l$ 个约束条件$h_j(x)$。</p>
<p>引入拉格朗日函数将上述问题等价表述为:<br>$$<br>L(x,\alpha,\beta) = f(x) + \sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x), \quad \alpha_i\geq 0 \<br>set\quad A(x)= \underset{\alpha,\beta;\alpha_i\geq 0}{max} L(x,\alpha,\beta)\<br>p^{<em>} = \underset{x}{min} A(x)<br>$$<br>其中的乘子 $a$ 与 $\beta$ 是未定参数向量需要被求解。我们将上述两种表示称为原始问题的最优解 $p^{</em>}$。</p>
<p>通常我们会将原始问题转化为对偶问题求解，对偶问题就是<strong>实质相同但从不同角度观察的一对问题</strong>。</p>
<p>设对偶问题为$d^{<em>}$，对偶函数为 $I(\alpha,\beta)$ 那么有:<br>$$<br>set\quad I(\alpha,\beta) =\underset{x}{min} L(x,\alpha,\beta) \quad x\in R^n \<br>d^{</em>} = \underset{\alpha,\beta}{max} I(\alpha,\beta),\ s.t. \ \alpha_i\geq 0<br>$$<br>其中$a_i\geq 0$ 是对偶问题的约束条件，对于对偶问题中在求 $\underset{x}{min} L(x,\alpha,\beta)$ 时，</p>
<p>$x$ 不受约束条件$c_i(x)$ 与 $h_j(x)$ 影响，因此$x \in R^n$。</p>
<p>我们可以证明 $d^{<em>} \leq p^{</em>}$ ，证明如下:<br>$$<br>\begin{aligned}<br>&amp;\underset{\alpha,\beta;\alpha_i\geq 0}{max} L(x,\alpha,\beta) \geq L(x,\alpha,\beta) \geq \underset{x}{min} L(x,\alpha,\beta)\<br>&amp;set\quad A(x)= \underset{\alpha,\beta;\alpha_i\geq 0}{max} L(x,\alpha,\beta), \quad I(\alpha,\beta) =\underset{x}{min} L(x,\alpha,\beta)\<br>&amp;\because \quad A(x) \geq I(\alpha,\beta)\<br>&amp;\therefore \quad  \underset{x}{min} A(x) \geq \underset{\alpha,\beta;\alpha_i\geq 0}{max}I(\alpha,\beta)\<br>&amp;\therefore \quad p^{<em>} \geq d^{</em>}<br>\end{aligned}<br>$$<br>更形象的图解证明可以参考<a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">视频</a> 28分钟左右。</p>
<p>满足 $d^{<em>} \leq p^{</em>}$ 关系的对偶性称为弱对偶性，通过弱对偶性，我们可以给出原始问题 $p^{*}$ 的范围。</p>
<p>当原始问题 $p^{<em>}$ 是<strong>凸优化问题且满足Slater条件</strong>时，有 $d^{</em>} = p^{*}$ ，即原始问题的最优解。 </p>
<p>(但是一般情况是凸优化问题就有$d^{<em>}=p^{</em>}$，上述凸优化问题且满足Slater条件是充分条件)</p>
<p><strong>什么是凸优化问题?</strong></p>
<p>当 $f(x),c_i(x)$ 是凸函数，$h_j(x)$ 是仿射函数时，原问题 $p^{*}$ 是一个凸优化问题。</p>
<p><strong>凸函数定义:</strong> ${f(x_1)+f(x_2) \over2} \geq f({x_1+x_2 \over 2})$ 且 定义域为凸集。$f(x)=x^2$ 就是一个典型的凸函数。</p>
<p>凸集的定义如下，假设集合 $C$ 是一个定义在 $n$ 维的定义域。</p>
<p><img src="/.io//timg.gif" data-original="ConvexSet.png"></p>
<p>那么右侧橙色所表示的集合 $C$ 是凸集，而左侧蓝色所表示的集合不是凸集。</p>
<p>关于求最大熵问题一般都是凸优化问题，下面给出一个简单的例子感受一下。<br>$$<br>p^{<em>}=\underset{P}{max} \ H(P) = -\sum_x P(x)logP(x)\<br>p^{</em>}=\underset{P}{min} \ -H(P) = \sum_x P(x)logP(x)\<br>s.t. \ E_p(f_i) = E_{\tilde{P} }(f_i), \ i=1,\cdots,n\<br>\sum_{x}P(x)=\sum_{x}\tilde{P}(x)=1<br>$$<br>假设随机变量$X={x_1,x_2}$  那么有 $- H(P) = P(x_1)logP(x_1) + (1-P(x_1))log(1-P(x_1))$ 函数图像:</p>
<p><img src="/.io//timg.gif" data-original="HP.png"></p>
<p>从函数图像可以看出关于熵的函数$-H(P)$ 是一个凸函数。</p>
<p>同时关于最大熵模型的约束条件(仅有等式约束)，符合仿射函数条件。</p>
<p>所以求最大熵问题一般情况下符合凸优化问题定义。</p>
<p><strong>什么是仿射函数?</strong></p>
<p>仿射函数指符合 $c = Wx+b$ 且 $ x,w\in R^n$ 关系的函数， 当$x,w$是一维时，它就是典型的线性函数。</p>
<p>而它的解集 $C={x|c=Wx+b}$  是仿射集。</p>
<p><strong>什么是Slater条件?</strong></p>
<p>Slater条件定义如下:</p>
<p>存在一个点$x \in relint \ D$ ($relint \ D$ 表示非边界定义域)，</p>
<p>使得 $c_i(x) &lt; 0, \ i=1,2,\cdots,k$ 且 $Wx = b $ ，即 $x$ 属于$h_j(x)$的解集。</p>
<p><strong>为何选择求解对偶问题 $b^{<em>}$ 而不是直接求解 $p^{</em>}$ ?</strong></p>
<p>原始问题求解比较困难，主要是因为原始问题中 $f(x)$ 或 $A(x)$ 凹凸性不明确。</p>
<p>而对偶问题中 $I(\alpha,\beta)$ ，一定是一个凹函数 (与凸函数相反)，即一定存在最大值。</p>
<p>关于$I(\alpha,\beta)$ 是凹函数的证明可以看<a href="https://blog.csdn.net/frostime/article/details/90291392" target="_blank" rel="noopener">此博客</a></p>
<h3 id="原始问题与对偶问题的求解"><a href="#原始问题与对偶问题的求解" class="headerlink" title="原始问题与对偶问题的求解"></a>原始问题与对偶问题的求解</h3><p>前文简单介绍了使用对偶问题求解拉格朗日函数表示的约束最优化问题。</p>
<p>但是无论是原始问题 $p^{<em>}$ 还是对偶问题 $d^{</em>}$ 它们要求极小极大值或极大极小值，这在理解时非常抽象。</p>
<p><a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">视频</a> 28分钟左右，证明了$p^{<em>}\geq d^{</em>}$ 的同时也展示了如何直接求解原始问题和对偶问题:</p>
<p>设有原始问题$p^{<em>}$:<br>$$<br>\begin{aligned}<br>\underset{x\in R^n}{min}\quad &amp; f(x)\<br>s.t \quad &amp; c_i(x) \leq 0, i=1,2,\cdots,k\<br>&amp; h_j(x) = 0, j=1,2,\cdots,l\\<br>L(x,\alpha,\beta) &amp;= f(x) + \sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)<br>\end{aligned}<br>$$<br>其对偶问题$d^{</em>}$为:<br>$$<br>d^{*} = \underset{\alpha,\beta}{max} \ \underset{x}{min} L(x,\alpha,\beta)\<br>s.t. \alpha_i \geq 0<br>$$<br>由于$h_j(x)=0$ 它对$L(x,\alpha,\beta)$的大小没有贡献，在讨论拉格朗日函数 $L$ 的具体值时可以省略。</p>
<p>但是我们仍然需要在拉格朗日函数中加入 $h_j(x)$ 因为它的导数对求解问题有意义。</p>
<p>同时我们可以令$f(x) = t$，$\sum_{i=1}^k\alpha_ic_i(x) = \lambda^T u$ 。</p>
<p>那么拉格朗日函数的形式被简化成:<br>$$<br>L(x,\alpha,\beta) = L(t,u)= t + \lambda^T u<br>$$<br>其中 $t$ 是标量，$u$是一个向量，其维度大小等于约束条件 $c_i(x)$ 的个数$i$。</p>
<p>为了简化问题我们可以将拉格朗日函数看成关于变量 $t$ 和 $u$ 的函数 $L$ 。</p>
<p>同时简化后的原始问题和对偶问题为:<br>$$<br>p^{<em>} = \underset{x}{min}{t|(t,u)\in G_1, u\leq0 }\<br>d^{</em>} = \underset{\lambda}{max} \ \underset{x}{min} {t + \lambda^T u|(t,u)\in G_2,\lambda \geq 0}\<br>$$<br>其中 $G_1$ 表示原始问题的可行域，$G_2$ 表示对偶问题的可行域，且 $G_1 \in G_2$，</p>
<p>因为对偶问题中 $x$ 不受约束条件影响因此 $G_1$ 是 $G_2$ 的子集。</p>
<p><img src="/.io//timg.gif" data-original="p_d_problem.png"></p>
<p>那么对于原始问题就是在可行域 $G_1$ 处找到一个点$(t,u)$ 使得 $t$ 最小。</p>
<p>而对于对偶问题:</p>
<p>第一步</p>
<p>假定斜率 $\lambda$ 已知，在$G_2$ 内找到一个点 $(t,u)$ ，即调整 $x$ 使得函数 $L(t,u)$  过该点，且它的截距最小。</p>
<p>这里可能不太好理解为什么找截距$c$ ，即 $c = \underset{x}{min} L(t,u)$ 。</p>
<p>假设找到的函数$L(t,u)$ 过点 $(t^{<em>}, u^{</em>})\in G_2$ 且斜率 $\lambda$ 已知，那么截距 $c = t^{<em>}+\lambda^Tu^{</em>}$ 。</p>
<p>因为一旦确定了 $(t^{<em>}, u^{</em>})$ ，那么二元函数$L(t,u)$ 就退化成了一元函数 $c -\lambda^Tu= t$。</p>
<p>而对于一元函数带入直线上任意一点都等于同一个值 $c$ 。</p>
<p>第二步</p>
<p>调整 $\lambda$ ，重复第一步，每个斜率各自对应一条直线，找出这些直线中截距最大的那一条。</p>
<p>那么最终的截距$c$ 就是我们要求的对偶问题的解，即$d^{*} = \underset{\lambda}{max} \ \underset{x}{min} {t + \lambda^T u|(t,u)\in G_2,\lambda \geq 0}$。</p>
<p><strong>KKT条件</strong></p>
<p>由于直接求解对偶问题中的极大极小值问题比较抽象，</p>
<p>我们通常会使用 $KKT$ 条件中梯度为0的条件求解拉格朗日函数中的参数$\alpha,\beta$ 以及变量 $x$ , </p>
<p>可以说只要满足强对偶关系，那么可以使用$KKT$条件求解最优值。</p>
<p>对于凸优化原始问题 $p^{*}$<br>$$<br>\begin{aligned}<br>\underset{x\in R^n}{min}\quad &amp; f(x)\<br>s.t \quad &amp; c_i(x) \leq 0, i=1,2,\cdots,k\<br>&amp; h_j(x) = 0, j=1,2,\cdots,l\<br>L(x,\alpha,\beta) =&amp; f(x) + \sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)<br>\end{aligned}<br>$$<br>其对应的$KKT$ 条件表述如下 :<br>$$<br>c_i(x) \leq 0\<br>h_i(x) = 0\\</p>
<p>\nabla_xL(x,\alpha,\beta) = 0\<br>\nabla_{\alpha}L(x,\alpha,\beta) = 0\<br>\nabla_{\beta}L(x,\alpha,\beta) = 0\<br>a_i \geq 0\\<br>\alpha_ic_i(x) = 0<br>$$<br>$KKT$ 条件的前两条对应原问题中的约束条件。</p>
<p>中间梯度为0以及$a_i\geq 0$ 是对偶问题的约束条件。</p>
<p>统计学习方法附录中有$\nabla_{\alpha}L(x,\alpha,\beta) = 0$ ，$\nabla_{\beta}L(x,\alpha,\beta) = 0$，将这种KKT条件作为强对偶性的充分必要条件。</p>
<p>而其他资料中只有前一条$\nabla_xL(x,\alpha,\beta) = 0$，将这种KKT条件作为强对偶性的必要条件。</p>
<p>最后一个条件被称为互补松弛条件。</p>
<p>在最大熵模型的学习问题中只有等式约束条件，因此不用太关注互补松弛条件。</p>
<p>关于互补松弛条件的含义具体可以查看<a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">视频</a> 40分左右的讲解。</p>
<p>可以参考统计学习方法书中的例6.2来感受一下如何使用对偶性以及$KKT$条件求解最大熵模型:</p>
<p>已知随机事件$X = {A,B,C,D,E}$ 各自发生的概率$P(y_i), \ i = 1,\cdots,5$。</p>
<p>要求解随机事件$X$ 的最大熵模型$P(y_i),\ i=1,\cdots, 5$</p>
<p>对于随机事件$X$ 有约束条件: </p>
<p>$P(y_1) + P(y_2) = \tilde{P}(y_1) + \tilde{P}(y_2)= 3/10$，且 $\sum_i P(y_i) = \sum_i \tilde{P}(y_i) = 1$。</p>
<p>则原始问题 $p^{<em>}$ 表示为:<br>$$<br>\begin{aligned}<br>&amp;min \ -H(P)=\sum_{i=1}^5P(y_i)logP(y_i)\<br>&amp;s.t \  P(y_1) + P(y_2) = \tilde{P}(y_1) + \tilde{P}(y_2)= 3/10\<br>&amp;\quad \quad \sum_i P(y_i) = \sum_i \tilde{P}(y_i) = 1<br>\end{aligned}<br>$$<br>设拉格朗日函数 $L(P,w)$ , 其中 $w$ 是前面介绍拉格朗日函数里等式约束中的参数向量 $\alpha$。<br>$$<br>L(P,w) = -H(P) + w_1(P_(y_1)+P(y_2)-3/10) + w_0(\sum_{i=1}^5P(y_i)-1)\<br>p^{</em>} = \underset{x}{min} \ \underset{w}{max} L(x,w)\<br>d^{*} = \underset{w}{max} \ \underset{x}{min} L(x,w)<br>$$<br>$P$ 则指代最大熵模型中的$P(y_i)$，</p>
<p>将 $w$ 作为参数求解 ${\partial L \over \partial P(y_i)} = 0$， 此时偏导的零点为原函数的最小值点，</p>
<p>得到用参数$w = {w_0,w_1}$ 表示的 $P_w(y_i)$。</p>
<p>再使用 $P_w(y_i)$ 表示 $L(P_w,w)$ 。</p>
<p>最后求解 ${\partial L \over \partial w_i} = 0$， 此时偏导的零点为原函数的最大值点，</p>
<p>得到参数 $w$ 的解，将 $w$ 带入 $P_w(y_i)$ 得到随机事件 $X$ 的最大熵模型。</p>
<p>在这个例题中拉格朗日对偶性告诉我们:</p>
<p>由于原问题$min \ -H(P)$ 是一个凸优化问题，</p>
<p>先将 $w$ 作为参数 $P(y_i)$ 作为变量求解问题($d^{*}$)，</p>
<p>和先将 $P(y_i)$ 作为参数 $w$ 作为变量求解问题( $p^{*}$)。</p>
<p>最终的解是一样的($d^{<em>} = p^{</em>}$)。</p>
<p>上述例题在求解对偶问题时可以看到使用了求偏导找零点求最值的过程，</p>
<p>这其实就是在使用 $KKT$ 条件求解强对偶关系问题中最优值的方法。</p>
<p><strong>KKT条件为什么能求出对偶问题最优解?</strong></p>
<p>KKT条件中的梯度为0的条件其实引出了如何构造出拉格朗日函数的问题。</p>
<p>下面以 <a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">视频</a> 中的例子结合 <a href="https://zhuanlan.zhihu.com/p/99945521" target="_blank" rel="noopener">知乎</a> 的推导进行讲解。</p>
<p>设有原始问题如下，其中$x=(x_1,x_2)$ 是一个二维向量，讨论仅含有一个等式约束 $h(x)$ 的情况。<br>$$<br>\begin{aligned}<br>\underset{x\in R^n}{min}\quad &amp; f(x) = x_1^2+x_2^2\<br>s.t \quad &amp; h(x) = 0\<br>\end{aligned}<br>$$<br>下图中蓝色同心圆为 $f(x)$ 的等高线，其梯度$\nabla_x f(x)$为圆上向外的法线，即蓝色箭头。</p>
<p>黄色曲线为等式约束 $h(x)$，其梯度 $\nabla_x h(x)$  为黄色曲线上的法线，即黄色箭头。</p>
<p><img src="/.io//timg.gif" data-original="explain_kkt.png" height="500" width="600/"></p>
<p>假设已有点$x=(x_1,x_2)$ ，我们想找到符合约束条件 $h(x)$ 的点$x{<em>}=(x_1{</em>},x_2{*})$ 使得 $f(x)$ 最小。</p>
<p>设 $x{*}-x = \delta x$ 那么 $\delta x$ 要满足: $f(x+\delta x) &lt; f(x)$ 且 $h(x+\delta x) = 0$ 。</p>
<p>我们知道从 $x$ 到 $x{*}$ ， $\delta x$ 必须在约束条件 $h(x)$ 上移动，即只能沿着与 $\nabla_x h(x)$ 垂直的方向移动，</p>
<p>所以有等式 $\delta x\nabla_x h(x) = 0$ 。</p>
<p>同时从上图中可以看到在 $\nabla f(x) = \beta \nabla h(x)$ 时能取到符合约束条件的极值点$x{*}$。<br>$$<br>\because \nabla_x f(x) = \beta \nabla_x h(x),\ \delta x\nabla_x h(x) = 0\<br>\therefore \delta x \nabla_x f(x) = \delta x \beta \nabla_x h(x) = 0\<br>\therefore \nabla_x L(x,\beta) = \nabla_x f(x) + \beta \nabla_x h(x) = 0\<br>\therefore L(x,\beta) = f(x) + \beta h(x)<br>$$<br>由于在求解最大熵模型中没有涉及到不等式约束，</p>
<p>这里不再展示不等式约束情况下推导拉格朗日函数的具体细节。可以查看<a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">视频</a> 6min30s 左右的讲解。</p>
<h3 id="推导最大熵模型的学习过程"><a href="#推导最大熵模型的学习过程" class="headerlink" title="推导最大熵模型的学习过程"></a>推导最大熵模型的学习过程</h3><blockquote>
<p>相关参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/83765331" target="_blank" rel="noopener">李航《统计学习方法》最大熵模型p(y|x)推导的正确过程</a></p>
</blockquote>
<p>前文已经介绍了最大熵模型的定义，现在结合拉格朗日函数以及对偶性求解最大熵模型。</p>
<p>首先写出原始问题以及其约束条件。</p>
<p>统计学习此处给出的约束条件与其推导过程存在问题，此处推导过程主要参考上方参考链接处的方式。<br>$$<br>\begin{aligned}<br>min  \ -H(P) &amp;=  \sum_{x\in X,y \in Y}\tilde{P}(x)P(y|x)logP(y|x)\<br>s.t. &amp;\quad 1 - \sum_{x\in X,y\in Y}P(y|x)\tilde{P}(x) = 0\<br>&amp;\quad E_p(f_i) - E_{\tilde{P} }(f_i) = 0, \ i=1,\cdots,n\\</p>
<p>E_{\tilde{P} }(f) &amp;= \sum_{x\in X,y\in Y}\tilde{P}(x,y)f(x,y)\<br>E_{P}(f) &amp;= \sum_{x\in X,y\in Y}\tilde{P}(x)P(x|y)f(x,y)<br>\end{aligned}<br>$$<br>此处将$P(X=x_i)$ 简写为 $P(x)$ ，将$P(Y=y_j)$ 简写为 $P(y)$，将 $P(Y=y_j|X=x_i)$ 简写为$P(y|x)$，</p>
<p>将$P(X=x_i, Y=y_j)$ 简写为 $P(x,y)$。</p>
<p>最大熵模型中共有n个特征函数$f_i(x,y)$ ，其中变量$P$ 指代最大熵模型$P(y|x)$。</p>
<p>将上述原始问题用拉格朗日函数改写为等价问题。<br>$$<br>\begin{aligned}<br>L(P,w) =&amp; -H(P) + w_0[1 - \sum_{x\in X,y\in Y}P(y|x)\tilde{P}(x)]+\sum_{i=1}^nw_i(E_p(f_i) - E_{\tilde{P} }(f_i))\</p>
<p>L(P,w) =&amp; \sum_{x\in X,y \in Y}\tilde{P}(x)P(y|x)logP(y|x) + w_0[1 - \sum_{x\in X,y\in Y}P(y|x)\tilde{P}(x)]\<br>&amp; +\sum_{i=1}^nw_i[\sum_{x\in X,y\in Y}\tilde{P}(x,y)f(x,y) - \sum_{x\in X,y\in Y}\tilde{P}(x)P(x|y)f(x,y)]\\<br>p^{<em>} =&amp; \underset{P\in C}{min} \ \underset{w}{max} L(P,w)\<br>d^{</em>} =&amp; \underset{w}{max}\ \underset{P\in C}{min} L(P,w)\<br>\end{aligned}<br>$$<br>最大熵模型的学习最终就是要求出给定训练集$T$ 对应的$P(Y=y_i|X=x_i)$ ，即 $L(P,w)$ 中的 $P$。</p>
<p>根据 $KKT$ 条件，我们需要先求出$\nabla_P L(P,w) = 0$ 时 $P$ 关于参数 $w$ 的表达式。</p>
<p>对每个 $x_i$ 和 $y_j$ 的条件概率 $P(Y=y_i|X=x_i)$ 求 $L(P,w)$ 的偏导，(下文为了简洁用$P(y|x)$表示)。<br>$$<br>\begin{aligned}<br>{\partial L(P,w) \over \partial P(y|x)} =&amp; \tilde{P}(x)[logP(y|x)+1] - \tilde{P}(x)w_0 + \tilde{P}(x)\sum_{i=1}^n w_i f_i(x,y)\<br>=&amp;\tilde{P}(x)[logP(y|x) + 1 - w_0 - \sum_{i=1}^n w_i f_i(x,y) ]\<br>\because &amp;\quad \tilde{P}(x) \not= 0 \quad and \quad  {\partial L(P,w) \over \partial P(y|x)}=0\<br>\therefore &amp;\quad logP(y|x) + 1 - w_0 - \sum_{i=1}^n w_i f_i(x,y) = 0\<br>\therefore &amp;\quad P_w(y|x) = {exp(\sum_{i=1}^nw_if_i(x,y))\over exp(1-w_0)}\<br>\because &amp;\quad \sum_{y\in Y}P(y|x) = 1\<br>\therefore &amp;\quad \sum_{y\in Y}P(y|x) = {\sum_{y\in Y}exp(\sum_{i=1}^nw_if_i(x,y))\over exp(1-w_0) } = 1\<br>\therefore &amp;\quad Z_w(x) = exp(1-w_0) = \sum_{y\in Y}exp(\sum_{i=1}^nw_if_i(x,y))\<br>\therefore &amp;\quad P_w(y|x) = {exp(\sum_{i=1}^nw_if_i(x,y))\over Z_w(x)} = {exp(\sum_{i=1}^nw_if_i(x,y))\over \sum_{y\in Y}exp(\sum_{i=1}^nw_if_i(x,y))}<br>\end{aligned}<br>$$<br>其中 $Z_w(x)$ 表示最优化参数 $w$ 下的规范化因子，$P_w(y|x)$ 表示最优化参数 $w$ 下的最大熵模型。</p>
<p>注意到我们使用$Z_w(x)$ 去替换分母$exp(1-w_0)$ 有一个好处就是能说明 $P_w(y|x)$ 的值与 $w_0$ 无关，</p>
<p>或者说$w_0$ 的值是由$w_i,\ i=1,\cdots,n$ 共同决定的。</p>
<p>目前我们只求出了 $P(y|x)$ 关于 $w$ 的表达式 $P_w(y|x)$，我们需要求解出 $w$ 才能真正求出 $P_w$。</p>
<p>或者说我们只求出了对偶问题中的 $I(w)=\underset{P}{min} \ L(P,w) = L(P_w,w)$ ，还需要求解 $w{*}=\underset{w}{argmax}\ I(w)$。</p>
<p>那么最大熵模型的学习归结为对偶函数 $I(w)$ 的极大化，最终最大熵模型为 $P_{w{*}}(y|x)$。</p>
<p>由于$P_w(y|x)$ 的值与 $w_0$ 无关，且 $w_0[1 - \sum_{x\in X,y\in Y}P(y|x)\tilde{P}(x)]=0$ 对$L(P_w,w)$ 的值没有贡献，</p>
<p>因此此项在化简中可行省略。现在将 $P_w$ 带入$L(P_w,w)$ 并化简:<br>$$<br>\begin{aligned}<br>L(P_w,w) =&amp; \sum_{x\in X,y \in Y}\tilde{P}(x)P_w(y|x)logP_w(y|x) \<br>&amp; +\sum_{i=1}^nw_i[\sum_{x\in X,y\in Y}\tilde{P}(x,y)f_i(x,y) - \sum_{x\in X,y\in Y}\tilde{P}(x)P_w(x|y)f_i(x,y)]\<br>=&amp; \sum_{x\in X,y \in Y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y) + \sum_{x\in X,y\in Y}\tilde{P}(x)P_w(y|x)[logP_w(y|x)-\sum_{i=1}^nw_if_i(x,y)]\<br>=&amp; \sum_{x\in X,y \in Y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y) - \sum_{x\in X,y\in Y}\tilde{P}(x)P_w(y|x)logZ_w(x)\\<br>\because &amp;\quad \sum_yP(y|x) = 1\<br>\therefore &amp;\quad I(w) = L(P_w,w)= \sum_{x\in X,y \in Y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y) - \sum_{x\in X}\tilde{P}(x)logZ_w(x)<br>\end{aligned}<br>$$</p>
<p>统计学习方法在 <strong>6.2.4 极大似然估计</strong>中证明了对偶函数 $I(w)$ 的极大化等价于最大熵模型的极大似然估计。</p>
<p>设条件概率分布$P_w(y|x)$ 的对数似然函数为$L(P_w)$，那么有以下等式关系:<br>$$<br>\begin{aligned}<br>L(P_w) =&amp; log\prod_{x\in X,y\in Y} P_w(y|x)^{\tilde{P}(y,x)} \<br>=&amp; \sum_{x\in X,y\in Y}\tilde{P}(y,x) logP_w(y|x)\<br>=&amp; \sum_{x\in X,y \in Y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y) - \sum_{x\in X}\tilde{P}(x)logZ_w(x)\<br>\therefore &amp;\quad L(P_w) = I(w)<br>\end{aligned}<br>$$<br>这样，最大熵模型的学习问题就转换为具体求解对数似然函数极大化或对偶函数极大化的问题。</p>
<h2 id="模型学习的最优化算法"><a href="#模型学习的最优化算法" class="headerlink" title="模型学习的最优化算法"></a>模型学习的最优化算法</h2><blockquote>
<p>常用的方法有改进的迭代尺度法、梯度下降法、牛顿法或拟牛顿法。</p>
<p>此处主要针对最大熵模型讨论改进的迭代尺度法(IIS)和牛顿法。</p>
<p>相关参考:</p>
<p><a href="https://www.bilibili.com/video/BV1g64y1h7Lc" target="_blank" rel="noopener">深度之眼《李航统计学习方法》课程</a></p>
<p><a href="https://www.cnblogs.com/pinard/p/6093948.html" target="_blank" rel="noopener">最大熵模型原理小结 - 刘建平Pinard</a></p>
</blockquote>
<p>可以想到将$P_w$ 代入原式中再求解 $\nabla_w L(P_w,w) = 0$，</p>
<p>但实际上直接对$L(P_w,w)$ 求 $w$ 的偏导数求解十分困难，需要用到最优化算法求解。</p>
<h3 id="改进的尺度迭代法"><a href="#改进的尺度迭代法" class="headerlink" title="改进的尺度迭代法"></a>改进的尺度迭代法</h3><p>改进的尺度迭代法 (IIS) 一般只用于最大熵模型，</p>
<p>它假设当前的参数向量是 $w$ , 我们希望找到一个新的参数向量 $w+\delta$ , 使得对偶函数 $I(w)$ 增大, </p>
<p>重复此操作, 以达到 $\underset{w}{max}\ I(w)$  的目的。</p>
<p>将这个过程表述为等式:<br>$$<br>\begin{aligned}<br>&amp; I(w+\delta) - I(w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y)-\sum_{x\in X} \tilde{P}(x)log{Z_{w+\delta}(x)\over Z_w(x)}\\</p>
<p>\because &amp; -log\ x \geq 1-x \ ,\ (x&gt;0)\<br>\therefore &amp; \ I(w+\delta) - I(w)  \geq \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x){Z_{w+\delta}(x)\over Z_w(x)}\\</p>
<p>set \ &amp; A(\delta|w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x){Z_{w+\delta}(x)\over Z_w(x)}\<br>&amp; A(\delta|w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x)\sum_{y\in Y}P_w(y|x)exp\sum_{i=1}^n\delta_if_i(x,y)\<br>\therefore \ &amp;I(w+\delta) - I(w) \geq A(\delta|w)<br>\end{aligned}<br>$$<br>我们可以最大化$A()$ 来间接找到能使 $I(w)$ 增大最快的 $\delta$ 。</p>
<p>于是想到求解 $A(\delta|w)$ 的最大值，即求出$A(\delta|w)$ 关于 $\delta$ 的导数，找到零点。</p>
<p>但是如果这么做的话会发现，由于$\delta$ 是和 $w$ 同维度的向量，就需要对每个分量$\delta_i$求导。</p>
<p>那么原式中的 $exp\sum_i^n\delta_if_i(x,y)$ 在对$\delta_i$ 求导后就会变成 $f_i(x,y)exp\sum_i^n\delta_if_i(x,y)$ ,</p>
<p>我们发现由于指数函数的存在求导不能将偏导数摆脱其他 $\delta_j$ 分量，使其成为只关于$\delta_i$ 的函数，</p>
<p>我们不能使用未知的 $\delta_j$ 求解$\delta_i$ 的偏导数零点。</p>
<p>为了解决这个问题我们需要引入一个函数：$f^{ # }(x,y) = \sum_if_i(x,y)$ </p>
<p>以及一个不等式 Jensen不等式: </p>
<p>对于凸函数 $\phi$ 以及满足$\sum_ia_i = 1$ 的权重 $a_i$，那么就有$\phi(\sum_ia_ib_i)\leq \sum_i a_i\phi(b_i)$<br>$$<br>\begin{aligned}<br>&amp; set \ a_i = {f_i(x,y)\over f^{ # }(x,y)} \ ,\ b_i = \delta_if^{ # }(x,y)\<br>&amp; A(\delta|w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x)\sum_{y\in Y}P_w(y|x)exp\sum_{i=1}^n a_ix_i\\</p>
<p>\because &amp; \phi(x) = exp(x)\\<br>\therefore &amp; \phi(\sum_ia_ib_i)\leq \sum_i a_i\phi(b_i)\<br>\therefore &amp; exp(\sum_i^n {f_i(x,y)\over f^{ # }(x,y)}\delta_if^{ # }(x,y)) \leq \sum_i^n {f_i(x,y)\over f^{ # }(x,y)} exp(\delta_if^{ # }(x,y))\\<br>&amp; B(\delta|w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x)\sum_{y\in Y}P_w(y|x)\sum_i^n {f_i(x,y)\over f^{ # }(x,y)} exp(\delta_if^{ # }(x,y))\<br>&amp; A(\delta|w) \geq B(\delta|w)<br>\end{aligned}<br>$$<br>于是我们从 $A(\delta|w)$ 放缩得到 $B(\delta|w)$ , 即有$I(w+\delta) - I(w) \geq B(\delta|w)$ 。</p>
<p>由于现在的指数函数在求和内，那么无关变量$\delta_j$ 就是无关变量对$\delta_i$求导为0，</p>
<p>现在再求$B(\delta|w)$ 对 $\delta_i$ 的偏导数:<br>$$<br>{\part B(\delta|w)\over \part \delta_i} = \sum_{x\in X y\in Y} \tilde{P}(x,y)f_i(x,y) - \sum_{x\in X} \tilde{P}(x)\sum_{y \in Y}P_w(y|x)f_i(x,y)exp(\delta_i f^{ # }(x,y))\<br> set \quad {\part B(\delta|w)\over \part \delta_i} = 0\<br> E_{\tilde{P} }(f_i) = \sum_{x\in X y\in Y} \tilde{P}(x,y)f_i(x,y) = \sum_{x\in X,y\in Y} \tilde{P}(x)P_w(y|x)f_i(x,y)exp(\delta_i f^{ # }(x,y))<br>$$<br>现在只要求解上述关于 $\delta_i$ 的方程就能求出 $w$ 的最优解。</p>
<p>由于$f^{ # }(x,y)$ 并不是对任何$x,y$ 都有 $f^{ # }(x,y)=M$ 因此需要通过牛顿迭代法来求解。</p>
<h3 id="牛顿法与拟牛顿法"><a href="#牛顿法与拟牛顿法" class="headerlink" title="牛顿法与拟牛顿法"></a>牛顿法与拟牛顿法</h3><blockquote>
<p>相关参考:</p>
<p><a href="https://cloud.tencent.com/developer/article/1390228" target="_blank" rel="noopener">优化算法——牛顿法(Newton Method)</a></p>
</blockquote>
<p><strong>首先牛顿法能做什么？</strong></p>
<p>牛顿法可以通过迭代逼近的方法找到函数极值点。</p>
<p><strong>牛顿法如何找到极值点？</strong></p>
<p>牛顿法可以通过泰勒二阶展开推导得到。假设我们要求 $f(x)$ 的极值点, 即 $f’(x)$ 的零点。</p>
<p>我们知道 $f(x)$ 可以通过二阶泰勒展开近似表示为: </p>
<p>$f(x)= f(x_k) + f’(x_k)(x-x_k) + {1\over2}f’’(x_k)(x-x_k)^2$</p>
<p>对上述式子求导并令其为0得到: $f’(x_k) + f’’(x_k)(x-x_k) = 0$ 。 </p>
<p>因此有  $x= x_k- {f’(x_k)\over f’’(x_k)}$, 假设我们已经到达了点$(x_k, f(x_k))$ 我们可以用这个等式迭代毕竟极值点。</p>
<p>当然$f(x)$ 需要存在极值点 即存在 $\nabla f(x) = 0$</p>
<p><strong>那么什么是拟牛顿法?</strong></p>
<p>当 $f(x)$ 是一个关于向量 $x$ 的函数时求解其导数和二阶导数会使问题变得复杂。</p>
<p>当 $x$ 为向量时其二阶泰勒展开变为: $f(x) = f(x_k) + g(x_k)(x-x_k) + {1\over2}(x-x_k)^TH(x_k)(x-x_k) $。</p>
<p>其中 $g(x_k)= \nabla f(x_k)$ , $H(x_k)$ 是 $f(x)$ 的海赛矩阵(Hesse matrix):<br>$$<br>H(x) =<br>\begin{bmatrix}<br>{\part^2f \over \part x_i\part x_j}<br>\end{bmatrix}<em>{n\times n}<br>$$<br>那么迭代公式则改写为: $x</em>{k+1} = x_k - H_k^{-1}g_k$ , 其中 $H_k = H(x_k)$ , $g_k = g(x_k)$</p>
<p>为了求解下一个点$x_{k+1}$ 我们需要反复计算 $n\times n $ 矩阵的逆 $H^{-1}_k$ , 这对计算机非常的不友好。</p>
<p>为了避免求解逆矩阵的运算我们可以将迭代公式稍微变化一下, 于是产生了拟牛顿法。</p>
<p>在统计学习方法的附录中介绍了两种拟牛顿法 DFP算法和 BFGS算法, </p>
<p>其中后者更为流行因此这里仅介绍 BFGS算法。</p>
<p><strong>BFGS算法</strong></p>
<p>记 $y_k = g(x_{k+1}) - g(x_k)$ , $\delta_k = x_{k+1} - x_k$ 。<br>$$<br>\because \nabla f(x) = g(x_k) + H_k(x-x_k),\quad set \ x= x_{k+1}\<br>\therefore \nabla f(x_{k+1}) = g(x_{k+1}) \<br>\therefore g(x_{k+1}) - g(x_k) = H_k(x_{k+1} - x_k)\<br>\therefore y_k = H_k\delta_k<br>$$<br>BFGS算法考虑使用$B_{k+1}$ 逼近 $H_k$  </p>
<p>将原先的迭代公式改为: $B_{k+1} \delta_k= y_k$</p>
<p>我们假设构造的矩阵$B_k$ 存在这样的递推关系: $ B_{k+1} = B_k +P_k+Q_k$</p>
<p>为了满足迭代公式$B_{k+1} \delta_k= y_k$, 则有:<br>$$<br>B_{k+1}\delta_k = B_k\delta_k +P_k\delta_k + Q_k\delta_k\<br> P_k\delta_k = y_k\<br> Q_k\delta_k = - B_k\delta_k\<br> P_k = { y_k y_k^T\over y_k^T\delta_k}\<br> Q_k = { B_k \delta_k\delta_k^T B_k \over \delta_k^T B_k\delta_k}<br>$$<br>当取 $B_0$ 为正定对称矩阵则能保证之后求得的 $B_k$ 都为正定矩阵。</p>
<p>BFGS算法引入了矩阵$B$ 代替海赛矩阵 $H$,   虽然重点推导了$B_k$ 的递推式但是不要忘记</p>
<p>我们最终要求的是令 $g(x_k)=0$ 的解 $x_k$ 。</p>
<p>具体的算法见李航书中附录B，拟牛顿法 —— 算法B.3。</p>
<p><img src="/.io//timg.gif" data-original="BFGS.png"></p>
<p>其中第三步中的 $p_k = \delta_k = x_{k+1} - x_k$ , 这里可能会令人疑惑: </p>
<p>为什么会与 $B_k \delta_k = y_k$ 冲突？因为我们要求令 $g(x_{k+1})=0$ 的解$x_{k+1}$ ,</p>
<p>因此我们令 $y_k = g(x_{k-1}) -g(x_k) = 0 - g(x_k)$ , 于是就有了 $B_kp_k=-g_k$ 。</p>
<p><strong>使用拟牛顿算法求解最大熵模型参数$w$</strong></p>
<p>回到最大熵模型的学习问题上。</p>
<p>我们已经求出了最大熵模型 $P(y|x)$ 关于参数 $w$ 的表达式:<br>$$<br>P_w(y|x) = {exp(\sum_{i=1}^nw_if_i(x,y))\over \sum_{y\in Y} exp(\sum_{i=1}^nw_if_i(x,y))}\<br>$$<br>我们希望通过极大化对偶函数$I(w)$ 或似然函数$L(P_w)$ 找到对应的参数 $w$ 。</p>
<p>于是在 改进的迭代尺度法 中我们通过放缩找到了$I(w+\delta) - I(w)$ 的下界函数 $B(\delta|w)$ :<br>$$<br> B(\delta|w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x)\sum_{y\in Y}P_w(y|x)\sum_i^n {f_i(x,y)\over f^{ # }(x,y)} exp(\delta_if^{ # }(x,y))\<br>$$<br>我们要做的就是求解$B(\delta|w)$ 的最大值。使用拟牛顿法进行迭代求解,</p>
<p>其中$\delta_i^k=w_i^{k+1}-w_i^{k}$ 表示第k次迭代参数$w_i$ 的增量, $\delta{<em>}_i$ 为最终解则有:<br>$$<br>g(\delta_i) = {\part B(\delta|w)\over \part \delta_i} \<br>g(\delta_i{</em>}) = {\part B(\delta{<em>}|w)\over \part \delta_i{</em>}}=0\<br>\delta_i^{k+1} = \delta_i^{k} - {g(\delta_i^k) \over g’(\delta_i^k)}<br>$$<br>我们也可以不使用改进的迭代尺度算法(IIS) 而是直接针对对偶函数$I(w)$ 使用拟牛顿法求解参数 $w$。</p>
<p>求解最大熵模型$P_w(y|x)$ 要求我们最大化对偶函数 $I(w)$ , 书中设$f(w) = - I(w)$ 有最小值, </p>
<p>则目标函数为 $\underset{w}{min} \ f(w)$, 对$f(w)$ 的一阶导数向量 $g(w)$, 其中$w$  为n维的向量, $w_i$ 表示第i个分量:<br>$$<br>\underset{w}{min} \ f(w) =  \sum_{x\in X}\tilde{P}(x)logZ_w(x) - \sum_{x\in X,y \in Y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y)\<br>g(w) = { {\part f(w)\over w_1}, \cdots,{\part f(w)\over w_n} }\<br>{\part f(w)\over w_i} = \sum_{x\in X y\in Y} \tilde{P}(x)P_w(y|x)f_i(x,y)-\sum_{x\in X y\in Y} \tilde{P}(x,y)f_i(x,y)\<br>$$<br>使用BFGS算法求解目标函数最优解过程如下:</p>
<p><img src="/.io//timg.gif" data-original="BFGS_for_ME.png"></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="/mp3/Aimer - ONE.flac">
            </audio>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci='fb4e1a3e8686e267e168'
        data-cs='c6362b99dcd8b1231e724f71ad638bd6faf8f581'
        data-r='PeiGiZhu.github.io'
        data-o='PeiGiZhu'
        data-a='PeiGiZhu'
        data-d='true'
    >查看评论</div>



        
   
        
          <section id="valine-container" style="margin:10px;padding:10px;background:#fff;">
            <!--载入js，在
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(e){e.imageLazyLoadSetting.processImages=t;var n=e.imageLazyLoadSetting.isSPA,i=e.imageLazyLoadSetting.preloadRatio||1,r=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){n&&(r=o());for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];e=function(){r=r.filter(function(t){return o!==t})},(t=o).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,t.removeAttribute("data-original"),e&&e()},t.src!==i&&(n.src=i))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),e.addEventListener("resize",a),e.addEventListener("orientationchange",a)}(this);</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(e){e.imageLazyLoadSetting.processImages=t;var n=e.imageLazyLoadSetting.isSPA,i=e.imageLazyLoadSetting.preloadRatio||1,r=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){n&&(r=o());for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];e=function(){r=r.filter(function(t){return o!==t})},(t=o).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,t.removeAttribute("data-original"),e&&e()},t.src!==i&&(n.src=i))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),e.addEventListener("resize",a),e.addEventListener("orientationchange",a)}(this);</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(e){e.imageLazyLoadSetting.processImages=t;var n=e.imageLazyLoadSetting.isSPA,i=e.imageLazyLoadSetting.preloadRatio||1,r=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){n&&(r=o());for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];e=function(){r=r.filter(function(t){return o!==t})},(t=o).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,t.removeAttribute("data-original"),e&&e()},t.src!==i&&(n.src=i))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),e.addEventListener("resize",a),e.addEventListener("orientationchange",a)}(this);</script></body>之前插入即可-->
<!--Leancloud 操作库:-->
<!-- <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> -->
<!--Valine 的核心代码库-->
<!-- <script src="//unpkg.com/browse/valine/dist/Valine.min.js"></script> -->




  <div class="valine_comment v link" 
    data-enable='true'
    data-ae='true'
    data-notify='true'
    data-verify='false'
    data-visitor='true'
    data-avatar='wavatar'
    data-av=AV
    data-el='.valine_comment'
    data-emurl='https://cloud.panjunwen.com/alu'
    data-emlist='狂汗.png,不说话.png,汗.png,坐等.png,献花.png,不高兴.png,中刀.png,害羞.png,皱眉.png,小眼睛.png,暗地观察.png'
    data-appid='f0K5v7NsgEDxY2GRAFmmKBuW-gzGzoHsz'
    data-appkey='aKzBnQS2KG8El1SXhdrxLoPP'
    data-pagesize='10'
    data-placeholder='有话要说？'
    >
  </div>




          </section>
        

    </div>
    
</div>


    </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(e){e.imageLazyLoadSetting.processImages=t;var n=e.imageLazyLoadSetting.isSPA,i=e.imageLazyLoadSetting.preloadRatio||1,r=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){n&&(r=o());for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];e=function(){r=r.filter(function(t){return o!==t})},(t=o).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,t.removeAttribute("data-original"),e&&e()},t.src!==i&&(n.src=i))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),e.addEventListener("resize",a),e.addEventListener("orientationchange",a)}(this);</script></body>




  
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>





<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
