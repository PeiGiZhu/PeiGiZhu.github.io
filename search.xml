<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2015ICPC-沈阳-B</title>
    <url>/2020/07/12/2015ICPC-%E6%B2%88%E9%98%B3-B/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5510" target="_blank" rel="noopener">B.Bazinga</a></p>
<p>题意<br>给出n&lt;500个字符串每个字符串长度不超过2000 要求找到某个最大的i是的对于j&lt;i 存在s[j]不是s[i]的子串</p>
<p>题解<br>首先想到m*n^2 的算法 </p>
<p>再根据子串的传递性 :假如a是b的子串 且b是c的子串那么a也是c的子串</p>
<p>剪枝优化暴力 首先判断两个相邻的是否前一个s[j]是后一个的子串s[i]  </p>
<p>若是则将前面的标记为1  一直比较s[i]与s[i+1] s[i+1]与s[i+2]….</p>
<p>对于某个子串s[x] ,x&gt;i 若s[i]是s[x]的子串那么 s[j] ,j&lt;i, 被标记为1的一定都是s[i]的子串也是s[x]的子串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> nex[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn][<span class="number">2005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getnex</span><span class="params">(<span class="keyword">char</span> *b)</span></span>&#123;</span><br><span class="line">    nex[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = nex[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; b[i] != b[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line">        <span class="keyword">if</span>(b[i] == b[j+<span class="number">1</span>]) ++j;</span><br><span class="line">        nex[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> *a ,<span class="keyword">char</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> lena=<span class="built_in">strlen</span>(a),lenb=<span class="built_in">strlen</span>(b);</span><br><span class="line">    getnex(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[i] != b[j+<span class="number">1</span>]) j = nex[j];</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j+<span class="number">1</span>]) ++j;</span><br><span class="line">        <span class="keyword">if</span>(j == lenb<span class="number">-1</span>) <span class="keyword">return</span> i-lenb+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> t,cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;s[i]);</span><br><span class="line">            <span class="comment">//vis[i]=0;</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;s[i]&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(kmp(s[i],s[i<span class="number">-1</span>])&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                vis[i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//a=s[i],b=s[j];</span></span><br><span class="line">                <span class="comment">//cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span>(vis[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(kmp(s[i],s[j])&gt;=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;s[i]&lt;&lt;" "&lt;&lt;s[j]&lt;&lt;endl;</span></span><br><span class="line">                ans=i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"Case #"&lt;&lt; cnt++ &lt;&lt;": ";</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>,cnt++,ans);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>kmp</tag>
        <tag>暴力</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>2015ICPC-沈阳-F</title>
    <url>/2020/07/12/2015ICPC-%E6%B2%88%E9%98%B3-F/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5514" target="_blank" rel="noopener">F.Frog</a></p>
<p>题意</p>
<p>n个青蛙m个石子 下标从0到m-1</p>
<p>每只青蛙一次条ai格 假如它在x处下次它会在 (ai+x)%m 处</p>
<p>让这n只青蛙一直跳 求被青蛙跳到的石子下标和 被跳过多次只计算1次</p>
<p>题解</p>
<p>不难发现 对于某只青蛙而言它能跳到的石头一定是gcd(a[i],m)的倍数</p>
<p>而对于某块石头x而言若存在gcd(a[i],m)是x的因子 即 gcd(a[i],m)|m 那它就会被跳到</p>
<p>那我们对于gcd(a[i],m)=g，它产生的贡献是：</p>
<p>g ×(首项+末项)× (项数)/2=g×(1+m/g-1)×(m/g-1)/2=m×(m/g-1)/2</p>
<p>那么问题来了，被重复计算的怎么减掉呢？</p>
<p>由于gcd(a[i],m)一定是m的因子集合的子集 我们可以用它的因子来计算贡献</p>
<p>先求出m的所有因子x,存入phi中,再判断这些因子x中哪些是gcd(a[i],m)的倍数</p>
<p>cnt[x]=1 表示第x个因子是gcd(a[i],m)的倍数 要被计算到贡献中1次</p>
<p>最后在遍历所有因子 求它们对ans的贡献</p>
<p>对于第x个因子它产生的贡献是 ：m × (m/phi[x]-1)/2 ×(cnt[x]-repeat[x])</p>
<p>repeat[x]表示是第x个因子倍数的石子已经被重复计算过的次数 要从贡献中减去</p>
<p>每次求完这个因子x的贡献后 for循环找出比它大的因子y中有哪些是因子x的倍数</p>
<p>​并更新 repeat[y]+=（cnt[x]-repeat[x])  表示因子y的贡献被它更小的因子x已经多计算了</p>
<p> (cnt[x]-repeat[x]) 次 这部分就是容斥原理的体现</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> gcd[Max],cnt[Max],repeat[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t,ti=<span class="number">1</span>;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ll&gt;phi;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="built_in">memset</span>(repeat,<span class="number">0</span>,<span class="keyword">sizeof</span> repeat);</span><br><span class="line">        ll n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ll temp;<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">            gcd[i]=__gcd(temp,m);</span><br><span class="line">        &#125;</span><br><span class="line">        phi.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m%i)<span class="keyword">continue</span>;</span><br><span class="line">            phi.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i*i!=m)phi.push_back(m/i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(phi.<span class="built_in">begin</span>(),phi.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;phi.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(phi[j]%gcd[i])<span class="keyword">continue</span>;</span><br><span class="line">                cnt[j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;phi.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt[i])<span class="keyword">continue</span>;</span><br><span class="line">            ans+=m*(m/phi[i]<span class="number">-1</span>)/<span class="number">2</span>*(cnt[i]-repeat[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;phi.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(phi[j]%phi[i])<span class="keyword">continue</span>;</span><br><span class="line">                repeat[j]+=(cnt[i]-repeat[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;ti++&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不能直接通过枚举gcd(a[i],m)容斥直接计算贡献 就是用gcd(a[i],m)组成的集合来计算ans呢</p>
<p><strong>不加入求m的因子集合</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> gcd[Max],cnt[Max],repeat[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t,ti=<span class="number">1</span>;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ll&gt;phi;</span><br><span class="line">        <span class="built_in">memset</span>(repeat,<span class="number">0</span>,<span class="keyword">sizeof</span> repeat);</span><br><span class="line">        ll n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ll temp;<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">            gcd[i]=__gcd(temp,m);</span><br><span class="line">            cnt[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(gcd,gcd+n);</span><br><span class="line"></span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans+=m*(m/gcd[i]<span class="number">-1</span>)/<span class="number">2</span>*(cnt[i]-repeat[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(gcd[j]%gcd[i])<span class="keyword">continue</span>;</span><br><span class="line">                repeat[j]+=(cnt[i]-repeat[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;ti++&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2 12</span></span><br><span class="line"><span class="comment">9 10</span></span><br><span class="line"><span class="comment">3 60</span></span><br><span class="line"><span class="comment">22 33 66</span></span><br><span class="line"><span class="comment">9 96</span></span><br><span class="line"><span class="comment">81 40 48 32 64 16 96 42 72</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///对于第一个样例正确答案是42 而不用m的因子的方法得到的答案是48</span></span><br><span class="line"><span class="comment">///因为6 是gcd(10,12)=2的倍数也是gcd(9,12)=3的倍数 若用这种方法无法消除被重复计算的石子的贡献</span></span><br><span class="line"><span class="comment">///而用m的因子集合来求贡献就一定可以 因为gcd(a[i],m)的集合是因子集合的子集 </span></span><br><span class="line"><span class="comment">///能被跳到的石子一定是m的因子 所以6会被计入因子集合而 gcd的集合中不包括它</span></span><br></pre></td></tr></table></figure>

<p>此外还有一种分析</p>
<p>因为gcd(x,m)|m  所以枚举m的因子 假如对于m的一个因数k，如果存在一个i使得k能被ai整除(能被跳到)，则此时对于所有石头x符合gcd(x,m)==k的都对答案产生贡献：</p>
<p>∑x,{gcd(x,m)=k} = k*∑x/k,{gcd(x/k,m/k)=1}</p>
<p>而</p>
<p>∑x/k,{gcd(x/k,m/k)=1} = φ(m/k)*(m/k)/2</p>
<p>这里用到一个结论小于n于n互质的数的和 sum=φ(n)*n/2</p>
<p>推倒 假设一个数xi与n互质 那么 n-xi也与n互质 (更相减损法求gcd)</p>
<p>所以  sum=(x1 +n-x1)+(x2+n-x2)+…..(xφ(n)+n-xφ(n))/2</p>
<p>​除2是因为每个与n互质的数都被枚举了2次即(n-xi)=xj </p>
<p><a href="https://blog.csdn.net/Joker_He/article/details/107085525" target="_blank" rel="noopener">参考博客</a></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>gcd</tag>
        <tag>数论</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>2015ICPC-沈阳-M</title>
    <url>/2020/07/12/2015ICPC-%E6%B2%88%E9%98%B3-M/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5521" target="_blank" rel="noopener">M.Meeting</a></p>
<p>题意给你n(n&lt;=1e5)个点，m个关系：每个关系代表一个集合，包含权值v，表示该集合集合中两两的距离，还有集合的点的个数cnt和集合里的点的标号，相当于一个有距离的完全图。</p>
<p>保证集合中所有的点的数量不超过1e6。</p>
<p>两个人分别从1点和n点走，只可以在一个点相遇（一个人可以等另一个人），求最短相遇时间和最短时间的前提下在哪些编号的点相遇时间都是最短。</p>
<p>如果无法相遇，输出“Evil John”。</p>
<p>题解</p>
<p>就是求两个点的Dijkstra求最短路径，但是如何建图就很困难。因为一个完全图需要建n*(n-1)/2的边，容易超时，只能用组的方式建边。对于集合中每个点 建立一个虚拟的超级源点 下标记为(n+i)  比较常用的建图技巧</p>
<p>建边 该集合内任意一点x到n+i的距离为0,且n+i到该集合内任意一点距离为v。</p>
<p>这样保证集合中的任意两个点的距离是v。同时新建的图满足迪杰斯特拉算法的要求</p>
<p>可以直接跑最短路</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt;mp[maxn];</span><br><span class="line">ll dis[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Djstar</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> typ)</span></span>&#123;</span><br><span class="line">    dis[typ][start]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; Q;<span class="comment">///堆优化</span></span><br><span class="line">    Q.push(P(<span class="number">0</span>,start));</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        P x=Q.top();Q.pop();</span><br><span class="line">        <span class="keyword">int</span> u=x.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[typ][u])<span class="keyword">continue</span>;</span><br><span class="line">        vis[typ][u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[typ][i.first]&gt;dis[typ][u]+i.second)&#123;</span><br><span class="line">                dis[typ][i.first]=dis[typ][u]+i.second;</span><br><span class="line">                Q.push(P(dis[typ][i.first],i.first));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t,cnt=<span class="number">1</span>;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">            mp[i].<span class="built_in">clear</span>();</span><br><span class="line">            vis[<span class="number">0</span>][i]=vis[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">            dis[<span class="number">0</span>][i]=dis[<span class="number">1</span>][i]=<span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> d,num;<span class="built_in">cin</span>&gt;&gt;d&gt;&gt;num;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> indx;<span class="built_in">cin</span>&gt;&gt;indx;</span><br><span class="line">                mp[indx].push_back(&#123;n+i,<span class="number">0</span>&#125;);</span><br><span class="line">                mp[n+i].push_back(&#123;indx,d&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Djstar(<span class="number">1</span>,<span class="number">0</span>);Djstar(n,<span class="number">1</span>);</span><br><span class="line">        ll minn=<span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;dis[0][i]&lt;&lt;" "&lt;&lt;dis[1][i]&lt;&lt;endl;</span></span><br><span class="line">            minn=<span class="built_in">min</span>(minn,<span class="built_in">max</span>(dis[<span class="number">0</span>][i],dis[<span class="number">1</span>][i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;cnt++&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">if</span>(minn==<span class="number">1e18</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"Evil John"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;minn&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">max</span>(dis[<span class="number">0</span>][i],dis[<span class="number">1</span>][i])==minn)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!flag)<span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;i;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>超源点</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>2019, XII Samara Regional Intercollegiate Programming Contest</title>
    <url>/2020/10/15/2019,%20XII%20Samara%20Regional%20Intercollegiate%20Programming%20Contest/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/gym/102215/problem/D" target="_blank" rel="noopener">D. Country Division</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个n(n&lt;2e5)个点n-1条边的树</p>
<p>q组询问</p>
<p>每次将一些点染红,一些点染蓝</p>
<p>问是否能删掉一条边使得红点相互联通,蓝点相互联通,但红蓝点不能相互联通</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p><a href="https://blog.csdn.net/ccsu_cat/article/details/94004728" target="_blank" rel="noopener">参考博客</a></p>
<p>这题当作树上倍增寻找Lca算法的练习题记录</p>
<p>我们求出所有红点LcaRed，所有蓝点LcaBlue，如果所有蓝点不在LcaRed的子树中或者</p>
<p>所有红点不在LcaBlue的子树中，那么就是yes。</p>
<p>这里有几个技巧：</p>
<ul>
<li><p>我们不选择两两点找公共祖先,而是直接找dfs序最小的点(即dfs最先遍历到的点)</p>
<p>和dfs序最大的点(即dfs最后遍历到的点)的最近公共祖先    </p>
<p>那两个点的公共祖先就是所有红点/蓝点的最近公共祖先 </p>
</li>
</ul>
<ul>
<li><p>如何判断一些点是否为一个点的子孙结点？</p>
<p>记录每个点的Dfsin和Dfsout [Dfsin,Dfsout]表示该点的所有子孙节点对应的dfs序</p>
</li>
</ul>
<p>​               </p>
<ul>
<li><p>那么由于根节点选择的不同是否对判断结果产生影响？事实是不会</p>
<p>若红点连通块和蓝点连通块联通 那么无论以哪个点作为根节点 </p>
<p>必然都不符合条件(如果所有蓝点不在LcaRed的子树中或者所有红点不在LcaBlue的子树中)</p>
<p>反之若以某点为根节点时符合条件(如果所有蓝点不在LcaRed的子树中或者所有红点不在LcaBlue的子树中)</p>
<p>那么任意其他点为根节点时也符合条件</p>
<p><del>不会证明但是画图大概能感觉到</del> </p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">typedef</span> long long ll;</span><br><span class="line">#define endl <span class="string">'\n'</span></span><br><span class="line">#define Turnoff std::ios::sync_with_stdio(<span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">//bool vis[(int)1e7+5];</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt;mp[Max];</span><br><span class="line"><span class="built_in">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="comment">///<span class="markdown">Dfsin/Dfsout 每个点的区间[Dfsin,Dfsout]以内的数</span></span></span><br><span class="line"><span class="comment">///<span class="markdown">表示该点的所有子节点对应的dfs序</span></span></span><br><span class="line"><span class="built_in">int</span> Dfsin[Max],Dfsout[Max];</span><br><span class="line"><span class="built_in">int</span> Fa[Max][<span class="number">20</span>],deep[Max];</span><br><span class="line"><span class="built_in">int</span> Lca(<span class="built_in">int</span> x,<span class="built_in">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[x]&lt;deep[y])swap(x,y);</span><br><span class="line">    <span class="comment">///<span class="markdown">x的深度比y深</span></span></span><br><span class="line">    <span class="comment">///<span class="markdown">找到高度恰好大于等于y高度的x的祖先</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[Fa[x][i]]&gt;=deep[y])x=Fa[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="comment">///<span class="markdown">若Fa[<span class="string">x</span>][<span class="symbol">i</span>]==Fa[<span class="string">y</span>][<span class="symbol">i</span>]则该点为它们的公共祖先</span></span></span><br><span class="line">    <span class="comment">///<span class="markdown">但是不是最近的公共祖先</span></span></span><br><span class="line">    <span class="comment">///<span class="markdown">若Fa[<span class="string">x</span>][<span class="symbol">i</span>]!=Fa[<span class="string">y</span>][<span class="symbol">i</span>]则上跳,二进制一定能表示出一个确定的公共点</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Fa[x][i]!=Fa[y][i])&#123;</span><br><span class="line">            x=Fa[x][i];</span><br><span class="line">            y=Fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///<span class="markdown">最后更新到的点就是两者的LCA</span></span></span><br><span class="line">    <span class="keyword">return</span> Fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> dfs(<span class="built_in">int</span> now,<span class="built_in">int</span> fa)&#123;</span><br><span class="line">    Dfsin[now]=++cnt;</span><br><span class="line">    deep[now]=deep[fa]+<span class="number">1</span>;</span><br><span class="line">    Fa[now][<span class="number">0</span>]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="number">20</span>;i++)Fa[now][i]=Fa[Fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(auto to:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dfs(to,now);</span><br><span class="line">    &#125;</span><br><span class="line">    Dfsout[now]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bool</span> check(<span class="built_in">int</span> u,vector&lt;<span class="built_in">int</span>&gt; node)&#123;</span><br><span class="line">    <span class="keyword">for</span>(auto i:node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dfsin[u]&lt;=Dfsin[i]&amp;&amp;Dfsout[u]&gt;=Dfsout[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="built_in">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        mp[u].push_back(v);</span><br><span class="line">        mp[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">int</span> q;cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">int</span> r,b;cin&gt;&gt;r&gt;&gt;b;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt;Red,Blue;</span><br><span class="line">        <span class="built_in">int</span> Firstvis=<span class="number">0</span>,Lastvis=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            Red.push_back(temp);</span><br><span class="line">            <span class="keyword">if</span>(!Firstvis||Dfsin[Firstvis]&gt;Dfsin[temp])Firstvis=temp;</span><br><span class="line">            <span class="keyword">if</span>(!Lastvis||Dfsin[Lastvis]&lt;Dfsin[temp])Lastvis=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> LcaRed=Lca(Lastvis,Firstvis);</span><br><span class="line">        Lastvis=<span class="number">0</span>,Firstvis=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;b;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            Blue.push_back(temp);</span><br><span class="line">            <span class="keyword">if</span>(!Firstvis||Dfsin[Firstvis]&gt;Dfsin[temp])Firstvis=temp;</span><br><span class="line">            <span class="keyword">if</span>(!Lastvis||Dfsin[Lastvis]&lt;Dfsin[temp])Lastvis=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> LcaBlue=Lca(Lastvis,Firstvis);</span><br><span class="line">        <span class="keyword">if</span>(check(LcaBlue,Red))cout&lt;&lt;<span class="string">"YES"</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(check(LcaRed,Blue))cout&lt;&lt;<span class="string">"YES"</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">"NO"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title>2019银川ICPC区域赛-I</title>
    <url>/2020/09/19/2019%E9%93%B6%E5%B7%9DICPC%E5%8C%BA%E5%9F%9F%E8%B5%9B-I/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/42389" target="_blank" rel="noopener">I - Base62</a> </p>
<p>题意</p>
<p>给出一个x进制数z&lt;$x^{120}$</p>
<p>输出它的y进制形式</p>
<p>规定’0’-‘9’表示0到9</p>
<p>‘A’-‘Z’表示10到35</p>
<p>‘a’-‘z’表示36到61 </p>
<p>题解</p>
<p><a href="https://www.cnblogs.com/lmjer/p/8972037.html" target="_blank" rel="noopener">参考博客</a></p>
<p>x进制数z&lt;$x^{120}$ 用字符串读入那么长度不会超过120位</p>
<p>模拟短除法转换进制：</p>
<p>举个例子：50，要从十进制转换为二进制。(即x=10,y=2,z=50)</p>
<p>将十进制每位单独存进数组</p>
<p>十位是5，个位是0，那么首先5/2商为2，余1</p>
<p>下一步就是1*10+0=10，然后个位就变成了10，然后10/2=5余0，</p>
<p>0就是50这个数从十进制转化二进制结果的个位，</p>
<p>然后下一步就是对25进行操作</p>
<p>2/2商1余0，那么十位就是1 个位就是0*10+5=5.</p>
<p>5/2商2余1，那么50的二进制结果的十位就是1。</p>
<p>然后对12进行操作，十位是1，1/2商0余1，那么十位就为0了。</p>
<p>个位就是1*10+2=12.12/2商6余0，结果的百位就是0.</p>
<p>因为十位是0，所以只对个位进行操作了，6/2商3余0，千为就是0</p>
<p>3/2商1余1，万位为1.</p>
<p>1/2商0余1，十万位为1，所以50转换为二进制就是110010</p>
<p>短除法每次对z除以y 大约$log_yz$ 次 每次除法从最高位模拟到最低为最多120位</p>
<p>所以进制转化的复杂度为 $O120log_yz$ </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;alp;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt;tran;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> i=<span class="string">'0'</span>;i&lt;=<span class="string">'9'</span>;i++)alp[i]=(i-<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> i=<span class="string">'A'</span>;i&lt;=<span class="string">'Z'</span>;i++)alp[i]=(i-<span class="string">'A'</span>+<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> i=<span class="string">'a'</span>;i&lt;=<span class="string">'z'</span>;i++)alp[i]=(i-<span class="string">'a'</span>+<span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> temp=<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        tran[i]=temp;</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    temp=<span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;<span class="number">36</span>;i++)&#123;</span><br><span class="line">        tran[i]=temp;</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    temp=<span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">36</span>;i&lt;<span class="number">62</span>;i++)&#123;</span><br><span class="line">        tran[i]=temp;</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> ans[<span class="number">1100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">string</span> z,nz=<span class="string">""</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">    intn();<span class="keyword">int</span> len=z.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        data[i]=alp[z[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> st=<span class="number">0</span>,indx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(st&lt;len)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=st;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            data[i+<span class="number">1</span>]+=data[i]%y*x;</span><br><span class="line">            data[i]/=y;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[indx++]=data[len<span class="number">-1</span>]%y;</span><br><span class="line">        data[len<span class="number">-1</span>]/=y;</span><br><span class="line">        <span class="keyword">while</span>(st&lt;len&amp;&amp;!data[st])st++;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(ans,ans+indx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indx;i++)&#123;</span><br><span class="line">        nz+=tran[ans[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nz&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>进制转化</tag>
        <tag>实现</tag>
      </tags>
  </entry>
  <entry>
    <title>2019南昌ICPC区域赛-C</title>
    <url>/2020/09/12/2019%E5%8D%97%E6%98%8CICPC%E5%8C%BA%E5%9F%9F%E8%B5%9B-C/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/42578" target="_blank" rel="noopener">C.And and Pair</a></p>
<p>题意</p>
<p>给出一个上限n (n非常大用长度1e5的二进制表示)</p>
<p>求出有多少对pair(i,j)满足</p>
<ul>
<li><p>0&lt;=j&lt;=i&lt;=n</p>
</li>
<li><p>i&amp;n=i</p>
</li>
<li><p>i&amp;j=0;</p>
</li>
</ul>
<p>答案对1e9+7取模</p>
<p>题解</p>
<p><a href="https://blog.csdn.net/qq_43803508/article/details/106979979" target="_blank" rel="noopener">组合数解法参考</a></p>
<p><a href="https://blog.csdn.net/qq_43804974/article/details/104001473" target="_blank" rel="noopener">dp解法参考</a></p>
<p>首先根据题目条件</p>
<p>i&amp;n=i,那么若n的第k位二进制位上为0 ,则i的第k位上必须为0</p>
<p>否则n的第k位上为1,则i的第k位上 可以是1/0</p>
<p>其次i&amp;j=0,那么i的第k位上为0时 j可以为1/0 </p>
<p>i的第k位上为1时 j必须为0</p>
<p>由于一定要满足j&lt;=i的数对</p>
<p>所以可以从n的最低位枚举到最高位 </p>
<p>若当前n的第k位为1那么将这一位作为i的最高位</p>
<p>若当前n的第k位为0那么跳过，因为i的第k位上为0时 j可以为1/0 </p>
<p>那么从第k位到后面出现的第一个1(设此处为s)之间j的二进制都必须为0</p>
<p>否则不满足j&lt;=i的条件  </p>
<p>这样就相当于在统计以第s位为i的最高位时的可行数对</p>
<p>​    </p>
<p>当枚举到最高位为k时，统计从最低位到k-1之间有cnt0个0 ,cnt1个1</p>
<p>那么选择可选择的j就有$2^{cnt0}$种(i的第k位上为0时 j可以为1/0, i的第k位上为1时 j必须为0)</p>
<p>剩下的cnt1个1中i选择其中y个位置变为0其他位为1，同时又对应$2^y$ 种 j</p>
<p>所以以k为i的最高位时 有 $2^{cnt0}∑<em>{i=0}^{cnt1}C</em>{cnt1}^{i}2^i$ 对符合要求的(i,j)</p>
<p>这里有一个组合数的等效转换公式$∑<em>{i=0}^{cnt1}C</em>{cnt1}^{i}2^i=3^{cnt1}$ 具体证明可以参考第一个🔗</p>
<p>这样转化就避免了组合数取模求逆元的麻烦</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">ll p2[Max],p3[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    p2[<span class="number">0</span>]=p3[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1e5</span>;i++)&#123;</span><br><span class="line">        p2[i]=(p2[i<span class="number">-1</span>]*<span class="number">2</span>)%Mod;</span><br><span class="line">        p3[i]=(p3[i<span class="number">-1</span>]*<span class="number">3</span>)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt0=<span class="number">0</span>;</span><br><span class="line">        ll ans=<span class="number">1</span>;</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                ans=(ans+(p2[cnt0]*p3[cnt1])%Mod)%Mod;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cnt0++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比起组合数学推公式 ，dp更直观设计三维dp(k,0/1,0/1)</p>
<p>第一维表示现在枚举到第几位，</p>
<p>第二维度表示数对中的i在这一位表示是什么，</p>
<p>第三维度表示的是j在这一位表示的是什么 </p>
<p>对于以第k位为i最高位对答案的贡献为+=dp(k,1,0)表示i的第k位为1 ，j的第k位为0的数对有几个</p>
<p>(理由见上面分析)</p>
<p>于是有转移方程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">	<span class="comment">//你只能填0；直接转移</span></span><br><span class="line">	f[i][<span class="number">0</span>][<span class="number">0</span>] =  ((f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) % mod + (f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) % mod + (f[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) % mod) % mod;</span><br><span class="line">	f[i][<span class="number">0</span>][<span class="number">1</span>] = ((f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) % mod + (f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) % mod + (f[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	f[i][<span class="number">1</span>][<span class="number">0</span>] =  ((f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) % mod + (f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) % mod + (f[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) % mod) % mod;</span><br><span class="line">	f[i][<span class="number">0</span>][<span class="number">0</span>] = ((f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) % mod + (f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) % mod + (f[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) % mod) % mod;</span><br><span class="line">	f[i][<span class="number">0</span>][<span class="number">1</span>] = ((f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) % mod + (f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) % mod + (f[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">ans += f[i][<span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>2019南昌ICPC区域赛-E</title>
    <url>/2020/09/12/2019%E5%8D%97%E6%98%8CICPC%E5%8C%BA%E5%9F%9F%E8%B5%9B-E/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/42580" target="_blank" rel="noopener">E.Bob’s Problem</a></p>
<p>题意</p>
<p>给出n &lt;1e5点m&lt;5e5条边的无向图(存在自环和重边)</p>
<p>每条边有权值和颜色(黑/白)两种属性</p>
<p>要求删除一些边后图中任意两点互相连通 且最多不超过k条白边</p>
<p>问删除一些边后图的边权和最大是多少</p>
<p>题解</p>
<p>贪心的想所有黑边都可以保留 被记入总贡献</p>
<p>只要考虑如何删除白边</p>
<p>我们先将黑边连成的图用并查集缩点</p>
<p>然后将白边根据权值降序排列</p>
<p>枚举每个白边 判断白边两侧的点是否处于同一个连通块</p>
<p>若不是则这条边必须加入，否则先将这条边搁置</p>
<p>判断其他白边是否必须加入使图中点两两连通</p>
<p>若最后图中必须加入的白边大于k条或最后加完白边还不能构成一个连通图则输出-1 ，</p>
<p>否则若图中还能再添加白边则将之前搁置的白边按权值从大到小加入图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for1(i,n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forn(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m_p(x,y) make_pair(x,y)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="comment">//ll??</span></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> uu, vv, ww;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; e;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[(<span class="keyword">int</span>)<span class="number">5e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x==fa[x]? x : fa[x]=<span class="built_in">find</span>(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.ww &gt; b.ww;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	for1(i,n)&#123;</span><br><span class="line">		fa[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">	e.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="built_in">read</span>(); <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n=<span class="built_in">read</span>(), m=<span class="built_in">read</span>(), k=<span class="built_in">read</span>();</span><br><span class="line">		init(n);</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		for1(i,m)&#123;</span><br><span class="line">			<span class="keyword">int</span> u=<span class="built_in">read</span>(), v=<span class="built_in">read</span>(), w=<span class="built_in">read</span>(), c=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span>(c==<span class="number">0</span>)&#123;				</span><br><span class="line">				u = <span class="built_in">find</span>(u), v=<span class="built_in">find</span>(v);</span><br><span class="line">				<span class="keyword">if</span>(u != v) fa[u] = v;</span><br><span class="line">				ans += <span class="number">1l</span>l*w;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> e.push_back(&#123;u,v,w&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(e.<span class="built_in">begin</span>(),e.<span class="built_in">end</span>(),cmp);</span><br><span class="line">		forn(i,e.<span class="built_in">size</span>())&#123;</span><br><span class="line">			<span class="keyword">int</span> u = e[i].uu, v=e[i].vv;</span><br><span class="line">			u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">			<span class="keyword">if</span>(u != v)&#123;</span><br><span class="line">				vis[i] = <span class="number">1</span>;</span><br><span class="line">				ans += <span class="number">1l</span>l*e[i].ww;</span><br><span class="line">				fa[u] = v;</span><br><span class="line">				k--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(k&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		forn(i,e.<span class="built_in">size</span>()) <span class="keyword">if</span>(!vis[i] &amp;&amp; k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			ans += <span class="number">1l</span>l*e[i].ww;</span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;flag &amp;&amp; i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> f = <span class="built_in">find</span>(i);</span><br><span class="line">			<span class="keyword">if</span>(f != tmp) flag = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag) ans = <span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>图论</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>2019南昌ICPC区域赛-G</title>
    <url>/2020/09/12/2019%E5%8D%97%E6%98%8CICPC%E5%8C%BA%E5%9F%9F%E8%B5%9B-G/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/42582" target="_blank" rel="noopener">G.Eating Plan</a></p>
<p>题意</p>
<p>给出长度为n&lt;1e5的排列p(1到n都只出现一次)</p>
<p>m&lt;1e4次询问，每次输入一个数k</p>
<p>求一个最短区间[L,R]的长度</p>
<p>使得$∑_{i=L}^R p[i]! $ $mod$   $998857459 &gt;=k$</p>
<p>题解</p>
<p><a href="https://www.cnblogs.com/artoriax/p/12188239.html" target="_blank" rel="noopener">参考题解</a></p>
<p>打表发现当p[i]&gt;=2803时 p[i] mod 998857459 为0</p>
<p>因为实际上模数 998857459 并不是一个素数 </p>
<p>所以当n大于2803时，实际上只有 2802个 p[i]需要计算</p>
<p>于是存入2802×2802个区间 根据pair&lt;区间和,区间长度&gt; 升序排列 </p>
<p>在每次二分查找一个区间和&gt;=k的下标pos</p>
<p>由于优先以区间和升序排列 区间长度没有准确的递增递减趋势</p>
<p>所以预处理出一个后缀数组suff[i]表示后往前到下标为i的所有区间中长度最短的值</p>
<p>答案输出suff[pos] 若不存在则输出-1</p>
<ul>
<li>为什么只用处理2802×2802个区间</li>
</ul>
<p>对于每次询问k，首先需要找到存在一个区间的和($∑_{i=L}^R p[i]! $)&gt;=k</p>
<p>显然每个区间长度下只有最大的区间和($∑_{i=L}^R p[i]! $) 才是有用的信息 其他的均可抛弃</p>
<p>其次我们需要找到 相同区间和的情况下最短的区间长度 </p>
<p>那么显然只有2802×2802个区间有用</p>
<p>假如有p[i]! mod 998857459 如下：</p>
<p>0 0 5 0 1 0 2</p>
<p>我们选择区间和=6的区间会选择[3,5]而不将0纳入</p>
<p>因为[2,5]和[3,5]区间和都为6但是显然[3,5]长度更短</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll P[Max],pos[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    ll n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;P[i];</span><br><span class="line">        pos[P[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1l</span>l*pos[<span class="number">1</span>]*(pos[<span class="number">1</span>]<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">1l</span>l*(<span class="number">1</span>+n-pos[<span class="number">1</span>])*(n-pos[<span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;=<span class="number">2</span>&amp;&amp;pos[<span class="number">2</span>]&gt;pos[<span class="number">1</span>])ans+=<span class="number">1l</span>l*(pos[<span class="number">2</span>]-pos[<span class="number">1</span>])*(pos[<span class="number">1</span>])*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;=<span class="number">2</span>&amp;&amp;pos[<span class="number">2</span>]&lt;pos[<span class="number">1</span>])ans+=<span class="number">1l</span>l*(pos[<span class="number">1</span>]-pos[<span class="number">2</span>])*(n-pos[<span class="number">1</span>]+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">    ll rightpos=<span class="built_in">max</span>(pos[<span class="number">1</span>],pos[<span class="number">2</span>]),leftpos=<span class="built_in">min</span>(pos[<span class="number">1</span>],pos[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//if(pos[i]&lt;rightpos&amp;&amp;pos[i]&gt;leftpos)continue;</span></span><br><span class="line">        <span class="keyword">if</span>(pos[i]&lt;leftpos)&#123;</span><br><span class="line">            ans+=<span class="number">1l</span>l*(n-rightpos+<span class="number">1</span>)*(leftpos-pos[i])*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pos[i]&gt;rightpos)&#123;</span><br><span class="line">            ans+=<span class="number">1l</span>l*leftpos*(pos[i]-rightpos)*i;</span><br><span class="line">        &#125;</span><br><span class="line">        rightpos=<span class="built_in">max</span>(rightpos,pos[i]);</span><br><span class="line">        leftpos=<span class="built_in">min</span>(leftpos,pos[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>规律发现</tag>
      </tags>
  </entry>
  <entry>
    <title>2020北京ICPC网络选拔赛Round1-A</title>
    <url>/2020/10/25/2020%E5%8C%97%E4%BA%ACICPC%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9BRound1-A/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/7501/A" target="_blank" rel="noopener">Intelligent Warehouse</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个长度为n&lt;1e5的数组a</p>
<p>其中ai&lt;1e7</p>
<p>求一个它的最大子集</p>
<p>使得其中的任意两数互为倍数因子关系</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//input</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//hint:One possible choice is &#123;1, 4, 2, 8&#125;.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>设dp[i]表示当前选的所有数都是i的因子的最优解(最大值)</p>
<p>此题能开int 1e7大小的数组</p>
<p>最直观的转移就是用dp[i]更新所有i的倍数的dp值 即</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Max;i++)&#123;</span><br><span class="line">    dp[i]+=cnt[i];</span><br><span class="line">    <span class="keyword">if</span>(!cnt[i])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=Max;j+=i)dp[j]=<span class="built_in">max</span>(dp[j],dp[i]);</span><br><span class="line">    <span class="comment">///取max表示数j有多个因子但不能取它的所有因子</span></span><br><span class="line">    <span class="comment">///例如10有因子5和2但5和2不能放在一个集合中</span></span><br><span class="line">    ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样极限复杂度超过1e8</p>
<p>实际上就只用枚举i的素数倍就可以 因为合数可以倍若干个素数乘积凑出来</p>
<p>没必要再枚举</p>
<p>比如 i=30</p>
<p>我只用枚举它的素数倍即更新</p>
<p>dp[30×2]=max(dp[30×2],dp[30])…..dp[30×5]=max(dp[30×5],dp[30])</p>
<p>那为什么不用更新dp[30×6]？</p>
<p>因为在枚举它的素数倍时已经更新了dp[30×2]和dp[30×3]</p>
<p>dp[30×6] 会在之后dp[60×3]和dp[90×2]被更新到</p>
<p>复杂度和埃氏筛相同(?个人记得这个是nlogn的复杂度) 为O(XloglogX) 其中X=1e7</p>
<p>1e7内的素数可以通过欧拉筛或埃氏筛处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=Max;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isprime[i])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=Max;j++)isprime[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///埃氏筛</span></span><br></pre></td></tr></table></figure>

<p>不加埃氏筛直接处理它的所有倍数 可以卡进1s但是理论复杂度超过1e8</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e7</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> dp[Max],cnt[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        cnt[temp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">///枚举所有倍数转移极限复杂度较高</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Max;i++)&#123;</span><br><span class="line">        dp[i]+=cnt[i];</span><br><span class="line">        <span class="keyword">if</span>(!cnt[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=Max;j+=i)dp[j]=<span class="built_in">max</span>(dp[j],dp[i]);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>2020北京ICPC网络选拔赛Round1-J</title>
    <url>/2020/11/03/2020%E5%8C%97%E4%BA%ACICPC%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9BRound2-G/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/7502/G" target="_blank" rel="noopener">Shift and Reverse</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个长度为n&lt;1e5的序列a</p>
<p>可以进行如下操作任意次：</p>
<p>选择一个位置i</p>
<p>将$a_1,a_2,….a_i,a_{i+1},a_{i+2},..a_n$  变为</p>
<p>$a_i,a_{i−1},…,a_1,a_n,a_{n−1},…,a_{i+1}$</p>
<p>问能产生多少个不同的序列</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>对于一个给定序列 如</p>
<p>1 2 3 4 5 6 </p>
<p>选择{1 2 3}{4 5 6}</p>
<p>一次操作后得到:3 2 1 6 5 4</p>
<p>选择 {3 2}{1 6 5 4}</p>
<p>再一次操作后得到:2 3 4 5 6 1</p>
<p>选择{2 3 4 5}{6 1}</p>
<p>再一次操作后得到:5 4 3 2 1 6</p>
<p>发现无论如何操作得到的序列一定是</p>
<p>1 2 3 4 5 6 1 2 3 4 5 6 或</p>
<p>6 5 4 3 2 1 6 5 4 3 2 1 的某个长度为n的子段</p>
<p>用hash将子段映射成对应的ull型数</p>
<p>On遍历用map类型的vis标记 统计共有多少中不同的子串</p>
<p>实际上无论几次操作最多得到2n种不同结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ull Hash[Max],base[Max],num_hash=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[Max],ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;ull,<span class="keyword">int</span>&gt;vis;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    base[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Max;i++)base[i]=base[i<span class="number">-1</span>]*<span class="number">131</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">get_hash</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Hash[R]-Hash[L<span class="number">-1</span>]*base[R-L+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        vis.<span class="built_in">clear</span>();</span><br><span class="line">        num_hash=<span class="number">0</span>;ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">            num[i+n]=num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)Hash[i]=Hash[i<span class="number">-1</span>]*<span class="number">131</span>+num[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            num_hash=get_hash(i,i+n<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!vis[num_hash])ans++;</span><br><span class="line">            vis[num_hash]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(num,num+n*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)Hash[i]=Hash[i<span class="number">-1</span>]*<span class="number">131</span>+num[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            num_hash=get_hash(i,i+n<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!vis[num_hash])ans++;</span><br><span class="line">            vis[num_hash]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>规律发现</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>2020北京ICPC网络选拔赛Round1-J</title>
    <url>/2020/11/03/2020%E5%8C%97%E4%BA%ACICPC%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9BRound2-I/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/7501/J" target="_blank" rel="noopener">Matrix Subtraction</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个字符串s和字符串t (长度均小于2000)</p>
<p>从他们中分别选出两个子序列x y</p>
<p>要求符合：</p>
<ul>
<li>x的字典序小于y</li>
<li>要求|x|+|y|最大</li>
</ul>
<p>求|x|+|y|的最大值</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>x的字典序小于y当且仅当：</p>
<ul>
<li>x是y的前缀且|x|&lt;|y|</li>
<li>x不是y的前缀 且存在某个位置i 使得x和y的前i-1个字符相同 $x_i$&lt;$y_i$ </li>
</ul>
<p>从s和t串中得到的x和y必须符合上述条件</p>
<p>发现无论哪种情况 都需要求出LongestCommonSequence($s_1$<del>$s_i$, $t_1$</del> $t_j$) </p>
<p>对于第一种情况|x|+|y|的最大值=max{LCS($s_1$<del>$s_i$, $t_1$</del> $t_j$)+$len_t-j$} </p>
<p>即x是y的前缀同时将$t_{j+1}$之后的字符全给归s</p>
<p>对于第二种情况当$s_i&lt;t_j$时以这一位字符作为 x和y的位置 i (上文提到的位置 i )</p>
<p>|x|+|y|的最大值=max{LCS($s_1​$~ $s_{i-1}​$,$t_1​$~$t_{j-1}​$)+$len_t-j+1​$+$len_s-i+1​$}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="comment">//#define P pair&lt;ll,ll&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[Max][Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="built_in">string</span> s,t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t)&#123;</span><br><span class="line">        <span class="keyword">int</span> lens=s.<span class="built_in">size</span>(),lent=t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans=lent;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lens;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lent;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==t[j])dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]);</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,dp[i+<span class="number">1</span>][j+<span class="number">1</span>]*<span class="number">2</span>+lent-j<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s[i]&lt;t[j])ans=<span class="built_in">max</span>(ans,dp[i][j]*<span class="number">2</span>+lens-i+lent-j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>dp</tag>
        <tag>最长上升子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>2020北京ICPC网络选拔赛Round1-J</title>
    <url>/2020/10/25/2020%E5%8C%97%E4%BA%ACICPC%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9BRound1-J/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/7501/J" target="_blank" rel="noopener">Matrix Subtraction</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个一个n×m的矩阵</p>
<p>是否存在一种方案</p>
<p>使得多次从n×m矩阵中选中某个a×b的矩阵并将所有元素-1后</p>
<p>将原矩阵变为全0矩阵</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//input</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">QAQ</span><br><span class="line">^_^</span><br><span class="line"></span><br><span class="line">For the second <span class="keyword">case</span>, one possible scheme <span class="keyword">is</span> to choose (<span class="number">1</span>, <span class="number">1</span>) - (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">2</span>) - (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>) - (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>) - (<span class="number">2</span>, <span class="number">3</span>) respectively.</span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p><a href="https://blog.csdn.net/fztsilly/article/details/109278718" target="_blank" rel="noopener">参考博客</a></p>
<p>发现左上角的元素(M(1,1) )只能被(1,1)到(a,b)的矩阵消耗</p>
<p>所以(1,1)到(a,b)的矩阵被选择的次数是确定的</p>
<p>同理在经过(1,1)到(a,b)的矩阵处理后得到的新n×m矩阵</p>
<p>可以从(M(1,2) )求出(1,2)到(a,b+1)的矩阵需要被用几次</p>
<p>记C(i,j)表示(i,j)到(i+a-1,j+b-1)的子矩阵需要被用多少次</p>
<p>可得 $C_{i,j}=M_{i,j}-∑<em>{u=0}^{a-1}∑</em>{v=0}^{b-1}[u!=0 || v!=0] C_{i-u,j-v}$</p>
<p>利用二位前缀和+二维差分就可以快速求出</p>
<ul>
<li><p>如何将原矩阵转化差分矩阵？</p>
<p>设原矩阵为a(i,j) ,b为a的差分矩阵</p>
<p>在二维矩阵中，前缀和公式为s(i,j) = a(i,j) + s(i,j - 1) + s(i - 1,j) - s(i - 1,j - 1) </p>
<p>故a(i,j) = b(i,j) + a(i,j - 1) + a(i - 1,j) - a(i - 1,j - 1);</p>
<p>交换一下位置得b(i,j) = a(i,j) + a(i - 1,j - 1) - a(i,j - 1) - a(i - 1,j) </p>
</li>
</ul>
<p>于是只要判断是否能保证$C_{i,j}$非负且原矩阵是否恰好全变为0</p>
<p>整体复杂度$Onm$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///std 二位前缀+差分</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line">ll mat[Max][Max];</span><br><span class="line">ll Cmat[Max][Max];</span><br><span class="line">ll C[Max][Max];</span><br><span class="line"><span class="keyword">int</span> n,m,a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;mat[i][j];</span><br><span class="line">                C[i][j]=<span class="number">0</span>,Cmat[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                C[i][j]+=C[i<span class="number">-1</span>][j];</span><br><span class="line">                C[i][j]+=C[i][j<span class="number">-1</span>];</span><br><span class="line">                C[i][j]-=C[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                mat[i][j]-=C[i][j];</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]&lt;<span class="number">0</span>)flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i+a<span class="number">-1</span>&gt;n||j+b<span class="number">-1</span>&gt;m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mat[i][j])flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                C[i][j]+=mat[i][j];</span><br><span class="line">                C[i][j+b]-=mat[i][j];</span><br><span class="line">                C[i+a][j]-=mat[i][j];</span><br><span class="line">                C[i+a][j+b]+=mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">"QAQ"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"^_^"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是自己的代码(wa)只使用了二维前缀和</p>
<p>暂时不知道哪里出问题了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">ll mat[Max][Max];</span><br><span class="line">ll Cmat[Max][Max];</span><br><span class="line">ll C[Max][Max];</span><br><span class="line"><span class="keyword">int</span> n,m,a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)<span class="built_in">cin</span>&gt;&gt;mat[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> X=<span class="built_in">max</span>(<span class="number">0</span>,i-a),Y=<span class="built_in">max</span>(<span class="number">0</span>,j-b);</span><br><span class="line">                ll temp=Cmat[i<span class="number">-1</span>][j]+Cmat[i][j<span class="number">-1</span>]-Cmat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                temp-=Cmat[X][j];temp-=Cmat[i][Y];</span><br><span class="line">                temp+=Cmat[X][Y];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]-temp&lt;<span class="number">0</span>)flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i+a<span class="number">-1</span>&gt;n||j+b<span class="number">-1</span>&gt;m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mat[i][j]-temp)flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                C[i][j]=mat[i][j]-temp;</span><br><span class="line">                Cmat[i][j]=C[i][j]+Cmat[i<span class="number">-1</span>][j]+Cmat[i][j<span class="number">-1</span>]-Cmat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">"QAQ"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"^_^"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二维前缀和</tag>
        <tag>二维差分</tag>
      </tags>
  </entry>
  <entry>
    <title>2020超级码力初赛-Round1-C</title>
    <url>/2020/08/29/2020%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%88%9D%E8%B5%9B-Round1-C/</url>
    <content><![CDATA[<p><a href="https://tianchi.aliyun.com/oj/14491652514320995/73733636160164532" target="_blank" rel="noopener">大楼间穿梭</a> </p>
<p>题意</p>
<p>蜘蛛侠在大楼间穿梭。大楼的高度可以看作是一个从左到右排列的数组。 现在蜘蛛侠站在第一栋大楼上，他想跳到最后一栋上。 蜘蛛侠的视野为 k，他可以花费 x 点体力，用蛛丝移动到右侧 k 幢建筑中第一栋比当前位置高的大楼。 或者蜘蛛侠可以花费 y 点体力，跳跃到右侧接下来两栋大楼其中一栋。 请计算蜘蛛侠最少花费多少体力，到达最后一栋上。</p>
<p>大楼的高度为数组 heights，一共有 n 栋大楼，2≤n≤105, 1≤$heights_i$≤109. 蜘蛛侠的视野为 k，1≤k≤n。 两种行动的体力花费满足 1≤x,y≤109。</p>
<p>题解</p>
<p>很显然题目已经说明了转移方程</p>
<p>难点在于对于第i个位置 如何快速得到k距离内能跳到的下一个大楼</p>
<p>朴素想法$On^2$ 暴力 。</p>
<p>发现“右边第一个比自己大的数字”是单调栈的经典模型 </p>
<p>那么这个问题可以通过单调栈预处理对于位置i它能跳到最近的位置j满足$heights_j&gt;heights_i$ </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param heights: the heights of buildings.</span></span><br><span class="line"><span class="comment">     * @param k: the vision.</span></span><br><span class="line"><span class="comment">     * @param x: the energy to spend of the first action.</span></span><br><span class="line"><span class="comment">     * @param y: the energy to spend of the second action.</span></span><br><span class="line"><span class="comment">     * @return: the minimal energy to spend.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">int</span> nextpos[(<span class="built_in">int</span>)<span class="number">1e5</span>+<span class="number">5</span>];</span><br><span class="line">    long long dp[(<span class="built_in">int</span>)<span class="number">1e5</span>+<span class="number">5</span>];</span><br><span class="line">    long long shuttleInBuildings(vector&lt;<span class="built_in">int</span>&gt; &amp;heights, <span class="built_in">int</span> k, <span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">        <span class="built_in">int</span> n=heights.size();</span><br><span class="line">        stack&lt;<span class="built_in">int</span>&gt;st;</span><br><span class="line">        long long ans=<span class="number">0</span>;<span class="built_in">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=n;i++)nextpos[i]=n+<span class="number">1</span>,dp[i]=<span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//if(i)dp[i]=1e18;</span></span><br><span class="line">            <span class="keyword">while</span>(!st.empty()&amp;&amp;heights[st.top()]&lt;=heights[i])&#123;</span><br><span class="line">                nextpos[st.top()]=i;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n)dp[i+<span class="number">1</span>]=min(dp[i+<span class="number">1</span>],dp[i]+y);</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">2</span>&lt;n)dp[i+<span class="number">2</span>]=min(dp[i+<span class="number">2</span>],dp[i]+y);</span><br><span class="line">            <span class="keyword">if</span>(nextpos[i]-i&lt;=k)dp[nextpos[i]]=min(dp[nextpos[i]],dp[i]+x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2020超级码力初赛-Round1-D</title>
    <url>/2020/08/29/2020%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%88%9D%E8%B5%9B-Round1-D/</url>
    <content><![CDATA[<p><a href="https://tianchi.aliyun.com/oj/14491652514320995/73733636160164531" target="_blank" rel="noopener">对称前后缀</a> </p>
<p>题意</p>
<p>给定一个字符串 s。 我们令一个字符串的权值为一个字符串的最长对称前后缀长度。 </p>
<p>请求出 s 的所有子串的权值的总和。 </p>
<p>例如，”abcxyzcba” 的最长对称前后缀的长度为 3，因为 “abc” 和 “cba” 对称。</p>
<p>字符串的长度为 n，1≤n≤3000。 字符串均由小写英文字符组成。</p>
<p>题解</p>
<p>考虑区间dp(L,R) 表示[L,R]区间内 最长的对称前后缀长度</p>
<p>对于长度为1的子串 它的权值为1</p>
<p>对于长度为2的子串 若s[i]==s[i+1]则权值为2 否则为0</p>
<p>对于长度大于3的子串 当s[L]==s[R]</p>
<p>则dp(L,R)由dp(L+1,R-1) 转移得到</p>
<p>若[L+1,R-1]为回文串(即dp(L+1,R-1)==R-L-1)那么加入字符s[L]和s[R] +2权值贡献</p>
<p>否则 +1 权值贡献</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param s: a string.</span></span><br><span class="line"><span class="comment">     * @return: return the values of all the intervals.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">    ll dp[<span class="number">3004</span>][<span class="number">3004</span>];</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">suffixQuery</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)dp[i][i+<span class="number">1</span>]=(s[i]==s[i+<span class="number">1</span>]?<span class="number">2</span>:<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=n;len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">0</span>;L+len<span class="number">-1</span>&lt;n;L++)&#123;</span><br><span class="line">                <span class="keyword">int</span> R=L+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[R]==s[L])&#123;</span><br><span class="line">                    dp[L][R]=dp[L+<span class="number">1</span>][R<span class="number">-1</span>]+(dp[L+<span class="number">1</span>][R<span class="number">-1</span>]==R-L<span class="number">-1</span>?<span class="number">2</span>:<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> R=<span class="number">0</span>;R&lt;n;R++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">0</span>;L&lt;=R;L++)&#123;</span><br><span class="line">                ans+=dp[L][R];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>dp</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title>2020超级码力复赛-B</title>
    <url>/2020/10/03/2020%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%A4%8D%E8%B5%9B-B/</url>
    <content><![CDATA[<p><a href="https://tianchi.aliyun.com/oj/84846268534006540/92553970267132882" target="_blank" rel="noopener">吃鸡</a> </p>
<p>题意</p>
<p>给出n&lt;1e5个点m&lt;2e5条边</p>
<p>k&lt;5个特殊点,求将k个点联通的最小边权和 (最小图)</p>
<p>​    </p>
<p>题解</p>
<p>斯坦纳树模板题</p>
<p><a href="https://www.dazhuanlan.com/2019/12/14/5df3d4636f1d5/?__cf_chl_jschl_tk__=c1e4b81a74996348ee91e16ebabc7eae19d7eae4-1601542832-0-Aav8jmT0SudKfGBpTZnbV-Y4T_35Cj0rvHmImznflfsWGwDVUROSNKLi0JKXSFk4WG31y9naDtxzRi2a_z0Jv338AUnf9GOeQ2468cCpYrbq1c6sO0RHegZlOxi6LAujH4fjgfpgUyekInmqxdBweHVA0sTohSN45foPW4lQxdU2cLx0_PHk1V4EY9-rlGY4dPXVNs7aZ8zlSXCw0pnoVqx81t96BocuoCVriPwMZS5sxU1U7nGUYJQz7VAn7URrWyUZSMtX6ppGuqwuJpbvK7rBgozlp8068sr_x7BoZz3hJUk-gp_tUc00koqsC_CqoQ" target="_blank" rel="noopener">斯坦纳树参考博客</a></p>
<p>将k个点状态压缩 利用dp转移 得到答案</p>
<p>状态压缩:比如5个点用二进制表示是否纳入集合10111表示除第2个点外都纳入集合 </p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for 总状态集 from 0 to 1&lt;&lt;k</span><br><span class="line">	for 根结点 from 1 to n</span><br><span class="line">		for 子状态集合 </span><br><span class="line">			dp<span class="comment">[总状态集]</span><span class="comment">[根节点]</span>=min(self,dp<span class="comment">[子状态集A]</span><span class="comment">[根节点]</span>+dp<span class="comment">[子状态集B]</span><span class="comment">[根节点]</span>)</span><br><span class="line">	ShoutCut(总状态集时的最短路)</span><br></pre></td></tr></table></figure>

<p>ShoutCut算法可以用spfa或迪捷斯卡特</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//#define endl '\n'</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,int&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param n: n islands</span></span><br><span class="line"><span class="comment">     * @param k: k special islands</span></span><br><span class="line"><span class="comment">     * @param m: The number of the two islands and the time spent crossing the bridge connecting the two islands</span></span><br><span class="line"><span class="comment">     * @return: Time spent on the bridge through all the small islands</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">bool</span> vis[Max];</span><br><span class="line">    <span class="built_in">vector</span>&lt;P&gt;mp[Max];</span><br><span class="line">    ll dp[(<span class="number">1</span>&lt;&lt;<span class="number">5</span>)+<span class="number">5</span>][Max];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShoutCut</span><span class="params">(ll* dis,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i]!=inf)q.push(&#123;dis[i],i&#125;);</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            P <span class="built_in">point</span>=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> now=<span class="built_in">point</span>.second;</span><br><span class="line">            <span class="keyword">if</span>(vis[now])<span class="keyword">continue</span>;</span><br><span class="line">            vis[now]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> to:mp[now])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[to.first]&gt;dis[now]+to.second)&#123;</span><br><span class="line">                    dis[to.first]=dis[now]+to.second;</span><br><span class="line">                    q.push(&#123;dis[to.first],to.first&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;k, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Kland=k.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge:m)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=edge[<span class="number">0</span>],v=edge[<span class="number">1</span>],w=edge[<span class="number">2</span>];</span><br><span class="line">            mp[u].push_back(&#123;v,w&#125;);</span><br><span class="line">            mp[v].push_back(&#123;u,w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp,inf,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="comment">///注意初始化源点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Kland;i++)dp[<span class="number">1</span>&lt;&lt;i][k[i]]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">1</span>,up=<span class="number">1</span>&lt;&lt;Kland;S&lt;up;S++)&#123;</span><br><span class="line">            <span class="comment">///S的二进制状态表示第i个点是否被加入初始集合S</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">1</span>;start&lt;=n;start++)&#123;</span><br><span class="line">                <span class="comment">///枚举以start作为根节点到所有被纳入集合的关键点</span></span><br><span class="line">                <span class="comment">///注意最短路中的源点和此处遍历的根节点不同</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> S0=S&amp;(S<span class="number">-1</span>);S0;S0=S&amp;(S0<span class="number">-1</span>))&#123; </span><br><span class="line">                    <span class="comment">///这个遍历表示逐个将S其中一个1换成0</span></span><br><span class="line">                    <span class="comment">/// 比如S=11010 那S0= 11000，10010，01010</span></span><br><span class="line">                    <span class="comment">///从两个子状态集合转移到当前状态集</span></span><br><span class="line">                    dp[S][start]=<span class="built_in">min</span>(dp[S][start],dp[S0][start]+dp[S^S0][start]);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">///当前状态集被更新(松弛完)后再作为最短路的源点为下次转移做准备</span></span><br><span class="line">            ShoutCut(dp[S],n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;Kland)<span class="number">-1</span>][k[<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最大子段和</tag>
        <tag>问题转化</tag>
      </tags>
  </entry>
  <entry>
    <title>2020超级码力复赛-A</title>
    <url>/2020/10/03/2020%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%A4%8D%E8%B5%9B-A/</url>
    <content><![CDATA[<p><a href="https://tianchi.aliyun.com/oj/84846268534006540/92553970267132883" target="_blank" rel="noopener">密钥</a> </p>
<p>题意</p>
<p>给出一个长度为1e6的只包含0~9的串</p>
<p>定义某个区间的val=出现最多的数的次数-出现最少的数的次数</p>
<p>求所有子区间中最大的val</p>
<p>​    </p>
<p>题解</p>
<p>我们枚举出现次数最多和最少的那个数,假设为A和B</p>
<p>那么 原字符串 中若第i位为A则替换成1,为B则替换为-1 其余则置为0</p>
<p>于是这个问题被转化成了最大子段和问题 可以用经典$On$解法解决</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param s: number string</span></span><br><span class="line"><span class="comment">     * @return: Find the key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">key</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;<span class="number">9</span>;a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>;b&lt;<span class="number">9</span>;b++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=<span class="number">0</span>,numa=<span class="number">0</span>,numb=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i]-<span class="string">'0'</span>==a)numa++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]-<span class="string">'0'</span>==b)numb++;</span><br><span class="line">                    <span class="keyword">if</span>(numa&gt;=numb&amp;&amp;numb)temp=<span class="built_in">max</span>(temp,numa-numb);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(numa&lt;numb)numa=numb=<span class="number">0</span>;</span><br><span class="line">                    <span class="comment">///最大子段和On解法的关键</span></span><br><span class="line">                    <span class="comment">///当目前子段和&lt;=0那么直接舍弃</span></span><br><span class="line">                    <span class="comment">///因为它对后面的和无贡献</span></span><br><span class="line">                    <span class="comment">///而当前子段的后半部分则是负贡献</span></span><br><span class="line">                &#125;</span><br><span class="line">                maxn=<span class="built_in">max</span>(maxn,temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最大子段和</tag>
        <tag>问题转化</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT&amp;NTT学习笔记</title>
    <url>/2020/08/07/FFT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.bilibili.com/video/BV1Y7411W73U" target="_blank" rel="noopener">互动视频学习&amp;实现FFT</a> (建议配合视频阅读本章)</p>
<p><a href="https://zhuanlan.zhihu.com/p/28478034" target="_blank" rel="noopener">通俗理解“卷积”——从傅里叶变换到滤波器</a></p>
<p><a href="https://www.cnblogs.com/zwfymqz/p/8244902.html" target="_blank" rel="noopener">快速傅里叶变换详解</a></p>
<p><a href="https://www.cnblogs.com/qiyueliu/p/11237318.html" target="_blank" rel="noopener">多项式算法</a></p>
<p><a href="https://www.cnblogs.com/zwfymqz/p/8980809.html" target="_blank" rel="noopener">快速数论变换总结</a></p>
<p><a href="https://blog.csdn.net/linjiayang2016/article/details/95349208" target="_blank" rel="noopener">快速数论变换NTT</a></p>
</blockquote>
<p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>什么是傅里叶变化？</p>
<p>通俗来说傅里叶变换用于将时域函数变换为频域函数</p>
<p>原来的时域函数可以用多个不同频率的sin or cos 函数叠加拟合出来</p>
<img src="/.io//timg.gif" data-original="FFT_example0.png">

<p>上图形象的描述了傅里叶变换在做什么</p>
<p>不过此处不多深究傅里叶变换数学上的推导及其含义(<del>主要是👴忘了</del>) 详细可以看<a href="https://zhuanlan.zhihu.com/p/108598607" target="_blank" rel="noopener">这里</a></p>
<p>这里重点讨论 :1.FFT具体实现,2.它解决什么问题 3.它与信号处理有何关系</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><blockquote>
<p><em>key words : 单位根 , 多项式</em></p>
</blockquote>
<h4 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h4><p>可以理解为在复平面上的向量</p>
<p>一个单位圆上的复数 $z=cosθ+isinθ$</p>
<p>用欧拉定理 $e^{iθ}=cosθ+isinθ$ 其中θ为幅角 因为在单位圆上所以模长为1</p>
<p>而单位根$w_n^d=(e^{iθ})^d$ 其中 $θ=2pi/n$ </p>
<p>可以想象成一个单位圆被平分成n分从x轴的 $w_n^0$逆时针数第d个点为$w_n^d$ </p>
<p>关于单位根有三个重要的引理在之后实现FFT时会用到：</p>
<img src="/.io//timg.gif" data-original="FFT_example2.png">

<p>上面是严格按照定义证明，下面按照我的理解证明</p>
<h5 id="Lemma-1-消去引理：-w-dn-dk-w-n-k"><a href="#Lemma-1-消去引理：-w-dn-dk-w-n-k" class="headerlink" title="Lemma.1 消去引理：$w_{dn}^{dk}=w_n^k$"></a>Lemma.1 消去引理：$w_{dn}^{dk}=w_n^k$</h5><p>可以想象被分成dn分的单位圆从x轴逆时针数第dk个 和 被分成n个的单位元从x轴逆时针数第k个 是同一个点</p>
<p>而这个引理主要用到这个公式的转换$w_n^{n/2}=w_2^1=-1$</p>
<h5 id="Lemma-2-折半引理：-w-n-k-n-2-2-w-n-k-2"><a href="#Lemma-2-折半引理：-w-n-k-n-2-2-w-n-k-2" class="headerlink" title="Lemma.2 折半引理：$(w_n^{k+n/2})^2=(w_n^k)^2$"></a>Lemma.2 折半引理：$(w_n^{k+n/2})^2=(w_n^k)^2$</h5><p>这也显然某个点转过半圈它们的实部长度相等 即 $|cos(θ)|=|cos(θ+pi/2)|$</p>
<h5 id="Lemma-3求和引理-∑-i-0-n-1-w-n-k-i-k-n-n"><a href="#Lemma-3求和引理-∑-i-0-n-1-w-n-k-i-k-n-n" class="headerlink" title="Lemma.3求和引理:$∑_{i=0}^{n-1}(w_n^k)^i=[k==n]*n$"></a>Lemma.3求和引理:$∑_{i=0}^{n-1}(w_n^k)^i=[k==n]*n$</h5><p>这个引理用于求IDFT</p>
<p>若将这个式子考虑为向量相加,单位圆上被平分成n+1个点,</p>
<p>当k=r*n时(r = any int) 等效于单位圆上只有$w_0^0=1+0i$ 它被加了n次所以求和结果为n</p>
<p>当k!=r*n时，无论分成奇数个还是偶数个点这几个向量相加还是0 如下图</p>
<p>​                      <img src="/.io//timg.gif" data-original="FFT_example1.png"></p>
<h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>多项式F的次数degree(F) = 最大幂次项的幂级数， 次数界&gt;degree(F)</p>
<h4 id="多项式的系数表示法"><a href="#多项式的系数表示法" class="headerlink" title="多项式的系数表示法:"></a>多项式的系数表示法:</h4><p> $F(x)=a_0+a_1x+a_2x^2+….+a_nx^n=∑_{i=0}^n a_ix^i$ (F(x)的degree(F)=n)</p>
<p>一般可以用一个一维矩阵[a0,a1,a2,…an]仅仅保存系数来表示一个多项式</p>
<h4 id="多项式的点值表示法"><a href="#多项式的点值表示法" class="headerlink" title="多项式的点值表示法:"></a>多项式的点值表示法:</h4><p>顾名思义用一系列点(n+1个点)表示一个多项式函数图像</p>
<p>{$(x_0,F(x_0)),(x_1,F(x_1)),(x_2,F(x_2)),…,(x_n,F(x_n))$}</p>
<p>点值表示法有什么优势呢 </p>
<p>假如求$A(x)=F(x)×G(x)$ 其中F(x)的系数以ai表示共m项 G(x)的系数以bi表示共n项</p>
<p>A(x)的系数以ci表示 共n+m项即得到的$A(x)$中degree(A)=degree(F)+degree(G)</p>
<p>用系数表示法$c_i=∑_{j=0}^{i} a_j*b_{i-j}$   需要$On^2$</p>
<p>而用点值表示法我我们要求$A(x_i)$只用算$F(x_i)×G(x_i)$ 对应点相乘就好了</p>
<p>点值表示法可以$On$求出两多项式的乘积 </p>
<img src="/.io//timg.gif" data-original="FFT_example3.png">

<p>如果有什么黑科技能快速将多项式从系数表示法变为点值表示法 求得两个多项式的乘积后再变回系数表示法</p>
<p>那么就能加速多项式乘法了,FFT算法解决了这个痛点</p>
<h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><p>FFT主要用于在$Onlogn$的复杂度内快速地 将多项式从系数表示法变为点值表示法 or 逆变换操作</p>
<p>由此来加速多项式乘法 比如<a href="https://www.luogu.com.cn/problem/P3803" target="_blank" rel="noopener">模板题</a></p>
<p><em>给定一个 n 次多项式 F(x)，和一个 m 次多项式 G(x)。请求出 F(x) 和 G(x) 的卷积。</em> </p>
<p>这里求两个多项式卷积实际上指的是两个多项式相乘的结果用系数表示法输出各个项的系数</p>
<p>假如求$A(x)=F(x)×G(x)$ 其中F(x)的系数以ai表示共m项 G(x)的系数以bi表示共n项</p>
<p>A(x)的系数以ci表示 共n+m项即得到的$A(x)$中degree(A)=degree(F)+degree(G)</p>
<p>用系数表示法求A(x)的系数$ci$需要进行卷积运算即：$c_i=∑_{j=0}^{i} a_j*b_{i-j}$ </p>
<p>而解决这个问题我们所需要做的就是求A(x)</p>
<p>具体的求： $A(x)=IDFT(FFT(F)*FFT(G))$</p>
<p>其中FFT(X)表示将某多项式X从系数表示变为点值表示 IDFT(X)表示将某多项式X从点值表示变为系数表示</p>
<p>意思是我们需要将F(x),G(x)转化为点值式 然后$On$的对应点相乘 再转为系数表达式整体复杂度$Onlogn$</p>
<ul>
<li><p>插入语</p>
<p>这里稍微提一下实现的细节问题，下文会具体贴出实现代码</p>
<p>这里需要注意的是由于degree(A)=degree(F)+degree(G)最后A(x)的系数有n+m个</p>
<p>于是我们直接读入长度为n+m系数矩阵a和b(原来没有的系数为0) 这样FFT和IDFT处理时就不会出错了</p>
<p>另外,在实现FFT时原来的数组含义为存第i项的系数</p>
<p>变为点值表达式后数组的含义为当多项式取$x=w_n^i$时对应的$G(w_n^i)$ 值</p>
<p>IDFT后数组又变成了第i项的系数</p>
</li>
</ul>
<p>##FFT算法实现</p>
<blockquote>
<p><em>key words:实现原理,优化加速</em></p>
<p>本章主要为了了解如何实现&amp;使用FFT 因此推导过程略显潦草</p>
</blockquote>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>最终目的：使用FFT将$A(x)=∑_{i=0}^{n-1}a_ix^i$ 用点值法表示出来</p>
<p>而快速傅里叶变换使用单位根$w_n^i,i∈[0,n-1]$做为点代入求得点值表示法中的{$(x_0,y_0),..,(x_i,y_i)$}  集合</p>
<p>也就是说我们要求出$y_i=A(w_n^i)=∑_{j=0}^{n-1}a_jw_n^{ij}$ $i∈[0,n-1]$  </p>
<p>对于多项式A(x) 它的系数构成的一维矩阵$a=[a_0,a_1,a_2….a_{n-1}]$</p>
<p>将这个系数矩阵按奇偶分组 对应系数下标表示此项为${a_ix^i}$ </p>
<p>$a^{[0]}=[a_0,a_2,…a_{n-2}]$  对应多项式为$A^{[0]}(x)$</p>
<p>$a^{[1]}=[a_1,a_3,…a_{n-1}]$对应多项式为$A^{[1]}(x)$</p>
<p>尝试寻找这三个矩阵(多项式)的关系</p>
<p>得到$A(x)=A^{[0]}(x^2)+xA^{[1]}(x^2)$ (中间的详细过请看鹤翔万里的<a href="https://www.bilibili.com/video/BV1Y7411W73U" target="_blank" rel="noopener">互动视频</a>)</p>
<img src="/.io//timg.gif" data-original="FFT_example4.png">

<p>​            </p>
<p>分别带入单位根$w_n^k$ 和$w_n^{k+n/2}$得到下图两个式子 </p>
<img src="/.io//timg.gif" data-original="FFT_example5.png">

<p>​                 </p>
<p>利用折半引理和消去引理得到</p>
<img src="/.io//timg.gif" data-original="FFT_example6.png">

<p>于是求解$A(x)$的问题被分成两个规模更小(只有A(x)一半系数)的子问题 我们只要求$A^{[0]}(x),A^{[1]}(x)$ 就能得到$A(x)$</p>
<p>同理利用递归分治将求解$A^{[0]}(x),A^{[1]}(x)$ 于是如何将多项式从系数表达式变为点值表达式的问题解决了</p>
<p>接下来考虑如何进行逆变换</p>
<p>以下截取自<a href="https://www.cnblogs.com/zwfymqz/p/8244902.html" target="_blank" rel="noopener">快速傅里叶变换详解</a>(另外加了些注释讲解)</p>
<p>$(y_0,y_1,y_2,\dots,y_{n-1})$为多项式A(x)系数矩阵 $(a_0,a_1,a_2,\dots,a_{n-1})$的傅里叶变换（即点值表示）</p>
<p>设有另一个向量$(c_0,c_1,c_2,\dots,c_{n-1})$满足$c_k=∑_{i=0}^{n−1}y_i(ω_n^{−k})^i $</p>
<p>即多项式$B(x)=y_0,y_1x,y_2x^2,\dots,y_{n-1}x^{n-1}$在$\omega_n^{0},\omega_n^{-1},\omega_n^{-2},\dots,\omega_{n-1}^{-(n-1)}$处的点值表示 </p>
<p>$(c_0,c_1,c_2,\dots,c_{n-1})$满足$c_k=∑_{i=0}^{n-1}y_i(w_n^{-k})^i$ </p>
<p>这样就将点值表示法的矩阵$y$重新视为一个系数表示法的多项式系数 </p>
<p>将$y$做一个替换</p>
<p>$c_k=∑_{i=0}^{n-1}(w_n^{-k})^i(∑_{j=0}^{n-1}a_j(w_n^i)^j)$</p>
<p>因为本来$yi$就是将$w_n^i$带入多项式A(x)的系数表达式$∑_{j=0}^{n-1}a_j(w_n^i)^j$求得的值</p>
<p>其中$aj$是我们最终将A(x)从点值表示变为系数表示所要求的系数</p>
<p>接着运算化简得到： $c_k=∑_{j=0}^{n−1}a_j(∑_{i=0}^{n−1}(ω_n^{j−k})^i) $</p>
<p>这里两个$∑$累加变量i 和 j里外互换是比较常见的操作</p>
<p>实际上可以理解成二维矩阵是一列一列加和还是一行一行加和 结果都是矩阵里所有数的和</p>
<p>设$S(x)=∑_{i=0}^{n-1}x^i$ 带入$w_n^k$ 通过Lemma.3求和引理可得当且仅当k=n时$S(w_n^k)$有值</p>
<p>应此$c_k=∑_{j=0}^{n−1}a_j(∑_{i=0}^{n−1}(ω_n^{j−k})^i) $被化简为$c_k=na_k$</p>
<p>其中$c_k$为点值表示法中矩阵中第k个元素  求得$a_k$为系数表示法中矩阵第k个元素</p>
<p>回头看IDFT的操作实际上是将A(x)的点值表示法视为B(x)系数表示法再进行FFT变换</p>
<p>需要修改的地方就是带入的点为{$(w_n^{-0},B(w_n^{-0})),(w_n^{-1},B(w_n^{-1})),…,(w_n^{-k},B(w_n^{-k})),…$}</p>
<p>并且得到B(x)的点值表示法矩阵ci需要 /n才等于要求的A(x)的系数表示法矩阵ai</p>
<p>​                    <img src="/.io//timg.gif" data-original="FFT_example7.png"></p>
<p>至此解决了FFT和IDFT的推导&amp;实现，现在能实现递归版的FFT&amp;IDFT </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///来自洛谷的模板</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//定义复数的运算 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    <span class="built_in">complex</span> (<span class="keyword">double</span> xx=<span class="number">0</span>,<span class="keyword">double</span> yy=<span class="number">0</span>)&#123;x=xx,y=yy;&#125;</span><br><span class="line">&#125;a[MAXN],b[MAXN];</span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span> + (<span class="built_in">complex</span> a,<span class="built_in">complex</span> b)&#123; <span class="keyword">return</span> <span class="built_in">complex</span>(a.x+b.x , a.y+b.y);&#125;</span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span> - (<span class="built_in">complex</span> a,<span class="built_in">complex</span> b)&#123; <span class="keyword">return</span> <span class="built_in">complex</span>(a.x-b.x , a.y-b.y);&#125;</span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span> * (<span class="built_in">complex</span> a,<span class="built_in">complex</span> b)&#123; <span class="keyword">return</span> <span class="built_in">complex</span>(a.x*b.x-a.y*b.y , a.x*b.y+a.y*b.x);&#125;</span><br><span class="line"><span class="comment">///使用FFT将系数表示法转化为点值表示法注意将系数项个数limit扩展到2的次幂</span></span><br><span class="line"><span class="comment">///type=1为系数表示转点值表示,=-1表示点值变系数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fast_fast_tle</span><span class="params">(<span class="keyword">int</span> limit,<span class="built_in">complex</span> *a,<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(limit==<span class="number">1</span>) <span class="keyword">return</span> ;<span class="comment">//只有一个常数项</span></span><br><span class="line">    <span class="built_in">complex</span> a1[limit&gt;&gt;<span class="number">1</span>],a2[limit&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=limit;i+=<span class="number">2</span>)<span class="comment">//根据下标的奇偶性分类</span></span><br><span class="line">        a1[i&gt;&gt;<span class="number">1</span>]=a[i],a2[i&gt;&gt;<span class="number">1</span>]=a[i+<span class="number">1</span>];</span><br><span class="line">    fast_fast_tle(limit&gt;&gt;<span class="number">1</span>,a1,type);</span><br><span class="line">    fast_fast_tle(limit&gt;&gt;<span class="number">1</span>,a2,type);</span><br><span class="line">    <span class="built_in">complex</span> Wn=<span class="built_in">complex</span>(<span class="built_in">cos</span>(<span class="number">2.0</span>*Pi/limit) , type*<span class="built_in">sin</span>(<span class="number">2.0</span>*Pi/limit)),w=<span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//Wn为单位根，w表示幂</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(limit&gt;&gt;<span class="number">1</span>);i++,w=w*Wn)<span class="comment">//这里的w相当于(wn)^k </span></span><br><span class="line">        a[i]=a1[i]+w*a2[i],</span><br><span class="line">        a[i+(limit&gt;&gt;<span class="number">1</span>)]=a1[i]-w*a2[i];<span class="comment">//利用单位根的性质，O(1)得到另一部分 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然而递归版的FFT仍然不够优秀</p>
<p>接下来要讲如何将递归变为迭代 提高效率</p>
<h3 id="优化加速"><a href="#优化加速" class="headerlink" title="优化加速"></a>优化加速</h3><blockquote>
<p>主要有两种技巧优化加速</p>
<p>1.逆序位置换，2.蝴蝶操作</p>
</blockquote>
<h4 id="1-逆序位置换"><a href="#1-逆序位置换" class="headerlink" title="1.逆序位置换"></a>1.逆序位置换</h4><p>不断递归时我们发现，最初的系数矩阵会被按照奇偶分组 </p>
<p>递归到最后一层时当前系数下标与原数组的下标有一种规律</p>
<p>​                 <img src="/.io//timg.gif" data-original="FFT_example8.png"></p>
<p>上一行是变换前的系数下标，下面为递归到最后的系数对应下标</p>
<p>​                 <img src="/.io//timg.gif" data-original="FFT_example9.png"></p>
<p>经过观察得到规律：</p>
<img src="/.io//timg.gif" data-original="FFT_example10.png">

<p>于是我们可以舍弃递归直接使用位逆序置换操作预处理得到和递归一样的系数下标信息</p>
<p>根据公式<br>$$<br>A(w_n^k)=A^{[0]}(w_{n/2}^k)+ w_n^k A^{[1]}(w_{n/2}^k)<br>$$</p>
<p>$$<br>A(w_n^{k+n/2})=A^{[0]}(w_{n/2}^k)-w_n^kA^{[1]}(w_{n/2}^k)<br>$$</p>
<p>得到如下迭代运算过程</p>
<img src="/.io//timg.gif" data-original="FFT_example11.png">

<p>另外公式中$w_n^kA^{[1]}(w_{n/2}^k)$ 复数乘法被计算两次 可以将它计算一次后存入一个变量避免重复操作</p>
<p>这个优化被成为<em>蝴蝶操作</em></p>
<p>于是迭代版的FFT也就出来了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r,i;</span><br><span class="line">    Complex()&#123;r=<span class="number">0</span>,i=<span class="number">0</span>;&#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real,<span class="keyword">double</span> imag):r(real),i(imag)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Complex <span class="keyword">operator</span> + (Complex a, Complex b)&#123;<span class="keyword">return</span> Complex(a.r+b.r,a.i+b.i);&#125;</span><br><span class="line">Complex <span class="keyword">operator</span> - (Complex a, Complex b)&#123;<span class="keyword">return</span> Complex(a.r-b.r,a.i-b.i);&#125;</span><br><span class="line">Complex <span class="keyword">operator</span> * (Complex a, Complex b)&#123;<span class="keyword">return</span> Complex(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rev[Max],len,lim=<span class="number">1</span>;</span><br><span class="line">Complex a[Max],b[Max];<span class="comment">///原多项式系数</span></span><br><span class="line"><span class="comment">///预处理位逆变换</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getrev</span><span class="params">(<span class="keyword">int</span> lenth,<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;i++)rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(len<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *A,<span class="keyword">int</span> opt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)<span class="keyword">if</span>(i&lt;rev[i]) swap(A[i],A[rev[i]]);<span class="comment">///求出要迭代的序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid=<span class="number">1</span>;mid&lt;lim;mid&lt;&lt;=<span class="number">1</span>)&#123;<span class="comment">///待合并区间长度的一半</span></span><br><span class="line">        Complex Wn=Complex(<span class="built_in">cos</span>(Pi/mid),opt*<span class="built_in">sin</span>(Pi/mid));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> R=mid&lt;&lt;<span class="number">1</span>,i=<span class="number">0</span>;i&lt;lim;i+=R)&#123;<span class="comment">///R是区间的右端点，i表示前已经到哪个位置了</span></span><br><span class="line">            Complex W=Complex(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;mid;k++)&#123;<span class="comment">///枚举左半部分</span></span><br><span class="line">                Complex x=A[i+k],y=W*A[i+mid+k];<span class="comment">///蝴蝶操作</span></span><br><span class="line">                A[i+k]=x+y;</span><br><span class="line">                A[i+mid+k]=x-y;</span><br><span class="line">                W=W*Wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是之前的模板题<a href="https://www.luogu.com.cn/problem/P3803" target="_blank" rel="noopener">模板题</a></p>
<p>我们要添加上逆序位置换 然后实现$A(x)=IDFT(FFT(F)*FFT(G))$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e7</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r,i;</span><br><span class="line">    Complex()&#123;r=<span class="number">0</span>,i=<span class="number">0</span>;&#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real,<span class="keyword">double</span> imag):r(real),i(imag)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Complex <span class="keyword">operator</span> + (Complex a, Complex b)&#123;<span class="keyword">return</span> Complex(a.r+b.r,a.i+b.i);&#125;</span><br><span class="line">Complex <span class="keyword">operator</span> - (Complex a, Complex b)&#123;<span class="keyword">return</span> Complex(a.r-b.r,a.i-b.i);&#125;</span><br><span class="line">Complex <span class="keyword">operator</span> * (Complex a, Complex b)&#123;<span class="keyword">return</span> Complex(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rev[Max],len,lim=<span class="number">1</span>;</span><br><span class="line">Complex a[Max],b[Max];<span class="comment">///原多项式系数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *A,<span class="keyword">int</span> opt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)<span class="keyword">if</span>(i&lt;rev[i]) swap(A[i],A[rev[i]]);<span class="comment">///求出要迭代的序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid=<span class="number">1</span>;mid&lt;lim;mid&lt;&lt;=<span class="number">1</span>)&#123;<span class="comment">///待合并区间的中点</span></span><br><span class="line">        Complex Wn=Complex(<span class="built_in">cos</span>(Pi/mid),opt*<span class="built_in">sin</span>(Pi/mid));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> R=mid&lt;&lt;<span class="number">1</span>,i=<span class="number">0</span>;i&lt;lim;i+=R)&#123;<span class="comment">///R是区间的右端点，i表示前已经到哪个位置了</span></span><br><span class="line">            Complex W=Complex(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;mid;k++)&#123;<span class="comment">///枚举左半部分</span></span><br><span class="line">                Complex x=A[i+k],y=W*A[i+mid+k];<span class="comment">///蝴蝶操作</span></span><br><span class="line">                A[i+k]=x+y;</span><br><span class="line">                A[i+mid+k]=x-y;</span><br><span class="line">                W=W*Wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i].r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;b[i].r;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;=n+m) lim&lt;&lt;=<span class="number">1</span>,len++;<span class="comment">///此处注意n与m都是从0开始的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)</span><br><span class="line">        rev[i]= ( rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span> )| ( (i&amp;<span class="number">1</span>)&lt;&lt;(len<span class="number">-1</span>) ) ;</span><br><span class="line">    <span class="comment">// 在原序列中 i 与 i/2 的关系是 ： i可以看做是i/2的二进制上的每一位左移一位得来</span></span><br><span class="line">    <span class="comment">// 那么在反转后的数组中就需要右移一位，同时特殊处理一下复数</span></span><br><span class="line">    FFT(a,<span class="number">1</span>);FFT(b,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;i++) a[i]=a[i]*b[i];</span><br><span class="line">    FFT(a,<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">///根据逆变换推导，最后输出实部要记得除长度limit</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+m;i++)<span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>)(a[i].r/lim+<span class="number">0.5</span>)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="comment">///+0.5上取整调整精度,此时虚部已经全为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还有个小技巧三次FFT可以被优化成两次FFT同样得到结果</p>
<p>我们可以把$G(x)$放到$F(x)$的虚部上求出$F^2(x)$ ,然后取出$F(x)$的虚部全部/2就是答案了</p>
<p>正确性证明：$(a+bi)^2=(a^2-b^2)+(2abi)$</p>
<p>不过上面的代码中还有一些疑问比如为什么要+0.5上取整调整精度这是哪步产生的</p>
<p>到此为止FFT的实现优化已经结束。</p>
<p>接下来将要讨论NTT是什么以及FFT与信号处理的关系。</p>
<h2 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h2><blockquote>
<p><em>key words:原根,具体实现</em></p>
</blockquote>
<p>由于FFT需要用到复数 使用double精度较差</p>
<p>而NTT使用原根替代FFT中的单位根进行点值转换 其余原理相同</p>
<h3 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h3><p>首先介绍一个概念”阶“</p>
<p>若a,p互素且p&gt;1 对于$a^n≡1 (modp)$最小的n 我们称之为a模p的阶,记作$ δ_p(a)=n $</p>
<p>例如(似乎必须大于0)：</p>
<p>$δ_7(2)=3$，</p>
<p>$2^1≡2(mod7)$</p>
<p>$2^2≡4(mod7)$</p>
<p>$2^3≡1(mod7)$</p>
<p>然后就是要讨论的原根了</p>
<p>原根的定义：设p是正整数，a是整数，若$δ_p(a)$等于$ϕ(p)$，则称a为模p的一个原根 </p>
<p> $δ_7(3)=6=ϕ(7)$，也就是说$3^6mod7=1$ 其中6是3模p的阶, 因此3是模7的一个原根 </p>
<p>($ϕ(x)$是欧拉函数表示小于x且与x互素的数有几个不包括1,默认$ϕ(1)=1$)</p>
<p>注意原根的个数是不唯一的 如果模数p有原根，那么它一定有$ϕ(ϕ(p))$个原根 </p>
<p>根据原根的定义我们得到 对于质数p,假若g是p的原根 则有$g^{ϕ(p)}=1(modp)$</p>
<p>因为$δ_p(g)=ϕ(p)$ ,进一步可以得到$g^imodP(1&lt;g&lt;P,0&lt;i&lt;P)$的结果两两不同</p>
<p>对于质数$p=k×2^N+1$,设其原根为g,我们令$g_n=g^{(p-1)/n} (modp)$ ,注意这里的$g_n$是定义出来的 </p>
<p>在数值上等于$g^{(p-1)/n}$ 与g无关，在NTT中原根扮演了单位根的角色</p>
<p>$g_n$同样也满足单位根的三个性质 所以它能够替代单位根</p>
<p>证明参考<a href="https://blog.csdn.net/linjiayang2016/article/details/95349208" target="_blank" rel="noopener">此处</a></p>
<p>####细节</p>
<ul>
<li><p>为什么质数p一定要取$p=k×2^N+1$ </p>
<p>定义中$g_n=g^{(p-1)/n} (modp)$,  $(p-1)/n$必须为整数 </p>
<p>考虑FFT的过程是不断将系数数组二分的过程(递归时n&gt;&gt;1)</p>
<p>且在使用FFT前就要确保n(n就是系数数组的长度)为2的次幂</p>
<p>因而p-1要有足够大的2^N 才能保证(p-1)能被n整除 保证递归顺利进行</p>
</li>
<li><p>在逆变换时需要求 $g_n^{-1}$，在模意义下，也就是 $g_n$ 的逆元，预处理即可 </p>
</li>
</ul>
<p>p建议取998244353，它的原根为3。(注意读题有的题里会出现993244353这个数它的原根不是3)</p>
<p>如何求任意一个质数的原根呢？</p>
<p>对于质数p，质因子分解p−1，若$g^{(p−1)/pi}≠1(modp)$恒成立，g为p的原根</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">998244353</span>,G=<span class="number">3</span>,inv_G=<span class="number">332748118</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,limit,len,rev[Max];</span><br><span class="line">ll a[Max],b[Max];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a,ll k)</span> </span>&#123;</span><br><span class="line">    ll base=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) base=(base*a)%P;</span><br><span class="line">        a=(a*a)%P;k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> base%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inv(x) fastpow(x,P-2)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *A,<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;i++)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i]) swap(A[i],A[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid=<span class="number">1</span>;mid&lt;limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll Wn=qpow(type==<span class="number">1</span>?G:inv_G,(P<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;limit;j+=(mid&lt;&lt;<span class="number">1</span>)) &#123;</span><br><span class="line">            ll w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;mid;k++,w=(w*Wn)%P) &#123;</span><br><span class="line">                <span class="keyword">int</span> x=A[j+k],y=w*A[j+k+mid]%P;</span><br><span class="line">                A[j+k]=(x+y)%P,</span><br><span class="line">                A[j+k+mid]=(x-y+P)%P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="FFT与信号处理的关系"><a href="#FFT与信号处理的关系" class="headerlink" title="FFT与信号处理的关系"></a>FFT与信号处理的关系</h2><blockquote>
<h4 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.bilibili.com/video/BV1aT4y1J7JP#reply3333168665" target="_blank" rel="noopener">傅里叶变换夯实基础-离散傅里叶变换</a></p>
<p><a href="https://www.bilibili.com/video/av44600709" target="_blank" rel="noopener">离散傅里叶变换入门</a></p>
</blockquote>
<p>在上文讨论的FFT中 丝毫没有看见傅里叶变换最原始的用途：时域函数与频域函数的转换的影子</p>
<p>实际上多项式的点值表示法对应时域描述,而系数表示法则对应频域描述</p>
<p>回忆多项式$F(x)=∑a_kx^k$当带入点{$w_n^0, w_n^1, ..w_n^k…$}时得到了对应点{$(w_n^k ,F(w_n^k))$}</p>
<p>对于多项式而言$y_k=F(w_n^k)=∑_{j=0}^{n-1}a_jw_n^{kj}$ ，其中$w_n^k=(e^{2pi/n})^k$  </p>
<p>而某函数$f(x)$的傅里叶级数展开$f(x)=∑_{n=-inf}^{inf}c_ke^{ikx}$ </p>
<p>多项式带入一个自变量$x=w_n^k$ 就相当于函数的傅里叶级数表达式带入自变量$x=k*2pi/n$</p>
<img src="/.io//timg.gif" data-original="example.png">

<p>当我们将{$w_n^0, w_n^1, ..w_n^k…$}带入多项式 时我们就得到了下图左侧傅里叶级数对应的函数值</p>
<p>也就是时域上一系列点值{$(w_n^k ,F(w_n^k))$}</p>
<img src="/.io//timg.gif" data-original="example1.png">

<p>傅里叶级数是将函数用不同的频率分量($cosθ+isinθ$ )×权值($c_i$)求和得到的一个时域表达式</p>
<p>(时域函数图像就是不同时刻(x)对应的信号强度(y) )</p>
<p>而傅里叶变换是通过 时域上的点值{$(w_n^k ,F(w_n^k))$} 求得 频域上不同频率分量的权值 $c_i$</p>
<p>逆变换是通过频域上的权值$c_i$求得 时域上的一系列点值</p>
<p>(频域函数图像就是不同频率分量(频率为x)的幅值(权值为y) )</p>
<p>相当于通过系数表达式 求得 点值表达式 </p>
<p>只不过我们将多项式中的自变量替换成了$w_n^k$</p>
<p>这就相当于将多项式中的x当成不同频率分量而系数则成为权值</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>FFT &amp; NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-4609</title>
    <url>/2020/08/17/HDU4609/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4609" target="_blank" rel="noopener">3-idiots</a></p>
<p>题意</p>
<p>t组测试，每组测试给出n条木棒 n&lt;1e5</p>
<p>然后输入n条木棒的长度ai,问等概率取出三条木棒能构成三角形的概率</p>
<p>题解</p>
<p><a href="https://blog.csdn.net/m0_38013346/article/details/81736390" target="_blank" rel="noopener">参考题解A</a>      <a href="https://www.cnblogs.com/tempestT/p/7672496.html" target="_blank" rel="noopener">参考题解B</a></p>
<p>首先将读入信息从每个木棒长度 变为 每种长度几根木棒</p>
<p>例如lenth={1,3,3,4} 变为 num={0,1,0,2,1} </p>
<p>即长度为0的有0根,1的有1根,…..</p>
<p>那么如果从它们中任选两根组成三角形的两边和 那么可以得到</p>
<p>num={0, 0, 1, 0, 4, 2,  4,  4,  1} </p>
<p>(其中有AB互换得到的和以及同一根木棍自己和自己相加得到的和,之后会减去) </p>
<p>假如用生成函数来描述 那么 {0,1,0,2,1} 记为$f(x)=0x^0+1x^1+0x^2+2x^3+1x^4$</p>
<p>而两两匹配得到的{0, 0, 1, 0, 4, 2,  4,  4,  1} </p>
<p>实际上就是$f(x)×f(x)=0x^0+0x^1+1x^2+0x^3+4x^4+2x^5+4x^6+4x^7+1x^8$</p>
<p>其中次幂i表示长度,系数ai表示有多少根木棍=该长度i</p>
<p>于是我们可以利用FFT求出木棍两两组合得到新的长度各有多少种</p>
<p>另外需要容斥排除掉一些情况，在代码的注释中会有解释</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define Turnoff s<span class="symbol">td:</span><span class="symbol">:io</span><span class="symbol">s:</span><span class="symbol">:sy</span>nc_with_stdio(<span class="built_in">false</span>)</span><br><span class="line">const ll <span class="built_in">Max</span>=<span class="number">3</span>e5+<span class="number">5</span>;</span><br><span class="line">const double <span class="built_in">Pi</span>=<span class="built_in">acos</span>(-<span class="number">1</span>);</span><br><span class="line">/*</span><br><span class="line">*/</span><br><span class="line">struct <span class="built_in">Complex</span>&#123;</span><br><span class="line">    double r,i;</span><br><span class="line">    <span class="built_in">Complex</span>()&#123;r=<span class="number">0</span>,i=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>(double real,double imag)<span class="symbol">:r</span>(real),i(imag)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Complex</span> operator + (<span class="built_in">Complex</span> a, <span class="built_in">Complex</span> b)&#123;return <span class="built_in">Complex</span>(a.r+b.r,a.i+b.i);&#125;</span><br><span class="line"><span class="built_in">Complex</span> operator - (<span class="built_in">Complex</span> a, <span class="built_in">Complex</span> b)&#123;return <span class="built_in">Complex</span>(a.r-b.r,a.i-b.i);&#125;</span><br><span class="line"><span class="built_in">Complex</span> operator * (<span class="built_in">Complex</span> a, <span class="built_in">Complex</span> b)&#123;return <span class="built_in">Complex</span>(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);&#125;</span><br><span class="line"></span><br><span class="line">ll rev[<span class="built_in">Max</span>],<span class="built_in">len</span>=<span class="number">0</span>,lim=<span class="number">1</span>,ans[<span class="built_in">Max</span>];</span><br><span class="line"><span class="built_in">Complex</span> a[<span class="built_in">Max</span>],b[<span class="built_in">Max</span>];///原多项式系数</span><br><span class="line">ll <span class="built_in">sum</span>[<span class="built_in">Max</span>],lenth[<span class="built_in">Max</span>],num[<span class="built_in">Max</span>];</span><br><span class="line">///预处理位逆变换</span><br><span class="line">inline void getrev(<span class="built_in">int</span> lena,<span class="built_in">int</span> <span class="built_in">lenb</span>)&#123;</span><br><span class="line">    <span class="built_in">int</span> limit=<span class="number">1</span>,lenth=<span class="number">0</span>;</span><br><span class="line">    while(limit&lt;=lena+<span class="built_in">lenb</span>)limit&lt;&lt;=<span class="number">1</span>,lenth++;</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;limit;i++)rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(lenth-<span class="number">1</span>));</span><br><span class="line">    lim=limit,<span class="built_in">len</span>=lenth;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">inline void FFT(<span class="built_in">Complex</span> *A,<span class="built_in">int</span> opt)&#123;</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;lim;i++)<span class="built_in">if</span>(i&lt;rev[i]) swap(A[i],A[rev[i]]);///求出要迭代的序列</span><br><span class="line">    for(<span class="built_in">int</span> <span class="built_in">mid</span>=<span class="number">1</span>;<span class="built_in">mid</span>&lt;lim;<span class="built_in">mid</span>&lt;&lt;=<span class="number">1</span>)&#123;///待合并区间长度的一半</span><br><span class="line">        <span class="built_in">Complex</span> Wn=<span class="built_in">Complex</span>(<span class="built_in">cos</span>(<span class="built_in">Pi</span>/<span class="built_in">mid</span>),opt*<span class="built_in">sin</span>(<span class="built_in">Pi</span>/<span class="built_in">mid</span>));</span><br><span class="line">        for(<span class="built_in">int</span> R=<span class="built_in">mid</span>&lt;&lt;<span class="number">1</span>,i=<span class="number">0</span>;i&lt;lim;i+=R)&#123;///R是区间的右端点，i表示前已经到哪个位置了</span><br><span class="line">            <span class="built_in">Complex</span> W=<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            for(<span class="built_in">int</span> k=<span class="number">0</span>;k&lt;<span class="built_in">mid</span>;k++)&#123;///枚举左半部分</span><br><span class="line">                <span class="built_in">Complex</span> x=A[i+k],y=W*A[i+<span class="built_in">mid</span>+k];///蝴蝶操作</span><br><span class="line">                A[i+k]=x+y;</span><br><span class="line">                A[i+<span class="built_in">mid</span>+k]=x-y;</span><br><span class="line">                W=W*Wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span>(opt==-<span class="number">1</span>)for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;lim;i++)A[i].r=(A[i].r/lim+<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    //Turnoff;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">t</span>;</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&amp;<span class="built_in">t</span>);</span><br><span class="line">    while(<span class="built_in">t</span>--)&#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">n</span>;scanf(<span class="string">"%d"</span>,&amp;<span class="built_in">n</span>);</span><br><span class="line">        ll maxlen=<span class="number">0</span>,tot=<span class="number">1</span>ll*<span class="built_in">n</span>*(<span class="built_in">n</span>-<span class="number">1</span>)*(<span class="built_in">n</span>-<span class="number">2</span>)/<span class="number">6</span>;</span><br><span class="line">        memset(a,<span class="number">0</span>,sizeof a);</span><br><span class="line">        memset(<span class="built_in">sum</span>,<span class="number">0</span>,sizeof <span class="built_in">sum</span>);</span><br><span class="line">        //memset(num,<span class="number">0</span>,sizeof num);</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">n</span>;i++)&#123;</span><br><span class="line">            scanf(<span class="string">"%lld"</span>,lenth+i);</span><br><span class="line">            a[lenth[i]].r++;</span><br><span class="line">            //num[lenth[i]]++;</span><br><span class="line">            maxlen=<span class="built_in">max</span>(maxlen,lenth[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        getrev(maxlen,maxlen);FFT(a,<span class="number">1</span>);</span><br><span class="line">        maxlen*=<span class="number">2</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;lim;i++)a[i]=a[i]*a[i];</span><br><span class="line">        FFT(a,-<span class="number">1</span>);</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;lim;i++)<span class="built_in">sum</span>[i]=a[i].r;</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">n</span>;i++)<span class="built_in">sum</span>[lenth[i]*<span class="number">2</span>]--;</span><br><span class="line">        ///同一根木棒自己加自己 不合法减去</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=maxlen;i++)<span class="built_in">sum</span>[i]/=<span class="number">2</span>;</span><br><span class="line">        /// 两根木棒AB互换后BA重复统计 不合法/<span class="number">2</span></span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=maxlen;i++)<span class="built_in">sum</span>[i]+=<span class="built_in">sum</span>[i-<span class="number">1</span>];</span><br><span class="line">        /// 做前缀和处理</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        sort(lenth,lenth+<span class="built_in">n</span>);</span><br><span class="line">        ///排序构成三角形的第三边(最长边)长度</span><br><span class="line">        ///枚举最长边</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">n</span>;i++)&#123;</span><br><span class="line">            ans+=<span class="built_in">sum</span>[maxlen]-<span class="built_in">sum</span>[lenth[i]];</span><br><span class="line">            ///根据定理两边之和大于第三边得到两边和大于枚举边长度lenth[i]的总数</span><br><span class="line">            ///我们假定lenth[i]最长</span><br><span class="line">            ans-=<span class="number">1</span>ll*i*(<span class="built_in">n</span>-i-<span class="number">1</span>);</span><br><span class="line">            ///两边中有一个大于lenth[i]一个小于lenth[i]</span><br><span class="line">            ans-=<span class="number">1</span>ll*(<span class="built_in">n</span>-i-<span class="number">1</span>)*(<span class="built_in">n</span>-i-<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">            ///两边都大于lenth[i]</span><br><span class="line">            ans-=<span class="number">1</span>ll*(<span class="built_in">n</span>-<span class="number">1</span>);</span><br><span class="line">            ///另外两边中有一个就是lenth[i]本身</span><br><span class="line">        &#125;</span><br><span class="line">        //cout&lt;&lt;ans&lt;&lt;<span class="string">" "</span>&lt;&lt;tot&lt;&lt;endl;</span><br><span class="line">        printf(<span class="string">"%.7f\n"</span>,<span class="number">1.0</span>*ans/tot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>FFT &amp; NTT</tag>
        <tag>组合数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo踩坑指南</title>
    <url>/2020/07/08/Hexo%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>此文主要整合了用Hexo搭建博客时遇到的一些疑难杂症</p>
<p>不会js css也能也能用hexo搭建博客 网上已经有各种比较成熟的资源和解决方案</p>
<p>当然会更好可以有更高自由度的体验</p>
<p>hexo提供了框架  剩下的只要跟着搭积木(插件)就行了 </p>
<p>hexo搭建的主要流程网上已经有许多<a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=17266873825643509764" target="_blank" rel="noopener">详细教程</a> 此处不再赘述</p>
<p>在搭建之前请先下载安装 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>  <a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">git</a>  <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>  </p>
<p>npm（Node Package Manager，节点包管理器）是NodeJS的包管理器，用于节点插件的管理（包括安装，卸载和管理依赖等）。npm是随同新版的NodeJS一起安装的包管理工具，所以我们需要安装NodeJS。</p>
<p>安装完node.js后在控制台输入</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install cnpm -g --registry=https://registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure>

<p>用cnpm 从淘宝源中下载所需插件</p>
<p>git 主要是用于clone github中的主题和其他插件</p>
<p>在部署仓库上有三种选择 github / gitee / coding 仓库</p>
<p>github 国外网站加载缓慢 但可以自动部署 支持Gittalk</p>
<p>gitee 码云仓库加载快但是需要付费才能自动部署每次hexo d 都得到仓库里手动更新</p>
<p>coding 相较之下加载快而且支持自动部署 但是地址难记</p>
<p>关于主题 <a href="https://blog.csdn.net/zgd826237710/article/details/99671027" target="_blank" rel="noopener">这篇</a> 博客中罗列了一些 hexo官网也有展示但是不知道怎么下载</p>
<p>还得在github渠道git clone</p>
<p>win10环境下 本地部署到github时 经常会出现</p>
<p>HttpRequestException encountered报错</p>
<p><a href="https://blog.csdn.net/feitianlongfei/article/details/80904347" target="_blank" rel="noopener">解决方法一</a></p>
<p>尝试后仍不能解决</p>
<p>之后将网站根目录的配置文件 _config.yml 中的</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: </span><br><span class="line">    <span class="attribute">github</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:PeiGiZhu/PeiGiZhu.github.io.git</span><br><span class="line">    <span class="attribute">gitee</span>: <span class="attribute">https</span>:<span class="comment">//gitee.com/peigizhu/PeiGiZhu.git</span></span><br><span class="line">    <span class="attribute">coding</span>: <span class="attribute">https</span>:<span class="comment">//e.coding.net/peigizhu/peigizhu/peigizhu.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>

<p>github: 后面的仓库地址 从 http:// 改为 git@ 后就不再出现</p>
<p>更改为git@ 需要本地和仓库间需要ssh公钥验证 才能从本地直接将代码部署到仓库</p>
<p><a href="http://www.bubuko.com/infodetail-3334479.html" target="_blank" rel="noopener">如何生成ssh key</a> </p>
<p><a href="https://www.jianshu.com/p/7d686d8b7857" target="_blank" rel="noopener">如何用ssh key部署</a></p>
<p>本地生成的ssh key(public key)可以反复使用 </p>
<p>此处以gitee和coding部署流程为例 github仓库操作类似</p>
<p><a href="https://www.jianshu.com/p/79bd6fb15790" target="_blank" rel="noopener">这篇博客</a>里有图文流程可以参考</p>
<p><a href="https://www.jianshu.com/p/a2d298e26dcd" target="_blank" rel="noopener">hexo常用指令</a></p>
<p>部署时记得先清理缓存</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">hexo clean <span class="meta">&amp; hexo g -d <span class="comment">///一次性清理&amp;生成&amp;部署</span></span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qitong111/article/details/80217281" target="_blank" rel="noopener">可视化编辑工具-Typora</a>下载</p>
<p><a href="https://www.cnblogs.com/yyhh/p/11058985.html" target="_blank" rel="noopener">大佬自建博客详细指导</a></p>
<p><a href="https://blog.csdn.net/qq_36759224/article/details/85010191?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.nonecase" target="_blank" rel="noopener">Hexo功能&amp;插件优化</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1381382" target="_blank" rel="noopener">Hexo功能&amp;插件优化</a></p>
<p><a href="https://blog.csdn.net/l_201607/article/details/81097278" target="_blank" rel="noopener">Hexo功能&amp;插件优化</a></p>
<p><strong>在更新文章时发现的问题</strong></p>
<p>文章出现乱码 ： 尝试将文章.md 文件用笔记本打开另存为时设置编码为 UTF-8</p>
<p>博客中进入某个标签再点菜单中的首页 加载十分缓慢 </p>
<p>多数情况是由于引用了google源字体 导致加载缓慢 <a href="https://blog.csdn.net/MSDN_tang/article/details/106610897" target="_blank" rel="noopener">解决方案</a></p>
<p>但是由于使用主题不同 本人没有贸然修改(主要不懂这方面)</p>
<p>如何在百度上搜素到自己的博客而不是以链接的形式 <a href="https://www.jianshu.com/p/f37452d4978e" target="_blank" rel="noopener">参考此处</a></p>
<p>注意！私有仓库的前提下再使用第二种主动推送 </p>
<p>部署到仓库后网页没有更新 如果是gitee仓库请到gitee page 手动更新 </p>
<p>若不同浏览器打开博客后内容不同 尝试清理浏览器缓存后重新加载</p>
<p>typora插入图片 网页中不显示？<a href="https://blog.csdn.net/xh13096/article/details/103510129" target="_blank" rel="noopener">原因</a></p>
<p>可以在要编辑的md同目录下新建一个img文件夹 </p>
<p>然后在要插入的地方写入以下html语句</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"img/xxx.jpg"</span> <span class="attribute">width</span>=<span class="string">"100px"</span> <span class="attribute">height</span>=<span class="string">"100px"</span> /&gt;</span><br></pre></td></tr></table></figure>



<p>有些主题没有自带百度统计功能 需要手动写入</p>
<p>具体方法参考<a href="https://www.cnblogs.com/fazero/p/7976651.html" target="_blank" rel="noopener">此处</a></p>
<p>置顶功能没有达到理想效果 <a href="https://www.cnblogs.com/lqerio/p/11117467.html" target="_blank" rel="noopener">参考</a></p>
<p>Note：主题(themes)不同, 实现/解决方案不同 ,不同themes间并不能完全移植</p>
<p>更多资源/问题在优化本站时会再更新整合</p>
]]></content>
      <categories>
        <category>资料整理</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC Northwestern European Regional Programming Contest (NWERC 2018)</title>
    <url>/2020/09/05/NWERC%202018-B/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/102483/problem/B" target="_blank" rel="noopener">B - Brexit Negotiations</a></p>
<p>题意 </p>
<p>有n&lt;4e5个会议 每个会议需要开mint[i]分钟</p>
<p>开这个会议前需要指定几个其他的会议正在进行或已经结束</p>
<p>即想要取某个点需要先获得它的前继点</p>
<p>其次开始某个会议一分钟之后才能开始下一个会议</p>
<p>问开完所有会议最短需要多久</p>
<p>题解</p>
<p><a href="https://blog.csdn.net/gyr679/article/details/107270212" target="_blank" rel="noopener">参考题解</a></p>
<p><a href="https://blog.csdn.net/backordinary/article/details/105206763?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">参考题解</a></p>
<p>根据依赖关系，建立DAG。首先想到拓扑排序，由于题目要开完所有会议时间最短</p>
<p>于是当有多个会议满足前驱条件 (它指定的几个会议正在进行或已经结束) </p>
<p>则选择时间最长的会议先进行</p>
<p>过一分钟之后在选择其他会议 直觉上这样贪心</p>
<p>但正向贪心存在漏洞:</p>
<p>比如 (数字表示时间)</p>
<p>5-&gt;1</p>
<p>2-&gt;9</p>
<p>选择5 过一分种后选 2 再过一分钟后选9 最后选1</p>
<p>则总时长为11;</p>
<p>但实际上最优选择是先选择2 过一分钟再选择9 过一分钟再选择5 过一分钟再选择1</p>
<p>所以正向贪心不一定正确</p>
<p>考虑反向建边(从后往前考虑) 进行拓扑排序将入度为0的点(最后开的会议)压入优先队列</p>
<p>优先队列以会议时间短的优先级高 </p>
<p>于是对于上个样例</p>
<p>5-&gt;1</p>
<p>2-&gt;9</p>
<p>先拿出1放在最后 往前推1分钟 取出5 往前推1分钟 取出9 前推一分钟取出2</p>
<p>反向建图实际上是假设 上一级子问题已经取得最优解的状态下</p>
<p>讨论最后放时长最短的会议，对于上一级子问题以此类推</p>
<p>而正向建图 讨论当前状态下取出最优的点需要dfs到最后 判断选择哪个点</p>
<p>而不是直接根据贪心当前能取的点中时间最长的会议</p>
<p>所以正向建图贪心需要正向搜素反向回溯 于是干脆选择反向建边拓扑排序贪心</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll mint[Max];</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"><span class="keyword">int</span> in[Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;mint[i];</span><br><span class="line">        <span class="keyword">int</span> need;<span class="built_in">cin</span>&gt;&gt;need;</span><br><span class="line">        <span class="keyword">while</span>(need--)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v=i;<span class="built_in">cin</span>&gt;&gt;u;</span><br><span class="line">            mp[v].push_back(u);</span><br><span class="line">            in[u]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;,greater&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; &gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="keyword">continue</span>;</span><br><span class="line">        q.push(&#123;mint[i],i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt=n<span class="number">-1</span>,maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">///对于最后1个会议前面n-1个会议不间断进行则需要n-1分钟</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; now=q.top();q.pop();</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,cnt+now.first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[now.second])&#123;</span><br><span class="line">            in[i]--;</span><br><span class="line">            <span class="keyword">if</span>(in[i])<span class="keyword">continue</span>;</span><br><span class="line">            q.push(&#123;mint[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt--;</span><br><span class="line">        <span class="comment">///对于最后第k个会议 前面n-k个会议不间断进行则需要n-k分钟</span></span><br><span class="line">        <span class="comment">///下次循环解决上一级子问题</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>拓扑排序</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.862</title>
    <url>/2020/09/24/LeetCode%20862/</url>
    <content><![CDATA[<p><a href="https://tianchi.aliyun.com/oj/73486278997090424?spm=5176.15098393.J_6210563800.2.52d25cd6YTh6lz" target="_blank" rel="noopener">LeetCode 862. 和至少为 K 的最短子数组</a> </p>
<p>题意</p>
<p>给出长度5e4的数组 其中元素ai在[-1e5,1e5]之间</p>
<p>求最短的一段子串和&gt;=k 的长度</p>
<p>题解</p>
<p><a href="https://blog.csdn.net/qq_21201267/article/details/105662545" target="_blank" rel="noopener">参考题解</a></p>
<p>最初想法直接用双指针滑窗扫一遍</p>
<p>但是由于存在负数 </p>
<p>当某段区间中存在负数 双指针会将区间两端不断扩大 才有可能达到k</p>
<p>但是实际情况是将原来区间内的负数剔除掉就能达到k且长度更短</p>
<p>用双端队列q 将数组的前缀和 以单调队列的方式存入/弹出</p>
<p>当此位i前缀和sum[i]-sum[q.front()]&gt;=k时满足条件尝试缩短区间长度更新答案</p>
<p>也就是将q的队首弹出再次判断是否符合条件</p>
<p>当此位i的前缀和sum[i]&lt;=sum[q.back()] 那说明以i为左端点L比以q.back()</p>
<p>为左端点L更容易使得sum[R]-sum[L]&gt;=K成立 且i&gt;q.back()说明区间长度更短</p>
<p>所以我们弹出q的队尾将i压入队尾</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param A: the array</span></span><br><span class="line"><span class="comment">     * @param K: sum</span></span><br><span class="line"><span class="comment">     * @return: the length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum[(<span class="keyword">int</span>)<span class="number">5e4</span>+<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">5e4</span>+<span class="number">5</span>,n=A.<span class="built_in">size</span>();q.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum[i]=A[i<span class="number">-1</span>]+sum[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;sum[i]-sum[q.front()]&gt;=K)&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,i-q.front());</span><br><span class="line">                q.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;sum[q.back()]&gt;=sum[i])q.pop_back();</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans!=<span class="number">5e4</span>+<span class="number">5</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA列车调度</title>
    <url>/2020/10/27/PTA%E5%88%97%E8%BD%A6%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1049" target="_blank" rel="noopener">7-10 列车调度</a></p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<img src="/.io//timg.gif" data-original="example.png">



<p>两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有<code>N</code>条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？ </p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>要想得到最少的调度序列，</p>
<p>那就要找出最少的下降序列的个数。拿样例来说：有如下四个下降序列</p>
<p>8 4 2 1</p>
<p>5 3</p>
<p>9 6</p>
<p>7</p>
<p>根据Dilworth定理：某序列的最小的下降序列的个数等于它最长上升子序列的长度。</p>
<p>于是用二分栈优化dp求最长上升子序列</p>
<p>代码实现似乎像用栈模拟，反过来像用栈模拟可以nlogn求解最长上升子序列</p>
<p><a href="https://blog.csdn.net/lxt_Lucia/article/details/81206439" target="_blank" rel="noopener">LIS最长上升子序列</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> random(x) (rand()%x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[Max],st[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        st[i]=inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> need=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=lower_bound(st,st+n,arr[i])-st;</span><br><span class="line">        st[pos]=arr[i];</span><br><span class="line">        need=<span class="built_in">max</span>(need,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;need&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Dilworth</tag>
        <tag>二分栈优化</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#312-C</title>
    <url>/2020/08/11/codeforces-312-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/558/C" target="_blank" rel="noopener">C. Amr and Chemistry</a> </p>
<p>题意</p>
<p>给出一个长度为n&lt;1e5的数组</p>
<p>一次操作能让ai变为2ai 或 让ai变为 ai/2 下取整</p>
<p>问最少几次能让全部的数组元素相等</p>
<p>题解</p>
<p>对一个数 ×2或÷2下取整 </p>
<p>用二进制表示相当于位运算中&lt;&lt;1或&gt;&gt;1</p>
<p>观察发现 右移或左移不能产生新的二进制1 </p>
<p>但能删去原来二进制中的1</p>
<p>所以要操作最小次数得到相同元素必然会是数组a中所有数的二进制串</p>
<p>中最长的相同前缀</p>
<p>比如3 5 6的二进制：</p>
<p>011</p>
<p>101</p>
<p>110</p>
<p>为了找最长的相同前缀 我们需要将首位的一移动到相同的位置</p>
<p>变为</p>
<p>110</p>
<p>101</p>
<p>110</p>
<p>所以3 5 6 的最长相同前缀为 100</p>
<p>我们得到了这个前缀 对于这个前缀我们不关心有几个0 </p>
<p>因为可以通过左移右移得到 </p>
<p>我们需要操作将所有数的二进制删去多余的1调整0的个数</p>
<p>获得与最长前缀相同的值 (即最后所有数都相等)</p>
<p>所以在得到最长相同前缀后 逐个枚举</p>
<p>num=001 ，010，100</p>
<p>统计所有数变为num需要的操作次数更新答案</p>
<p>其他方法</p>
<p>将所有数a[i]通过 ×2 or /2得到的数所需要的操作次数num[x]统计出来</p>
<p>即num[a[i]×2]=num[a[i]]+1 或num[a[i]/2]=num[a[i]]+1</p>
<p>num[a[i]×4]=num[a[i]×2]+1 ….</p>
<p>同时记录有多少个数ai可以通过操作变为x记为cnt[x]</p>
<p>然后枚举最后数组所有数的最终值 x</p>
<p>若cnt[x]==n 则可能通过操作得到 更新答案</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> ndata[Max],data[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">int</span>  maxn=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;data[i];ndata[i]=data[i];</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;maxn&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(maxn)&#123;</span><br><span class="line">        maxn&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	maxn=<span class="number">1</span>&lt;&lt;(cnt<span class="number">-1</span>);</span><br><span class="line">	<span class="comment">//cout&lt;&lt;maxn&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ndata[i]&lt;maxn)ndata[i]&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//if(ndata[i]&gt;maxn)ndata[i]&gt;&gt;=1;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> temp=ndata[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)temp&amp;=ndata[i];</span><br><span class="line">	maxn=temp;</span><br><span class="line">	<span class="keyword">while</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp&amp;<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">        temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">1e9</span>,fn=<span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;maxn&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">//for(int i=0;i&lt;ndata[i];i++)cout&lt;&lt;ndata[i]&lt;&lt;" ";</span></span><br><span class="line">	<span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> bios=<span class="number">0</span>;(temp&lt;&lt;bios)&lt;=maxn;bios++)&#123;</span><br><span class="line">        <span class="keyword">int</span> need=<span class="number">0</span>,num=temp&lt;&lt;bios;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> now=data[i];</span><br><span class="line">            <span class="keyword">int</span> diff=ndata[i]^maxn;</span><br><span class="line">            <span class="keyword">if</span>(diff)&#123;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;diff&lt;&lt;" ";</span></span><br><span class="line">                <span class="keyword">int</span> biosnow=ndata[i];</span><br><span class="line">                <span class="keyword">while</span>(now&gt;biosnow)biosnow&lt;&lt;=<span class="number">1</span>,diff&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(now&lt;biosnow)biosnow&gt;&gt;=<span class="number">1</span>,diff&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(diff)&#123;</span><br><span class="line">                    now&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                    diff&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                    need++;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;diff&lt;&lt;endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;now&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(now&gt;num)&#123;</span><br><span class="line">                now&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                need++;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;now&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;(temp&lt;&lt;bios)&lt;&lt;" "&lt;&lt;i&lt;&lt;" "&lt;&lt;now&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">while</span>(now&lt;num)&#123;</span><br><span class="line">                now&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                need++;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;now&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,need);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;fn&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#369-D</title>
    <url>/2020/09/02/codeforces-369-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/711/D" target="_blank" rel="noopener">D. Directed Roads</a> </p>
<p>题意</p>
<p>给出n个点n条边的有向图(n&lt;1e5)</p>
<p>求出有多少种边集 使得反转集合种边的方向后 图中无环</p>
<p>题解</p>
<img src="/.io//timg.gif" data-original="example.png">

<p>上图举例了一个n个点n条边的有向图</p>
<p>容易发现要通过反转某些边获得无环图 需要从每一个环中取出至少一个边反转</p>
<p>所以选择的边集中必须包含各个环中的至少一条边</p>
<p>对于一个环i 需要反转的边集有$C_{loopsize[i]}^1+C_{loopsize[i]}^2+…..C_{loopsize[i]}^{loopsize[i]-1}$ 种</p>
<p>已知$∑_{i=0}^nC_n^i=2^n$  所以对于一个环i需要反转的边集有$2^{loopsize[i]}-2$种</p>
<p>通过组合数学的知识对于m个环则有</p>
<p>$(2^{loopsize[1]}-2) (2^{loopsize[2]}-2)…. (2^{loopsize[m]}-2)$ 种边集</p>
<p>对于非环中的边 无论它如何改变方向都不会产生新的环所以 被选中要反转的边中</p>
<p>可以有0条,1条…. $n-∑loopsize[i]$ 条非环边 </p>
<p>所以答案的方案数为$(2^{loopsize[1]}-2) (2^{loopsize[2]}-2)…. (2^{loopsize[m]}-2) (2^{n-∑loopsize[i]})$ </p>
<p>对于非环边 我们可以通过拓扑排序中删去入度为0的边 的过程来统计</p>
<p>而对于每个环的大小 </p>
<p>在这个题目中不会有环套环的情况因为n个点n条边每个点一个出边只会出现简单环</p>
<p>所以用简单dfs统计每个环的大小即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max];</span><br><span class="line"><span class="keyword">int</span> in[Max],out[Max],sz[Max];</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Topu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!in[i])q.push(i),cnt++,vis[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[pos])&#123;</span><br><span class="line">            in[i]--;</span><br><span class="line">            <span class="keyword">if</span>(!in[i])&#123;</span><br><span class="line">                cnt++;vis[i]=<span class="number">1</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    sz[now]=<span class="number">1</span>;vis[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">        dfs(i);</span><br><span class="line">        sz[now]+=sz[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=(ans*x)%mod;</span><br><span class="line">        x=(x*x)%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v;<span class="built_in">cin</span>&gt;&gt;v;</span><br><span class="line">        mp[i].push_back(v);</span><br><span class="line">        in[v]++;</span><br><span class="line">        out[i]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> outloop=Topu(n);</span><br><span class="line">	ll ans=qpow(<span class="number">2</span>,outloop);</span><br><span class="line">	<span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">        dfs(i);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;sz[i]&lt;&lt;endl;</span></span><br><span class="line">        ans=(ans*(qpow(<span class="number">2</span>,sz[i])<span class="number">-2</span>+mod)%mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>组合数学</tag>
        <tag>拓扑排序</tag>
        <tag>dfs &amp; bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#528-D</title>
    <url>/2020/10/30/codeforces-528-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1087/D" target="_blank" rel="noopener">D. Minimum Diameter Tree</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一颗n个点n-1条边的树</p>
<p>现在已知它的边权和=s</p>
<p>要求重新给这些边分配边权(非负数)</p>
<p>求分配后所能得到最小的树的直径</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>首先注意到无论怎么分配边权</p>
<p>树的直径一定是从一个叶子结点到另一个叶子结点</p>
<p>所以最终求得的树的直径也一定从某两个叶子结点的简单路径中产生</p>
<p>因为树的直径是树中最长路 我们要让最长路最短 </p>
<p>那么就需要将边权和平均分配到所有叶子结点直接连接的那条边上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">ll num[Max];</span><br><span class="line">ll leaves[Max],sz[Max],maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    sz[now]=num[now];</span><br><span class="line">    <span class="keyword">if</span>(mp[now].empty())leaves[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> to:mp[now])&#123;</span><br><span class="line">        dfs(to);</span><br><span class="line">        sz[now]+=sz[to];</span><br><span class="line">        leaves[now]+=leaves[to];</span><br><span class="line">    &#125;</span><br><span class="line">    ll di=sz[now]%leaves[now]?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;sz[now]&lt;&lt;" "&lt;&lt;leaves[now]&lt;&lt;endl;</span></span><br><span class="line">    maxn=<span class="built_in">max</span>(maxn,sz[now]/leaves[now]+di);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v=i;<span class="built_in">cin</span>&gt;&gt;u;</span><br><span class="line">        mp[u].push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>性质发现</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#428-D</title>
    <url>/2020/07/08/codeforces-428-D/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/839/problem/D" target="_blank" rel="noopener">D. Winter is here</a></p>
<p>题意</p>
<p>有一个序列a，对于某些k 称序列i1, i2, …, ik 是无趣的当且仅当i1 &lt; i2 &lt; i3 &lt; … &lt; ik </p>
<p>并且 gcd(ai1, ai2, …, aik) &gt; 1 . 并且它的无趣值为k · gcd(ai1, a i2, …, aik) . 求所有存在的无趣序列的无趣值之和，对1e9+7取模</p>
<p>给出一个长度为n n&lt;1e5 的序列a ai&lt;1e6<br>找出长度为k且gcd(ai1,ai2,ai3…..aik)&gt;1 的子序列<br>求∑k*gcd </p>
<p>题解<br>枚举gcd 那么由此gcd能构成的子序列 应该是由 gcd ，2gcd，3gcd….即gcd的倍数构成的<br>那么读入时统计各个数的个数 num[x]++<br>所以对于枚举到的某个gcd 它对应的子序列 是由a中出现的它的所有倍数选出1个，2个… x个<br>(假设最多x个)形成<br>同时以gcd为最大公约数的子序列对应的长度k可以是1,2,3,4,5…x;</p>
<p>∑k=∑len *C(x,len) ,(len=1,2,3,,,,x) = x * 2^ {x-1}</p>
<p>/* 常用组合数结论 */<br>那么以gcd为最大公约数的子序列对答案产生的贡献可以直接计算得到<br>此外还要考虑gcd=4 和gcd=2 被重复计算的情况 比如{4,8,12}的gcd=4但枚举到gcd=2时也会被计入 因此考虑容斥 对于gcd=2的子序列个数要减去gcd=4,6,8,10….2x<br>所以我们选择从大到小枚举gcd 同时维护一个dp数组记录以i为gcd的子序列对应的∑k</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"># include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line"># define endl <span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll <span class="keyword">mod</span>=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll num[(int)<span class="number">1e6</span>+<span class="number">5</span>];</span><br><span class="line">ll dp[(int)<span class="number">1e6</span>+<span class="number">6</span>];</span><br><span class="line">ll qpow(ll <span class="symbol">x</span>,ll <span class="symbol">y</span>)&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="symbol">y</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="symbol">y</span>&amp;<span class="number">1</span>)ans=(ans*<span class="symbol">x</span>)%<span class="keyword">mod</span>;</span><br><span class="line">        <span class="symbol">y</span>&gt;&gt;=<span class="number">1</span>;<span class="symbol">x</span>=(<span class="symbol">x</span>*<span class="symbol">x</span>)%<span class="keyword">mod</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    ll maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ll <span class="symbol">x</span>;cin&gt;&gt;<span class="symbol">x</span>;</span><br><span class="line">        num[<span class="symbol">x</span>]++;</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,<span class="symbol">x</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=maxn;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        ll <span class="symbol">x</span>=<span class="number">0</span>,sum=num[i];</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">2</span>*i;j&lt;=maxn;j+=i)&#123;</span><br><span class="line">            <span class="symbol">x</span>=(<span class="symbol">x</span>+dp[j])%<span class="keyword">mod</span>;</span><br><span class="line">            sum=(sum+num[j])%<span class="keyword">mod</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;j;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!sum)<span class="keyword">continue</span>;</span><br><span class="line">        dp[i]=(<span class="keyword">mod</span>+(sum%<span class="keyword">mod</span>*qpow(<span class="number">2</span>,sum<span class="number">-1</span>)%<span class="keyword">mod</span>)%<span class="keyword">mod</span>-<span class="symbol">x</span>)%<span class="keyword">mod</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;i;</span></span><br><span class="line">        ans=(ans+(i*dp[i])%<span class="keyword">mod</span>)%<span class="keyword">mod</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>gcd</tag>
        <tag>容斥原理</tag>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#538-C</title>
    <url>/2020/07/08/codeforces-538-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1114/problem/C" target="_blank" rel="noopener">C. Trailing Loves (or L’oeufs?)</a> </p>
<p>题意<br>求n!在b进制下末尾连续0的长度 </p>
<p>题解</p>
<p>要求 n! 在 b 进制下有多少个尾 0 就相当于 求 n! % (b^k) == 0 的最大 k。<br>那么我们现在把 n! 看作一个数 A。问题就是 求 A % (b^k) == 0 的最大 k;<br>我们知道有素数分解定理： b = p1^a1 * p2^a2 * p3^a3 …；<br>那么我们如果可以求得 A 里面 p1^b1 * p2^b2 * p3^b3 …  的 b1, b2, b3…<br>那么答案 ans = min(ans, ai/bi ) 了也就是要整除，首先要满足最小的那个能整除</p>
<p>(1)首先对 b 进行素因子分解，直接暴力（log b）, 用一个数组离散化形成该素因子的编号和该素因子的幂的映射 或者 用map存储该素因子的幂，得到所有素因子以及素因子的幂<br>(2)对于每一个素因子p，计算对应的 A（即 n! ) 中素因子p的幂，两者相除取所有p幂的最小值就是对应的最大整数。</p>
<p>问题在于如何快速求得n!即A的所有素因子个数<br>这里求 n! 下 素因子 p 的幂 用累除法，因为存在推论：<br>n！ 下 p 的幂 = [ n/p ] + [ n/(p^2) ] + [ n/(p^3) ]  …</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> <span class="built_in">vector</span>&lt;ll&gt;prime;</span><br><span class="line"> <span class="built_in">map</span>&lt;ll,<span class="keyword">int</span>&gt;powcnt;</span><br><span class="line"><span class="comment">///一个数的素因子及其幂的logn求法</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">getprime</span><span class="params">(ll num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>)&#123;</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">            <span class="keyword">while</span>(num%i==<span class="number">0</span>)&#123;</span><br><span class="line">                num/=i;</span><br><span class="line">                powcnt[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num!=<span class="number">1</span>)&#123;</span><br><span class="line">        prime.push_back(num);</span><br><span class="line">        powcnt[num]++;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">///求n!中某一素因子的幂</span></span><br><span class="line"> <span class="function">ll <span class="title">func</span><span class="params">(ll p,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        ans+=n/p;</span><br><span class="line">        n/=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,b;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;b;</span><br><span class="line">    getprime(b);</span><br><span class="line">    ll ans=(ll)<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">int</span> len=prime.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,func(prime[i],n)/powcnt[prime[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>素因子分解</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#615-C</title>
    <url>/2020/07/08/codeforces-615-C/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1294/problem/C" target="_blank" rel="noopener">C. Product of Three Numbers</a></p>
<p>题意<br>给出一个数n问是否能将他拆成三个不同数的乘积 n小于1e9</p>
<p>由唯一分解定理得</p>
<p>a=(p1 ^ k1) × (p2 ^ k2) × (p3 ^ k3)…..</p>
<p>sqrt(n)内枚举可能的素因子 第三个数可有n/(p1*p2)得 若能得到三个因子且都不等于1那么有解</p>
<p>map容器的first是键值 second是映射值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="comment">#define IO std::ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="comment">#define endl '\n'</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    int t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        int n;cin&gt;&gt;n;</span><br><span class="line">        map&lt;int,int&gt;ans;</span><br><span class="line">        <span class="keyword">for</span>(int i=2;i*i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i)<span class="built_in">continue</span>;</span><br><span class="line">            ans[i]=1;n/=i;///得到的i一定是n的素因子</span><br><span class="line">            <span class="keyword">if</span>(ans.size()==2)<span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //<span class="keyword">if</span>(n!=1)ans[n]=1;</span><br><span class="line">        <span class="keyword">if</span>(n!=1)ans[n]=1;</span><br><span class="line">        <span class="keyword">if</span>(ans.size()&lt;3)cout&lt;&lt;<span class="string">"NO"</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">"YES"</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">for</span>(auto i: ans)cout&lt;&lt;i.first&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>唯一分解定理</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#597-D</title>
    <url>/2020/07/10/codeforces-597-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1245/problem/D" target="_blank" rel="noopener">D. Shichikuji and Power Grid</a> </p>
<p>题意</p>
<p>给定 n 个点，在某个点上建立一个基站要花费ci，连接两点要花费(|xi−xj|+|yi−yj|)∗(ki+kj)。<br>对于一个点要么建立基站，要么连接建立基站的点。问最小代价是多少，同时输出建立基站的点和线路。</p>
<p>题解</p>
<p>建立一个超级根，对于每个城市建立发电站，连接一条权值为ci的边再把每个城市之间连接电线的花费算出来<br>跑最小生成树 kruskal</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2005</span>;</span><br><span class="line">ll x[maxn],y[maxn],cont=<span class="number">0</span>;</span><br><span class="line">ll costA[maxn],costB[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; station,<span class="built_in">connect</span>[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ll st,to;</span><br><span class="line">    ll val;</span><br><span class="line">&#125;G[maxn*maxn];</span><br><span class="line"><span class="keyword">int</span> root[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">found</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root[x]!=x)root[x]=found(root[x]);</span><br><span class="line">    <span class="keyword">return</span> root[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)root[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> u=G[i].st;</span><br><span class="line">         <span class="keyword">int</span> v=G[i].to;</span><br><span class="line">         <span class="comment">///cout&lt;&lt;u&lt;&lt;" "&lt;&lt;found(u)&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;found(v)&lt;&lt;endl;</span></span><br><span class="line">         <span class="keyword">if</span>(found(u)!=found(v))&#123;</span><br><span class="line">             root[found(u)]=root[found(v)];</span><br><span class="line">             sum+=G[i].val;</span><br><span class="line">             <span class="keyword">if</span>(G[i].st==<span class="number">0</span>)station.push_back(G[i].to);</span><br><span class="line">             <span class="keyword">else</span> <span class="built_in">connect</span>[G[i].st].push_back(G[i].to),cont++;</span><br><span class="line">             <span class="comment">///cout&lt;&lt;G[i].st&lt;&lt;" "&lt;&lt;G[i].to&lt;&lt;" "&lt;&lt;G[i].val&lt;&lt;endl;</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span>&#123;<span class="keyword">return</span> a.val&lt;b.val;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,cnt=<span class="number">0</span>;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)root[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;costA[i];</span><br><span class="line">        G[cnt].st=<span class="number">0</span>;</span><br><span class="line">        G[cnt].to=i;</span><br><span class="line">        G[cnt].val=costA[i];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;costB[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)<span class="keyword">continue</span>;</span><br><span class="line">            G[cnt].st=i;</span><br><span class="line">            G[cnt].to=j;</span><br><span class="line">            G[cnt].val=(<span class="built_in">abs</span>(x[i]-x[j])+<span class="built_in">abs</span>(y[i]-y[j]))*(costB[i]+costB[j]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(G,G+cnt,cmp);</span><br><span class="line">    ll ans=kruskal(cnt);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;station.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> lenth=station.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenth;i++)<span class="built_in">cout</span>&lt;&lt;station[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;cont&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">connect</span>[i].empty())<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> len=<span class="built_in">connect</span>[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="built_in">connect</span>[i][j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>超源点</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#615-D</title>
    <url>/2020/07/08/codeforces-615-D/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1294/problem/D" target="_blank" rel="noopener">D. MEX maximizing</a></p>
<p>题意<br>给出一个空的数组<br>每次向里加入一个数yi共加入q次(q&lt;4e5)<br>你可以通过向数组中任意数字+x或-x任意次使得该数列中的MEX的值尽可能的大<br>每次加入一个数后询问该数组的mex<br>对于数组[0,0,1,0,2]，MEX = 3，因为数字0、1和2在数组中表示，而3是数组中未表示的最小非负整数;</p>
<p>题解</p>
<p>不难发现+x -x的性质实际上让新加入的数yi等效转化成加入一个yi%x，统计cnt[yi%x]++;<br>那么对于这个数组的MEX实际就是求得从0到x-1中cnt[i]最少的数 那么MEX=最少的这个数i+x*cnt[i]<br>此处用线段树维护0到x-1内cnt[i]的最小值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="comment">#define IO std::ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="comment">#define endl '\n'</span></span><br><span class="line">const int maxn=(int)4e5+5;</span><br><span class="line">int num[(int)4e5+5];</span><br><span class="line">struct Tree&#123;</span><br><span class="line">    int L,R;</span><br><span class="line">    int minn;</span><br><span class="line">    int minn_num;</span><br><span class="line">&#125;tree[maxn&lt;&lt;2];</span><br><span class="line">inline void push_up(int i)&#123;</span><br><span class="line">    tree[i].minn=min(tree[i&lt;&lt;1].minn,tree[i&lt;&lt;1|1].minn);</span><br><span class="line">    <span class="keyword">if</span>(tree[i&lt;&lt;1].minn==tree[i&lt;&lt;1|1].minn)&#123;</span><br><span class="line">        tree[i].minn_num=min(tree[i&lt;&lt;1].minn_num,tree[i&lt;&lt;1|1].minn_num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree[i].minn==tree[i&lt;&lt;1].minn)&#123;</span><br><span class="line">        tree[i].minn_num=tree[i&lt;&lt;1].minn_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tree[i].minn_num=tree[i&lt;&lt;1|1].minn_num;</span><br><span class="line">    <span class="built_in">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">void build(int L,int R,int i)&#123;</span><br><span class="line">    tree[i].L=L;tree[i].R=R;</span><br><span class="line">    <span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">        tree[i].minn=0;</span><br><span class="line">        tree[i].minn_num=L;</span><br><span class="line">        <span class="built_in">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid=(L+R)&gt;&gt;1;</span><br><span class="line">    build(L,mid,i&lt;&lt;1);</span><br><span class="line">    build(mid+1,R,i&lt;&lt;1|1);</span><br><span class="line">    push_up(i);</span><br><span class="line">    <span class="built_in">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">void updata(int dis,int i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].L==tree[i].R)&#123;</span><br><span class="line">        tree[i].minn++;</span><br><span class="line">        ///cout&lt;&lt;tree[i].minn_num&lt;&lt;<span class="string">" "</span>&lt;&lt;tree[i].minn&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis&lt;=tree[i&lt;&lt;1].R)updata(dis,i&lt;&lt;1);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dis&gt;=tree[i&lt;&lt;1|1].L)updata(dis,i&lt;&lt;1|1);</span><br><span class="line">    push_up(i);<span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    int q,x;cin&gt;&gt;q&gt;&gt;x;</span><br><span class="line">    build(0,x-1,1);</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;q;i++)&#123;</span><br><span class="line">        int c;cin&gt;&gt;c;</span><br><span class="line">        num[c%x]++;</span><br><span class="line">        updata(c%x,1);</span><br><span class="line">        int ans=tree[1].minn_num;</span><br><span class="line">        //cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;ans+x*num[ans]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但可以用更简单的方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int now=0;</span><br><span class="line"><span class="keyword">for</span>(int i=0;i&lt;q;i++)&#123;</span><br><span class="line">    int c;cin&gt;&gt;c;</span><br><span class="line">    cnt[c%x]++;</span><br><span class="line">    <span class="keyword">while</span>(cnt[now%x])&#123;</span><br><span class="line">        cnt[now%x]--</span><br><span class="line">	now++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;now&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构</tag>
        <tag>MEX</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#621-D</title>
    <url>/2020/07/08/codeforces-621-D/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1307/problem/D" target="_blank" rel="noopener">D. Cow and Fields</a> </p>
<p>题意<br>有n个点 m条边 k个特殊点<br>现在给出k个特殊点下标<br>和已有的m条边<br>问在k个特殊点中选两个点建一条边<br>使得1到n的最短路最大</p>
<p>题解<br>对于两个特殊点 x y<br>如果在这两点之间建立一条边那么经过这两点的最短路长为<br>min(1-&gt;x+y-&gt;n , 1-&gt;y+x-&gt;n)中产生<br>假设(1-&gt;x+y-&gt;n) &lt; (1-&gt;y+x-&gt;n) 为了使最短路更长<br>我们选择更大的 (1-&gt;x+y-&gt;n) 同时又要满足(1-&gt;x+y-&gt;n) &lt; (1-&gt;y+x-&gt;n)<br>所以将(1-&gt;x+y-&gt;n) &lt; (1-&gt;y+x-&gt;n)转化为(1-&gt;x - x-&gt;n) &lt;(1-&gt;y- y-&gt;n)<br>此时选择两个特殊点 x y 时只要满足 (1-&gt;x - x-&gt;n) &lt;(1-&gt;y- y-&gt;n)<br>那么 (1-&gt;x+y-&gt;n)  将有可能成为最长的最短路<br>所以根据(1-&gt;x - x-&gt;n) &lt;(1-&gt;y- y-&gt;n) 将特殊点排序<br>现在要想 (1-&gt;x+y-&gt;n) 尽量大 在满足(1-&gt;x - x-&gt;n) &lt;(1-&gt;y- y-&gt;n) 的前提条件下 更新排序后前i个特殊点1-&gt; i的最大值 maxp + i-&gt;y的距离+1 就是加边后最长最短路<br>注意最长的最短路不会比原有1-&gt;n的路径长</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> special[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">4</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;<span class="built_in">point</span>[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">3</span>][(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    dis[type][pos]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;q.push(pos);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:<span class="built_in">point</span>[now])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[type][i]==maxn)&#123;</span><br><span class="line">                dis[type][i]=dis[type][now]+<span class="number">1</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)dis[<span class="number">1</span>][i]=maxn,dis[<span class="number">0</span>][i]=maxn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)<span class="built_in">cin</span>&gt;&gt;special[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">point</span>[x].push_back(y);</span><br><span class="line">        <span class="built_in">point</span>[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    bfs(<span class="number">1</span>,<span class="number">0</span>);bfs(n,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;sp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        sp.push_back(&#123;dis[<span class="number">0</span>][special[i]]-dis[<span class="number">1</span>][special[i]],special[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(sp.<span class="built_in">begin</span>(),sp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,maxp=-maxn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:sp)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=i.second;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,maxp+dis[<span class="number">1</span>][pos]);</span><br><span class="line">        maxp=<span class="built_in">max</span>(maxp,dis[<span class="number">0</span>][pos]);</span><br><span class="line">        <span class="comment">///此处更新可能会出现在一个特殊点上建环即ans=dis[0][pos] +dis[1][pos] 最后默认作为两点间建边多+1导致超过原先最短路</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">min</span>(ans+<span class="number">1</span>,dis[<span class="number">0</span>][n])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dfs &amp; bfs</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#642-E</title>
    <url>/2020/07/17/codeforces-642-E/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1353/problem/E" target="_blank" rel="noopener">E. K-periodic Garland</a> </p>
<p>题意 </p>
<p>给出一个01串长为n&lt;1e6</p>
<p>要求将它改为1的间隔=k的01串</p>
<p>比如k=3则</p>
<p>“00010010”,”1001001”,”00010”,”0000” 都合法</p>
<p>每次操作只改变一个位置的0/1状态</p>
<p>问最小操作次数</p>
<p>题解</p>
<p>设计dp[i][0] 表示第i位是第一个1</p>
<p>dp[i][1] 表示第i为不是第一个1</p>
<p>同时维护前缀pre[i]表示到第i位有几个1</p>
<p>那么可以得到转移方程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="keyword">int</span> last;</span><br><span class="line">    <span class="keyword">if</span>(i-k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    	last=<span class="built_in">min</span>(dp[i-k][<span class="number">0</span>],dp[i-k][<span class="number">1</span>]);<span class="comment">///到第i-k位合法的最小操作</span></span><br><span class="line">        dp[i][<span class="number">1</span>]=last+pre[i<span class="number">-1</span>]-pre[i-k]+(arr[i<span class="number">-1</span>]==<span class="string">'0'</span>);</span><br><span class="line">        <span class="comment">///dp[i][1]是由dp[i-k][1]+中间全变0,第位变1的操作次数</span></span><br><span class="line">        <span class="comment">///或dp[i-k][0]+中间全变0,第位变1的操作次数或者说退化成dp[i][0]含义</span></span><br><span class="line">        <span class="comment">///两者中取min</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="built_in">min</span>(dp[i][<span class="number">1</span>],dp[i][<span class="number">0</span>])+(pre[n]-pre[i]));</span><br><span class="line">    <span class="comment">///ans是到第i位合法的最小操作次数+后缀全为0的操作次数取min</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pre[Max];</span><br><span class="line"><span class="keyword">int</span> dp[Max][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="built_in">string</span> arr;<span class="built_in">cin</span>&gt;&gt;arr;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            pre[i]=pre[i<span class="number">-1</span>]+(arr[i<span class="number">-1</span>]==<span class="string">'1'</span>);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Max;</span><br><span class="line">            dp[i][<span class="number">0</span>]=pre[i<span class="number">-1</span>]+(arr[i<span class="number">-1</span>]==<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(pre[i]&gt;<span class="number">0</span>)flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=Max;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> last;</span><br><span class="line">            <span class="keyword">if</span>(i-k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                last=<span class="built_in">min</span>(dp[i-k][<span class="number">0</span>],dp[i-k][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>]=last+pre[i<span class="number">-1</span>]-pre[i-k]+(arr[i<span class="number">-1</span>]==<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,<span class="built_in">min</span>(dp[i][<span class="number">1</span>],dp[i][<span class="number">0</span>])+(pre[n]-pre[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/streamazure/p/12896935.html" target="_blank" rel="noopener">其他dp设计方案</a></p>
<p>dp[i][0/1]表示到第i位合法时第i位是0还是1</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#642-F</title>
    <url>/2020/07/22/codeforces-642-F/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1353/problem/F" target="_blank" rel="noopener">F. Decreasing Heights</a></p>
<p>题意<br>给出一个n*m的矩阵 n,m&lt;100</p>
<p>每个位置的值表示高度</p>
<p>现在从(1,1)走到(n,m);</p>
<p>只能走(i+1,j) or (i,j+1) 且当前所在位置的高度=要走到位置的高度-1</p>
<p>在出发前可以任意个位置-1高度 视为1次操作</p>
<p>问能使两点通路的最小操作</p>
<p>题解</p>
<p>按照题目要求</p>
<p>形成通路的前提条件是 存在一条路径</p>
<p>b0,b1,b2….bn+m-2  为了符合 b[i]+1=b[i+1]</p>
<p>那么这相当于第i个点 要比初始位置高出i的高度</p>
<p>所以原路径上所有的高度b[i]都可以转化成b[i]-i 变为可调整的高度</p>
<p>(对于每个点b[i]不可变化的高度是i)</p>
<p>则限制条件b[i]+1=b[i+1]变为b[i]=b[i+1] </p>
<p>那么对于b0,b1,b2….bn+m-2  这条路径需要修改的次数为</p>
<p>转化后求$∑b[i]-min(b[0,1,2,…,n+m-2])$;</p>
<p>取min操作是将路径中的最低点作为基准点</p>
<p>所以枚举路径中可能的最低值low On^2</p>
<p>再On^2 dp转移 整体On^4</p>
<p><a href="https://www.cnblogs.com/DeepJay/p/12895385.html" target="_blank" rel="noopener">参考博客</a></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line">ll data[Max][Max];</span><br><span class="line">ll dp[Max][Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;data[i][j];</span><br><span class="line">                data[i][j]-=(i+j<span class="number">-2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=<span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                ll low=data[i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;=n;r++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>;c&lt;=m;c++)dp[r][c]=<span class="number">1e18</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;=n;r++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>;c&lt;=m;c++)&#123;</span><br><span class="line">                        <span class="comment">//cout&lt;&lt;data[r][c]&lt;&lt;" "&lt;&lt;low&lt;&lt;endl;</span></span><br><span class="line">                        ll de=data[r][c]&gt;=low?data[r][c]-low:<span class="number">1e18</span>;</span><br><span class="line">                        <span class="keyword">if</span>(r==<span class="number">1</span>&amp;&amp;c==<span class="number">1</span>)dp[r][c]=<span class="built_in">min</span>(dp[r][c],de);</span><br><span class="line">                        <span class="keyword">if</span>(r&gt;<span class="number">1</span>)dp[r][c]=<span class="built_in">min</span>(dp[r][c],dp[r<span class="number">-1</span>][c]+de);</span><br><span class="line">                        <span class="keyword">if</span>(c&gt;<span class="number">1</span>)dp[r][c]=<span class="built_in">min</span>(dp[r][c],dp[r][c<span class="number">-1</span>]+de);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,dp[n][m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#649-D</title>
    <url>/2020/07/08/codeforces-649-D/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1364/problem/D" target="_blank" rel="noopener">D. Ehab’s Last Corollary</a></p>
<p>题意<br>给出一个n个点m条边的图</p>
<p>1.找出ceil(k/2)个点它们中没有两个被同一条边连着</p>
<p>2.或者找出一个不超过k个点的环</p>
<p>题解</p>
<p>找图中的最小环</p>
<p>若最小环长度r&lt;=k输出环</p>
<p>否则间隔的输出环上的点 因为r&gt;k 所以ceil(r/2)&gt;=ceil(k/2)一定能满足条件</p>
<p>若不存在环 则图为树 没有返祖边</p>
<p>直接黑白染色 输出其中一个集合中的点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;ll,ll&gt; P;</span><br><span class="line"><span class="comment">#define endl '\n'</span></span><br><span class="line"><span class="comment">#define Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line">const int mod=2e3;</span><br><span class="line">const int Max=2e5+5;</span><br><span class="line">vector&lt;int&gt;mp[Max];</span><br><span class="line">int color[Max],pa[Max],dfn[Max];</span><br><span class="line">bool flag;</span><br><span class="line">int n,m,k,minlen,pos;</span><br><span class="line">/*</span><br><span class="line">void dfs_color(int now,int per,int cl)&#123;</span><br><span class="line">    color[now]=cl;</span><br><span class="line">    <span class="keyword">for</span>(auto i:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])dfs_color(i,now,3-cl);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[i]+color[now]!=3)&#123;</span><br><span class="line">            flag=0;</span><br><span class="line">            <span class="built_in">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">///黑白染色dfs</span><br><span class="line">void dfs_color(int now,int per)&#123;</span><br><span class="line">    <span class="keyword">for</span>(auto i:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==per)<span class="built_in">continue</span>;</span><br><span class="line">        int temp=3-color[now];</span><br><span class="line">        //cout&lt;&lt;now&lt;&lt;<span class="string">" "</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])&#123;</span><br><span class="line">            color[i]=temp;</span><br><span class="line">            dfs_color(i,now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[i]+color[now]!=3)&#123;</span><br><span class="line">            flag=0;</span><br><span class="line">            <span class="built_in">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//找最小环dfs</span><br><span class="line">void dfs_dfn(int now,int per)&#123;</span><br><span class="line">    pa[now]=per;</span><br><span class="line">    ///额外记录一个指向父节点的数组用于路径还原</span><br><span class="line">    ///因为dfn被标记过一次的点不会再被深搜 所以pa[]的值是唯一对应的</span><br><span class="line">    <span class="keyword">for</span>(auto i:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==per)<span class="built_in">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfn[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfn[now]-dfn[i]&gt;0&amp;&amp;dfn[now]-dfn[i]+1&lt;minlen)&#123;</span><br><span class="line">                minlen=dfn[now]-dfn[i]+1;</span><br><span class="line">                pos=now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dfn[i]=dfn[now]+1;</span><br><span class="line">            dfs_dfn(i,now);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)color[i]=0,dfn[i]=0,pa[i]=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        int u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        mp[u].push_back(v);</span><br><span class="line">        mp[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    color[1]=1,minlen=n+1;</span><br><span class="line">    dfn[1]=1,dfs_dfn(1,0);</span><br><span class="line">    int need=(k+1)&gt;&gt;1;</span><br><span class="line">    <span class="keyword">if</span>(minlen!=n+1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(minlen&lt;=k)&#123;</span><br><span class="line">            cout&lt;&lt;2&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;minlen&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">while</span>(minlen--)&#123;</span><br><span class="line">                cout&lt;&lt;pos&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                pos=pa[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;1&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">while</span>(need--)&#123;</span><br><span class="line">                cout&lt;&lt;pos&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                pos=pa[pos];</span><br><span class="line">                pos=pa[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dfs_color(1,0);int cnt=0;</span><br><span class="line">        cout&lt;&lt;1&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(int i=1;i&lt;=n;i++)<span class="keyword">if</span>(color[i]==1)cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=need)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int i=1;i&lt;=n&amp;&amp;need;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(color[i]==1)&#123;</span><br><span class="line">                    need--;</span><br><span class="line">                    cout&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i=1;i&lt;=n&amp;&amp;need;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(color[i]==2)&#123;</span><br><span class="line">                    cout&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                    need--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dfs &amp; bfs</tag>
        <tag>最小环</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#650-F1</title>
    <url>/2020/07/11/codeforces-650-F1/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1367/problem/F1" target="_blank" rel="noopener">F1. Flying Sort (Easy Version)</a></p>
<p>题意<br>给出n个不重复的数 要求进行以下两种操作使得数组升序<br>1 将某位置的数移动到队列最前方<br>2 将某位置的数移动到队列最后方<br>问最小操作次数</p>
<p>题解<br>由于n个数互不相同离散化之后题目变为cf 606C<br>离散化技巧见代码<br>再贪心找最长连续上升子序列 设长为len<br>注意不是单纯的最长上升子序列是 最长的连续上升子序列(非子串)<br>连续的意思为这个上升子序列里相邻元素是连续的即差为1<br>答案为n-len<br>/*</p>
<p>cf 606C 题意<br>一个无限长的铁路有一个载着n辆车的火车，每一辆车的编号从1到n。每一辆车的编号都是不同的。他们的顺序是无序的。<br>David Blaine想要将这些车按照他们的编号从小到大排序，他可以做两种操作。第一种，他可以将一辆车从任意位置移动到所有车的第一位。第二种，他可以将一辆车从任意位置移动到所有车的最后一位。<br>不过他很懒，所以他想知道将这些车排好序最少做几次操作就可以。      </p>
<p>*/</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> arr[Max],len[Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;data;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> lower_bound(data.<span class="built_in">begin</span>(),data.<span class="built_in">end</span>(),x)-data.<span class="built_in">begin</span>()+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="comment">//bool cmp(Data x,Data y)&#123;return x.val&lt;y.val;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        data.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i];len[i]=<span class="number">0</span>;</span><br><span class="line">            data.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(data.<span class="built_in">begin</span>(),data.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=getid(arr[i]);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;pos&lt;&lt;endl;</span></span><br><span class="line">            len[pos]=len[pos<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;pos&lt;&lt;" "&lt;&lt;len[pos]&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(len[pos]&gt;maxn)maxn=len[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n-maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#650-E</title>
    <url>/2020/07/11/codeforces-650-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1367/problem/E" target="_blank" rel="noopener">E. Necklace Assembly</a></p>
<p>题意<br>给出 n个珠子(n小于2000) 珠子有26个品种用小写字母表示<br>现在要求取出尽量多的珠子串成项链 要求这串项链在顺时针旋转k个单位(一个珠子一个单位)时<br>每个位置的珠子种类仍和原来相同<br>问最长拿出多少个珠子使得它符合这种要求</p>
<p>题解<br>发现n较小 于是枚举答案 判断正确性<br>通过举例发现 当枚举到需要i个珠子时<br>要构成旋转k个单位仍不变的项链<br>一定是每两个相同种类珠子间隔x=gcd(i,k)个</p>
<p>可以延伸到其他与圆 周期性相关的题 可以考虑gcd</p>
<p>于是就能够计算出需要多少个相同种类的珠子来构成当前长度的项链</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> have[<span class="number">30</span>];</span><br><span class="line"><span class="comment">//bool cmp(Data x,Data y)&#123;return x.val&lt;y.val;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="built_in">string</span> s;<span class="built_in">cin</span>&gt;&gt;s;<span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(have,<span class="number">0</span>,<span class="keyword">sizeof</span> have);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)have[i-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line">            <span class="keyword">int</span> bios=__gcd(len,k);<span class="comment">///每两个相同种类的珠子间隔数=最后需要种类个数</span></span><br><span class="line">            <span class="keyword">int</span> need=(len/bios),cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                cnt+=have[i]/need;</span><br><span class="line">	<span class="comment">///每种珠子需要need个若某种珠子总数可以提供多个need</span></span><br><span class="line">            	<span class="comment">///若这种颜色的珠子能提供多组need个珠子那么可以算作多种不同的珠子对待</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=bios)ans=<span class="built_in">max</span>(ans,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>gcd</tag>
        <tag>规律发现</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#651-E</title>
    <url>/2020/07/11/codeforces-651-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1370/problem/E" target="_blank" rel="noopener">E. Binary Subsequence Rotation</a> </p>
<p>题意<br>给出两个等长度的01字符串s t<br>要求经过最少次操作使得s变为t<br>一次操作定义为<br>选出s中的一个子序列a<br>将子序列a中的元素顺时钟移动一位 再按原下标放回到s中 视为一次操作</p>
<p>比如<br>s=101001 选出子序列为{s1,s2,s4}={1,0,0} 顺时针转动后为 {0,1,0}放回s<br>则s变为 {011001}</p>
<p>首先排除掉s和t中0/1数量不同的<br>其他情况一定存在解<br>将 s中同一位置与 t<br>不同的字符拿出组成一个新字符串，<br>每次操作一定是取出 01010…或 10101…的子序列，</p>
<p>类似000111 -&gt; 111000 可以拆成三对01子序列进行转换<br>所以找出原字符串中最长的未被1抵消的 0的长度 较短的 连续0则被包含在0101 中<br>和最长的不被0抵消的1的长度 ；有部分为1开头的子序列被包含在0101的子序列中被计入以0开头的子序列<br>未被包含的子序列独自组成1010子序列<br>的长度即可，因为这些都是不能一次连续取的</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> data[Max],vis[Max];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> s,t;<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)<span class="keyword">if</span>(i==<span class="string">'1'</span>)cnt++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:t)<span class="keyword">if</span>(i==<span class="string">'1'</span>)cnt--;</span><br><span class="line">    <span class="keyword">if</span>(cnt)<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,maxn=<span class="number">0</span>,minn=<span class="number">0</span>;<span class="comment">///注意初始值为0若0101串多于1010串那么minn值仍为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==t[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'1'</span>)cnt++;</span><br><span class="line">            <span class="keyword">else</span> cnt--;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,cnt);</span><br><span class="line">            minn=<span class="built_in">min</span>(minn,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;maxn-minn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#654-E1</title>
    <url>/2020/07/09/codeforces-654-E1/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1371/E1" target="_blank" rel="noopener">E1. Asterism (Easy Version)</a></p>
<p>题意</p>
<p>一个玩家初始能力值为x (x未知)</p>
<p>有n个敌人 每个敌人有能力值pi</p>
<p>玩家需要以某种顺序逐个挑战每个敌人 </p>
<p>当玩家能力值x&gt;=当前敌人能力值pi 那么可以击败它 然后玩家能力值x++</p>
<p>否则跳过这个敌人玩家能力不变</p>
<p>定义f(x)为 玩家初始能力为x时 有多少种不同的挑战顺序能击败所有敌人</p>
<p>现在问对于已知n个敌人能力值和一个素数p</p>
<p>有多少种x使得f(x)%p !=0</p>
<p>输出种类数m 并升序输出所有x</p>
<p>题解</p>
<p>从变化中寻找不变的因素 一个显然的事实是 无论以哪种顺序依次击败所有敌人</p>
<p>每次击败一个敌人自身能力值x都会+1 </p>
<p>那么下次玩家一定能从剩下的敌人中选出能力值pi&lt;=x的其中一个敌人挑战</p>
<p>以此类推那么对于一个初始能力值为x的玩家</p>
<p>$$<br>f(x)= (小于等于x的敌人个数)*(小于等于x+1的敌人个数-1) *(小于等于x+2的敌人个数-2) ….<br>$$<br>若某时刻发现剩下的敌人中没有能力值pi&lt;=当前x的那么表示这种初始能力值不能击败所有敌人f(x)=0</p>
<p>由于初始能力值x&gt;最大的敌人能力值pi x无论如何增大f(x)不变</p>
<p>而题目说明m最多不会超过1e5那么只要x枚举到max(敌人能力值)</p>
<p>每次On计算f(x) 总复杂度On^2</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">int</span> data[Max],cnt[Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n,p;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line"></span><br><span class="line">    sort(data+<span class="number">1</span>,data+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll x=<span class="number">1</span>;x&lt;=data[n];x++)&#123;</span><br><span class="line">        ll now=x,pos=<span class="number">1</span>,temp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll eatten=<span class="number">0</span>;eatten&lt;n;)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pos&lt;=n&amp;&amp;data[pos]&lt;=now)pos++;</span><br><span class="line">            temp=(pos-eatten<span class="number">-1</span>)%p;</span><br><span class="line">            <span class="keyword">if</span>(!temp)<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//f=(f*temp)%p;</span></span><br><span class="line">            eatten++;now++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;x&lt;&lt;" "&lt;&lt;f&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(temp)ans.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:ans)<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#655-D</title>
    <url>/2020/07/14/codeforces-655-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1372/D" target="_blank" rel="noopener">D. Omkar and Circle</a></p>
<p>题意</p>
<p>n(奇数)个数排成一个⚪ 首尾相接</p>
<p>现在反复进行一种操作</p>
<p>取出一个数 然后它两侧的数相加成为新的数</p>
<p>最后只剩1个数 </p>
<p>问这个数最大多少</p>
<p>题解</p>
<p>首先想到贪心的两种策略</p>
<p>1.尽量保留最大的</p>
<p>2.尽量让多个数相加留到最后</p>
<p>比如7个数 </p>
<p>a  b  c  d  e  f  g</p>
<p>假设最后剩下的数为x</p>
<p>它最多由原先4个数相加最少由原先2个数相加</p>
<p>而这四个数是从⚪的某个位置切断形成链后间隔取到的</p>
<p>推广到n个数形成的⚪ 最少由(n-1)/2个数相加 最少由2个数相加</p>
<p>若想让x是n个数中y个数相加 {y&lt;(n-1)/2} </p>
<p>那它一定是(n-1)/2个数相加的中的某种情况去掉一些数得到的</p>
<p>比如7个数 </p>
<p>a  b  c  d  e  f  g</p>
<p>选择最终x由三个数相加得到 </p>
<p>去掉b得到 a+c  d  e  f  g</p>
<p>去掉f得到  a+c  d  e+g</p>
<p>去掉e+g 得到 a+c+d </p>
<p>实际上它是 a+c+d+f 的和去掉f</p>
<p>a+c+d+f是去掉b，e，g得到的结果</p>
<p>所以得出结论贪心策略是留下尽量多的数相加</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line">ll data[Max];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    ll ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">        data[i+n]=data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;data[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sum=<span class="number">0</span>;ll temp=<span class="number">0</span>;<span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        sum+=data[i];</span><br><span class="line">        <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==flag)&#123;</span><br><span class="line">            temp+=data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i-L+<span class="number">1</span>&gt;=n)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,temp);</span><br><span class="line">            temp=sum-temp;</span><br><span class="line">            flag=!flag;</span><br><span class="line">            sum-=data[L];</span><br><span class="line">            L++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>贪心</tag>
        <tag>规律发现</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#653-F</title>
    <url>/2020/07/14/codeforces-653-F/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1374/problem/F" target="_blank" rel="noopener">F. Cyclic Shifts Sorting</a></p>
<p>题意</p>
<p>给出一个数组a 长度为n&lt;500</p>
<p>要求给它排序 一次排序操作是对[ai,ai+1,ai+2]内的元素整体顺时针移动</p>
<p>变为[ai+2,ai,ai+1]</p>
<p>最多不超过n^2次操作 是否能将原数组排序成非降序</p>
<p>输出操作次数 并输出需要对哪个区间进行顺时针移动</p>
<p>题解</p>
<p>先简化问题 如果这个数组是长度为n的排列，即只有[1,2,3…n]各一个</p>
<p>那么在这种情况下 当且仅当排列中的逆序对为偶数时存在解</p>
<p>因为一次顺时针操移动作后 整个排列的逆序对的奇偶性是不变的</p>
<p>若原来有奇数个逆序对那么无论怎么操作最后仍然会剩下一个逆序对无法被排序</p>
<p>若有偶数对逆序对 那么对该排列模拟 <strong>选择排序</strong> 的过程 找到数组内</p>
<p>第i小的移动到从左到右第i位</p>
<p>那么 对于非排列的数组a ，其中存在重复的数组如何解决呢</p>
<p>首先离散化原数组a (根据pair(ai,i)以值为第一关键字 下标为第二关键字sort )</p>
<p>再根据原数组生成一个对应的排列b</p>
<p>若排列b中有奇数个逆序对 那么尝试找到原数组a中两个相同的数</p>
<p>交换它们在排列b中的位置 使得总的逆序对个数-1 成为偶数</p>
<p>因为a中相同的数被离散化后在排列b是两个不同的数 它们可能产生一对逆序对 而实际上它们不需要被交换，之后再对生成的排列b进行模拟选择排序的过程</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line">ll data[Max],ndata[Max];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> indx;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">rerange</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=ndata[pos],b=ndata[pos+<span class="number">1</span>],c=ndata[pos+<span class="number">2</span>];</span><br><span class="line">    ndata[pos]=c,ndata[pos+<span class="number">1</span>]=a,ndata[pos+<span class="number">2</span>]=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Data a,Data b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.val!=b.val)<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">    <span class="keyword">return</span> a.indx&lt;b.indx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Data&gt;sdata;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;<span class="built_in">step</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">            Data temp;</span><br><span class="line">            temp.indx=i,temp.val=data[i];</span><br><span class="line">            sdata.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//离散化</span></span><br><span class="line">        sort(sdata.<span class="built_in">begin</span>(),sdata.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)ndata[sdata[i].indx]=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> invers=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计逆序对</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)<span class="keyword">if</span>(ndata[j]&lt;ndata[i])invers++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调整排列b使得排列中逆序对为偶数对</span></span><br><span class="line">        <span class="keyword">if</span>(invers&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sdata[i].val==sdata[i+<span class="number">1</span>].val)&#123;</span><br><span class="line">                    swap(ndata[sdata[i].indx],ndata[sdata[i+<span class="number">1</span>].indx]);</span><br><span class="line">                    flag=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///模拟选择排序</span></span><br><span class="line">        <span class="keyword">int</span> inplace=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(inplace&lt;n)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=inplace;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ndata[i]==inplace+<span class="number">1</span>)&#123;</span><br><span class="line">                    pos=i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=pos<span class="number">-2</span>;i&gt;=inplace;i-=<span class="number">2</span>)&#123;</span><br><span class="line">                rerange(i);</span><br><span class="line">                <span class="built_in">step</span>.push_back(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ndata[inplace+<span class="number">1</span>]==inplace+<span class="number">1</span>)&#123;</span><br><span class="line">                rerange(inplace);</span><br><span class="line">                rerange(inplace);</span><br><span class="line">                <span class="built_in">step</span>.push_back(inplace+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">step</span>.push_back(inplace+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//for(int i=0;i&lt;n;i++)cout&lt;&lt;ndata[i]&lt;&lt;" ";</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">            inplace++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">step</span>.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:<span class="built_in">step</span>)<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>sort</tag>
        <tag>离散化</tag>
        <tag>构造</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#656-E</title>
    <url>/2020/07/17/codeforces-656-E/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/problemset/problem/1385/E" target="_blank" rel="noopener">E. Directing Edges</a> </p>
<p>题意 </p>
<p>给出一个n个点m条边的图 n,m&lt;2e5</p>
<p>m条边有一部分给定方向</p>
<p>确定剩下的边的方向使得最后的图不存在环</p>
<p>题解</p>
<p>用有向边建图,无向边视为两点间没有边</p>
<p>进行拓扑排序 每个点都有排序后的拓扑序</p>
<p>若最后被排序的点数&lt;n则一定存在环输出no</p>
<p>否则一定可以构造出无环图</p>
<p>拓扑排序流程</p>
<p>loop：</p>
<p>(1) 选择一个入度为0的顶点并输出之；</p>
<p>(2) 从网中删除此顶点及所有<a href="https://baike.baidu.com/item/%E5%87%BA%E8%BE%B9" target="_blank" rel="noopener">出边</a>。</p>
<p>若不存在入度为0的点则停止</p>
<p>若图中存在环, 环上的所有点入度都&gt;=1 因此他不会被排入拓扑序中</p>
<p>发现对于拓扑排序的结果，对于原图中的无向边</p>
<p>如果将它的方向定为 顺序较后的节点 到 顺序较前的节点 的有向边，必然会构成环 </p>
<p>因为拓扑排序本质上是点的遍历顺序, 若后遍历的点有指向先遍历的点 即返祖边 那么必然存在环</p>
<p>否则将无向边的方向定为先遍历的点指向后遍历的点 两者的拓扑序大小不变 不会构成返祖边</p>
<p>bfs实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfn[]表示该点被访问的时间戳即拓扑序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max];</span><br><span class="line"><span class="keyword">int</span> in[Max],dfn[Max],u[Max],v[Max];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!in[i])q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=q.front();q.pop();</span><br><span class="line">        dfn[pos]=cnt++;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;pos&lt;&lt;" ";</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[pos])&#123;</span><br><span class="line">            in[i]--;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>)q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> in[Max],dfn[Max],u[Max],v[Max];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> tp[Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max];</span><br><span class="line"><span class="comment">/* */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!in[i])q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=q.front();q.pop();</span><br><span class="line">        dfn[pos]=cnt++;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;pos&lt;&lt;" ";</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[pos])&#123;</span><br><span class="line">            in[i]--;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>)q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            in[i]=<span class="number">0</span>,dfn[i]=<span class="number">0</span>;</span><br><span class="line">            mp[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tp[i]&gt;&gt;u[i]&gt;&gt;v[i];</span><br><span class="line">            <span class="keyword">if</span>(tp[i])mp[u[i]].push_back(v[i]),in[v[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs();</span><br><span class="line">        <span class="comment">//cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(cnt!=n)<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tp[i])<span class="built_in">cout</span>&lt;&lt;u[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;v[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfn[u[i]]&lt;dfn[v[i]])<span class="built_in">cout</span>&lt;&lt;u[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;v[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;v[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;u[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#656-G</title>
    <url>/2020/09/04/codeforces-656-G/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1385/G" target="_blank" rel="noopener">G. Columns Swaps</a> </p>
<p>题意</p>
<p>给出一个2×n的矩阵 (n&lt;2e5)</p>
<p>要求每列最多交换一次使得矩阵两行均为[1,n]的排列</p>
<p>[1,n]的排列指[1,n]中每个数有且只有出现一次</p>
<p>问最少要交换几列才能变成2层排列 或者无法变为两层排列输出-1</p>
<p>输出交换次数以及需要交换哪几列</p>
<p>题解</p>
<p>首先判断不可能构成两层排列的情况</p>
<p>比如</p>
<p>1 1 2</p>
<p>3 2 2</p>
<p>其中2出现了3次,3出现了1次 这种情况无论如何变化都不能构成两层排列</p>
<p>所以显然当且仅当所有数在矩阵中出现2次才可能构成符合题意的解</p>
<p>我们将每列建一条无向边</p>
<p>每两个相同的数建一条无向边</p>
<p>对于相同的两个数在同一列则忽略</p>
<p>然后我们就得到了多个环构成的图</p>
<p>对于样例</p>
<p>5 3 5 1 4</p>
<p>1 2 3 2 4</p>
<p>它画出的图如下：</p>
<img src="/.io//timg.gif" data-original="example.png">

<p>将环上的每个点黑白染色后 发现同色的需要在同一行</p>
<p>于是可以用dfs 将环上每个点染色后判断哪种颜色在第一行需要的操作更少</p>
<p>注意存在多个独立环 每个环需要独立判断最优操作</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">2</span>*Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[<span class="number">2</span>*Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pos[Max],shiftA,shiftB;</span><br><span class="line"><span class="keyword">int</span> color[<span class="number">2</span>*Max],n;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2</span>*Max];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa||vis[i])<span class="keyword">continue</span>;</span><br><span class="line">        vis[i]=<span class="number">1</span>;</span><br><span class="line">        color[i]=<span class="number">3</span>-color[now];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i]==<span class="number">1</span>)shiftA.push_back(i);</span><br><span class="line">            <span class="keyword">else</span> shiftB.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(i,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">	<span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pos[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;data[i],pos[data[i]].push_back(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)<span class="built_in">cin</span>&gt;&gt;data[i],pos[data[i]].push_back(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos[i].<span class="built_in">size</span>()!=<span class="number">2</span>)&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> bios=n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)mp[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">                vis[i]=<span class="number">0</span>;color[i]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=n&amp;&amp;data[i]==data[i+bios])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;n&amp;&amp;data[i-bios]==data[i])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=n)mp[i].push_back(i+bios);</span><br><span class="line">                <span class="keyword">else</span> mp[i].push_back(i-bios);</span><br><span class="line">                <span class="keyword">int</span> Samenumpos=pos[data[i]][<span class="number">0</span>]!=i?pos[data[i]][<span class="number">0</span>]:pos[data[i]][<span class="number">1</span>];</span><br><span class="line">                mp[i].push_back(Samenumpos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=n&amp;&amp;data[i]==data[i+bios])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;n&amp;&amp;data[i-bios]==data[i])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">                color[i]=<span class="number">1</span>;dfs(i,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(shiftA.<span class="built_in">size</span>()&lt;shiftB.<span class="built_in">size</span>())<span class="keyword">for</span>(<span class="keyword">auto</span> i:shiftA)ans.push_back(i);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">auto</span> i:shiftB)ans.push_back(i);</span><br><span class="line">                shiftA.<span class="built_in">clear</span>();shiftB.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:ans)<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图染色</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#656-F</title>
    <url>/2020/07/22/codeforces-656-F/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1385/problem/F" target="_blank" rel="noopener">F. Removing Leaves</a> </p>
<p>题意有一棵树，共有n个节点 n-1条边</p>
<p>每次从同一个节点上去除k个叶子，问最多去除几次。 </p>
<p>题解</p>
<p>贪心的策略是：每次剪掉即可。因为剪去叶子不会对其他的节点产生负影响。也就是</p>
<p>说，剪除一次以后，只会说多出一个节点可以减，不会说剪除了以后导致其他节点减不</p>
<p>了。因此这道题根本不用考虑剪枝的先后问题，直接剪就行了。</p>
<p>具体实现</p>
<p>考虑类比拓扑排序，将叶子结点入队，然后对其相邻结点遍历，当被遍历次数到达k</p>
<p>次，ans++，如果此时度数为1就入队，注意需要用vis数组标记一下那些结点已经入过</p>
<p>队，且标记时需要在queue，一次标记一个，因为存在edge(u,v)，这样的情况，度数都</p>
<p>是1，但是如果都标记了，就算不了贡献了</p>
<p><a href="https://blog.csdn.net/woshixuxiran/article/details/107431925" target="_blank" rel="noopener">参考博客</a> <a href="https://blog.csdn.net/weixin_45750972/article/details/107480364" target="_blank" rel="noopener">参考博客</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max];</span><br><span class="line"><span class="keyword">int</span> edge[Max],viscnt[Max];</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)edge[i]=<span class="number">0</span>,mp[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v;<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            mp[u].push_back(v);</span><br><span class="line">            mp[v].push_back(u);</span><br><span class="line">            edge[u]++;edge[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;leave;<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(edge[i]==<span class="number">1</span>)leave.push(i);</span><br><span class="line">                vis[i]=<span class="number">0</span>,viscnt[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">///不需要担心每次queue中弹出的点都要标记被访问</span></span><br><span class="line">            <span class="comment">///之后会不会影响统计结果,因为被弹出的叶子节点</span></span><br><span class="line">            <span class="comment">///已经被统计到它相邻的非叶子结点上从queue中删去不影响</span></span><br><span class="line">            <span class="comment">///只用看相邻的非叶子结点是否满足viscnt[i]%k==0</span></span><br><span class="line">            <span class="keyword">while</span>(!leave.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> u=leave.front();</span><br><span class="line">                leave.pop();vis[u]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[u])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">                    viscnt[i]++;edge[i]--;</span><br><span class="line">                    <span class="keyword">if</span>(viscnt[i]%k==<span class="number">0</span>)&#123;<span class="comment">///这里用%k==0而不用viscnt[i]==k</span></span><br><span class="line">                        ans++;		  <span class="comment">///因为==k次操作一次 ==n*k操作n次</span></span><br><span class="line">                        <span class="keyword">if</span>(edge[i]==<span class="number">1</span>)leave.push(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>实现</tag>
        <tag>图论</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#657-D</title>
    <url>/2020/07/24/codeforces-657-D/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1379/problem/D" target="_blank" rel="noopener">D. New Passenger Trams</a> </p>
<p>题意：</p>
<p>某个星球的一天有h小时，一小时有m分钟，现在有两种车要开，客色的每半小时开一次，每次要等待k(k&lt;=m/2)分钟再开。货车有固定的时刻表，且没有准备时间，但是它与客车的等待时间重合了就会被取消掉（端点重合不取消），问你第一辆客车车的出发时间t(t&lt;=m/2)是多少才能使最少的货车被取消。输出最少要取消几辆以及第一辆客车的出发时间和被取消的货车是那几班</p>
<p>题解  </p>
<p>事实上由于每个客车半小时发一趟车，客车每小时只会出发两趟 所以客车从到站到出发的时间段实际上是以半小时为周期的, 在一小时60分种的情况下若下一趟的车在20分到 后40出发 即相当于 0到30分中 [20,30]和[0,10]分中有客车在等待 货车不能发车，所以将所有的货车出发时间映射到同一个半小时时间段内 仅仅讨论这半个小时内 哪段长度为k(客车等待时间)的时间段内所覆盖到的货车发车班次最少即最优解将所有货车映射到同一个半小时内后 第l趟货车和第r趟货车若发车间隔&gt;=k那么它们就不会被同一个客车等候时间被取消，我们要通过双指针得到一个区间左右端点上货车发车间隔&lt;k且最少货车发车的时间段确定了这个时间段后，第一班客车发车的时间t=右端点r位置的货车发车时间 因为经验上,客车到站或出站与某一辆货车的发车时间重合时可以取到最优 (突变点)</p>
<p>这里train[n+1]=train[1]+m/2 目的是为了更好的处理客车等候时长由于取模(环变链)导致的连续区间分裂 这样双指针就不会因为时长为k的区间一半在前一半在后而变得复杂</p>
<img src="/.io//timg.gif" data-original="example.png">


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Train</span>&#123;</span></span><br><span class="line">    ll mi;</span><br><span class="line">    <span class="keyword">int</span> indx;</span><br><span class="line">&#125; train[Max];</span><br><span class="line">ll n,h,m,k,half;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Train x,Train y)</span></span>&#123;<span class="keyword">return</span>  x.mi&lt;y.mi;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;h&gt;&gt;m&gt;&gt;k;half=m/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    	<span class="comment">///把所有货车出发的时间都对half取模映射到半小时内的时间段讨论</span></span><br><span class="line">    	<span class="comment">///因为所有客车都是以半小时为周期发车的</span></span><br><span class="line">    	<span class="comment">///所以讨论半小时内就行</span></span><br><span class="line">        <span class="keyword">int</span> hi,mi;<span class="built_in">cin</span>&gt;&gt;hi&gt;&gt;mi;</span><br><span class="line">        train[i].mi=mi%half;</span><br><span class="line">        train[i].indx=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(train,train+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    	<span class="comment">///再多加n个货车每个货车的出发时间为mi+half方便处理环</span></span><br><span class="line">    	<span class="comment">///主要是考虑到有的客车等待的时间会跨越0~half 而被取模</span></span><br><span class="line">    	<span class="comment">///这样既不影响单调性也能满足取模的性质</span></span><br><span class="line">        train[i+n].mi=train[i].mi+half;</span><br><span class="line">        train[i+n].indx=train[i].indx;</span><br><span class="line">    &#125;</span><br><span class="line">    ll bios;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">2e5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>,r=n;r&lt;<span class="number">2</span>*n;r++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(train[r].mi-train[l].mi&gt;=k)l++;</span><br><span class="line">        <span class="comment">///因为货车可以和客车同时出发或者在客车刚到时出发</span></span><br><span class="line">        <span class="comment">///所以两趟货车的间隔&gt;=k时不会同时被包括在一个客车等候时间段内</span></span><br><span class="line">        <span class="keyword">if</span>(num&gt;r-l)&#123;</span><br><span class="line">            num=r-l;</span><br><span class="line">            bios=train[r].mi;</span><br><span class="line">            <span class="comment">///贪心策略 </span></span><br><span class="line">            <span class="comment">///加入偏移量t(bios)使得某个货车出发取模后的时间与第一辆客车出发时间</span></span><br><span class="line">        	<span class="comment">///(也可能是到站时间)重合时一定能求得一个最优解</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="string">" "</span>&lt;&lt;bios%half&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        <span class="comment">///必须遍历2n个因为得到的bios是用多加入n个货车产生的,即bios的值在[0~m-1]</span></span><br><span class="line">        <span class="keyword">if</span>(train[i].mi&lt;bios&amp;&amp;train[i].mi&gt;bios-k)<span class="built_in">cout</span>&lt;&lt;train[i].indx&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#657-C</title>
    <url>/2020/07/21/codeforces-657-C/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/problemset/problem/1379/C" target="_blank" rel="noopener">C. Choosing flowers</a> </p>
<p>题意 </p>
<p>m种花，每种都有无限多要买n支</p>
<p>第一次购买第i种花获得a[i]点hp值 之后购买这种花获得b[i]hp值</p>
<p>问最多能获得多少hp值</p>
<p>题解</p>
<p>假设最优策略里面选择了x1,x2,…xn种买了不止一支，其余的可能只卖了一支，就直接按照a的从大到小买，对于b的贡献，按照b排序，那么b序列的贡献 </p>
<p>b[x1]&gt;=b[x2]&gt;=b[x3]…&gt;=b[xn] 显然在购买总数不变的条件下买x1获得的hp值更多</p>
<p>所以只有可能最多有一种花买了大于1支其余都只买了1支</p>
<p>那么只需要找到是哪种花购买1次以上，对于购买了k次的花记为x，则我们会发现如果少购买一次bx，去购买一个ai（ai&gt;bx)则会使得总数值更高，因此对于每种bx，我们在购买它之前需要把所有ai&gt;bx的花都先买下来。因此可以先按照ai进行排序，然后记录下ai的前缀和sum[i]，之后枚举每一个bi，二分查找到最小的p使得ap&gt;=bi(因为是按照a[i]升序)，剩下的n-(m-pos)支花就全部购买bi。<br>处理过程需要注意：</p>
<p>1.如果m-p&gt;n，则最多只能购买sum[n]而不是sum[p]</p>
<p>2.如果 p&gt;m说明不存在a[p]&gt;b[i]全部买这种花最优</p>
<p>3.如果i&lt;=p(因为是升序大的a[p]都靠后)，则说明当前bi对应的第一次购买ai还没有被购买，需要先购买一次ai，剩下的n-p-1次才能购买bi。</p>
<p>4.如果i&gt;p，剩下的n-p次全部购买bi。</p>
<p><a href="https://blog.csdn.net/ylwhxht/article/details/107454565?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1" target="_blank" rel="noopener">参考博客</a></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line">P data[Max];</span><br><span class="line">ll persum[Max],a[Max],b[Max];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">100 1</span></span><br><span class="line"><span class="comment">100 1</span></span><br><span class="line"><span class="comment">1 101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">cin</span>&gt;&gt;data[i].first&gt;&gt;data[i].second;</span><br><span class="line">        sort(data+<span class="number">1</span>,data+<span class="number">1</span>+m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)persum[i]=persum[i<span class="number">-1</span>]+data[i].first,a[i]=data[i].first;</span><br><span class="line">        <span class="comment">//for(int i=1;i&lt;=m;i++)cout&lt;&lt;data[i].first&lt;&lt;" ";</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//if(m&gt;=n)ans=persum[m]-persum[m-n];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=lower_bound(a+<span class="number">1</span>,a+<span class="number">1</span>+m,data[i].second)-(a+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">///此处注意得到的是最大且小于b[i]的a[pos];</span></span><br><span class="line">            <span class="keyword">int</span> have=m-pos;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;pos&lt;&lt;" "&lt;&lt;have&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(pos&gt;m)ans=<span class="built_in">max</span>(ans,data[i].second*(n<span class="number">-1</span>)+data[i].first);</span><br><span class="line">            <span class="keyword">if</span>(have&gt;n)ans=<span class="built_in">max</span>(ans,persum[m]-persum[m-n]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pos&gt;=i)ans=<span class="built_in">max</span>(ans,data[i].first+persum[m]-persum[pos]+data[i].second*(n<span class="number">-1</span>-have));</span><br><span class="line">            <span class="comment">///前缀和做差persum[m]-persum[pos]意为取第[pos+1,m]种花的第一次购买产生的a[i] hp值</span></span><br><span class="line">            <span class="comment">///所以pos处的花还没购买过一次</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pos&lt;i)ans=<span class="built_in">max</span>(ans,persum[m]-persum[pos]+data[i].second*(n-have));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原先的贪心思路是全部选择一种花x,买完n支</p>
<p>然后贪心的选择用b[x] 换a[y] (a[y]&gt;b[x]) 但是</p>
<p>2 3<br>100 1<br>100 1<br>1 101</p>
<p>这组样例说明了这样贪心不合理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    ll a,b;</span><br><span class="line">    <span class="keyword">bool</span> vis;</span><br><span class="line">&#125;data[Max];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">100 1</span></span><br><span class="line"><span class="comment">100 1</span></span><br><span class="line"><span class="comment">1 101</span></span><br><span class="line"><span class="comment">可以被这个数据hack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpb</span><span class="params">(Data x,Data y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.b!=y.b)<span class="keyword">return</span> x.b&gt;y.b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x.a&gt;y.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpa</span><span class="params">(Data x,Data y)</span></span>&#123;<span class="keyword">return</span> x.a&gt;y.a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m,pos=<span class="number">0</span>;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;data[i].a&gt;&gt;data[i].b;</span><br><span class="line">            data[i].vis=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(data,data+m,cmpb);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;m;i++)cout&lt;&lt;data[i].a&lt;&lt;" "&lt;&lt;data[i].b&lt;&lt;endl;</span></span><br><span class="line">        data[<span class="number">0</span>].vis=<span class="number">1</span>;</span><br><span class="line">        ll ans=data[<span class="number">0</span>].a+(n<span class="number">-1</span>)*data[<span class="number">0</span>].b;</span><br><span class="line">        ll maxb=data[<span class="number">0</span>].b,maxa=data[<span class="number">0</span>].a;</span><br><span class="line">        sort(data,data+m,cmpa);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;m;i++)cout&lt;&lt;data[i].a&lt;&lt;" "&lt;&lt;data[i].b&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>&amp;&amp;pos&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[pos].vis)pos++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(maxb&lt;data[pos].a)&#123;</span><br><span class="line">                ans-=maxb;ans+=data[pos].a;</span><br><span class="line">                <span class="comment">//data[pos].vis=1;</span></span><br><span class="line">                data[pos].a=data[pos].b;</span><br><span class="line">                pos++,n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            sort(data,data+m,cmpa);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(data[i].a&gt;maxa)&#123;</span><br><span class="line">                    ans-=maxa;</span><br><span class="line">                    ans+=data[i].a;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#658-D</title>
    <url>/2020/07/22/codeforces-658-D/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1382/problem/C2" target="_blank" rel="noopener">C2. Prefix Flip (Hard Version)</a> </p>
<p>题意<br>给出一个长度为2n的排列p</p>
<p>要求判断能否还原出两个等长的数组a b</p>
<p>使得merge(a,b)=p</p>
<p>定义merge运算：</p>
<p>merge(空集,a)=a</p>
<p>merge(a[1<del>n] , b[1</del>n])= a[1]&lt;b[1]?a[1]+merge(a[2<del>n], b[1</del>n]) : b[1]+ merge(a[1<del>n], b[2</del>n]);</p>
<p>就是比较a和b数组第一个数谁大 就把谁放到新数组(最初为空)的下一个位置</p>
<p>题解</p>
<p>观察样例发现merge运算实际上是当 max(a[l<del>r]) &lt;b[i] or max(b[l</del>r]) &lt; a[i]时，</p>
<p>将a[l<del>r]/ b[l</del>r] 放在一个b[i]/a[i]前</p>
<p>根据这个性质将2n的排列p打碎成尽量多的子串 假设最后子串有m个 </p>
<p><strong>例如3 , 1 , 4 ,5 , 2 , 63. 这个例子被分为(3 , 1) , (4) , (5 , 2) ,(6)</strong></p>
<p>每一个子串属于a/b中的1个 现在可以将问题转化成01背包模型</p>
<p>对于一个容量为n的 背包 m个物品每个 物品体积=价值=这个子串的长度</p>
<p>求能装下物品的前提下最大价值</p>
<p>若最后dp[n]=n说明存在解 否者输出no</p>
<p><a href="https://blog.csdn.net/spnooyseed/article/details/107508343" target="_blank" rel="noopener">参考博客</a></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">4000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> data[Max],dp[Max];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">string</span> s,ns;<span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;group;<span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)<span class="built_in">cin</span>&gt;&gt;data[i],dp[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxn=data[<span class="number">0</span>];data[<span class="number">2</span>*n]=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;maxn)&#123;</span><br><span class="line">                group.push_back(cnt);</span><br><span class="line">                cnt=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cnt++;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for(auto i:group)cout&lt;&lt;i&lt;&lt;" ";</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> len=group.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> w=n;w&gt;=group[i];w--)&#123;</span><br><span class="line">                dp[w]=<span class="built_in">max</span>(dp[w],dp[w-group[i]]+group[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dp[n]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(dp[n]!=n)<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>实现</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#658-C2</title>
    <url>/2020/07/22/codeforces-658-C2/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1382/problem/C2" target="_blank" rel="noopener">C2. Prefix Flip (Hard Version)</a> </p>
<p>题意<br>给出两个长度为n&lt;2e5的01串</p>
<p>一个原串s和一个目标串t</p>
<p>要求不超过2n次操作将s变为t串</p>
<p>一次操作：</p>
<p>选择s的一个前缀 将前缀中的0变成1，1变成0</p>
<p>然后将这个前缀翻转 </p>
<p>题解</p>
<p>有很多种构造方法</p>
<p>easy版On^2 复杂度用2n次操作:</p>
<p>从后往前遍历 逐个修改s[i]</p>
<p>若s[i]!=t[i] 它必然需要被操作 由于一次操作时一定有一个前缀的整体翻转</p>
<p>所以s[i]处的bit一定是由s[0]处翻转得到的</p>
<p>所以策略是先操作第一个bit s[0] (要判断是否需要) 然后再操作前缀s[0~i]</p>
<p>On^2是需要模拟操作种的取反+反转</p>
<p>hard版可以用同样策略优化到</p>
<p>需要考虑如何优化掉模拟操作带来的复杂度</p>
<p>注意到每次取反翻转 使得s[i]=t[i]  对于当前状态的s的前缀对应最初s的某一段子串</p>
<p>只需要追踪当前状态的s的前缀对应最初s串中那个下标 并且是否是翻转得到</p>
<p>就可以On处理处答案</p>
<p>实际实现时出了一对bug调到心累 逻辑不够清晰代码写的稀烂</p>
<p>另一种策略:</p>
<p>更直观的策略是用n次操作将s变为全0串</p>
<p>再用n次操作将t变为全0串</p>
<p>那么答案是 将s变为全0串的过程+t变为全0串的逆过程</p>
<p>官方代码 </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案2，摘自社论</span></span><br><span class="line"><span class="comment">//我们不进行模拟，而是存储两个变量idx和flip</span></span><br><span class="line"><span class="comment">//它们告诉我们足够的信息来询问过程中第一个比特的值</span></span><br><span class="line"><span class="comment">//如果flip为false，则表示子字符串s[idx，…， idx + i)目前是s的开始</span></span><br><span class="line"><span class="comment">//如果翻转为真，则表示翻转子字符串s[idx - i + 1，…目前是s的开始</span></span><br><span class="line"><span class="comment">//我们在每位O(1)时间或O(n)时间内正确地更新idx和翻转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">bool</span> flip = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ops;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flip ^ (a[idx] == b[i])) &#123;</span><br><span class="line">                ops.push_back(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ops.push_back(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(flip) idx -= i;</span><br><span class="line">            <span class="keyword">else</span> idx += i;</span><br><span class="line">            flip = !flip;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ops.<span class="built_in">size</span>() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : ops) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种实现方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;ll,ll&gt; P;</span><br><span class="line"><span class="comment">#define endl '\n'</span></span><br><span class="line"><span class="comment">#define Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line">const int mod=2e3;</span><br><span class="line">const int Max=2000+5;</span><br><span class="line">int data[Max],dp[2][Max];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">4</span><br><span class="line">10</span><br><span class="line">0110011011</span><br><span class="line">1000110100</span><br><span class="line">7 1 10 8 7 1 2 1</span><br><span class="line">*/</span><br><span class="line">string s,ns;int n;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    int t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        int n;cin&gt;&gt;n;</span><br><span class="line">        string s,ns;cin&gt;&gt;s&gt;&gt;ns;</span><br><span class="line">        s+=<span class="string">'0'</span>,ns+=<span class="string">'0'</span>;</span><br><span class="line">        vector&lt;int&gt;ans,temp;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[i+1])ans.push_back(i+1);</span><br><span class="line">            <span class="keyword">if</span>(ns[i]!=ns[i+1])temp.push_back(i+1);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(temp.begin(),temp.end());</span><br><span class="line">        cout&lt;&lt;ans.size()+temp.size();</span><br><span class="line">        <span class="keyword">for</span>(auto i:ans)cout&lt;&lt;<span class="string">" "</span>&lt;&lt;i;</span><br><span class="line">        <span class="keyword">for</span>(auto i:temp)cout&lt;&lt;<span class="string">" "</span>&lt;&lt;i;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>实现</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#659-D</title>
    <url>/2020/07/28/codeforces-659-D/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1384/problem/D" target="_blank" rel="noopener">D. GameGame</a> </p>
<p>题意<br>有一堆数字</p>
<p>两个人轮流拿</p>
<p>最后两人手里的数的异或和最大的人取胜</p>
<p>题解</p>
<p>对于所有数的most significant bit 统计 有x个1 y个0</p>
<p>假设x是偶数那么对于这一位数，两人最后拿到的异或和相同</p>
<p>去掉这一位以下一位作为most significat bit </p>
<p>若当前x为奇数需要讨论</p>
<p>若当前这位x%4==1</p>
<p>那么先手可以先拿一个1然后模仿后手每次的决策 最后先手这位数的异或和更大</p>
<p>比如x=5, 被轮流取走后先手有3个1 而后手只有2个1 </p>
<p>若当前这位x%4==3</p>
<p>假设y%2==0</p>
<p>后手一直模仿先手每次的决策最后会多出来一个1 先手必须拿走 </p>
<p>最后先手手中有偶数个1 后手有奇数个1后手更大</p>
<p>若y%2==1那么  先手可以先拿多出来的0,让后手变成先手 两人角色互换 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll data[Max];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;<span class="keyword">bool</span> Lose=<span class="number">0</span>,Win=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">        <span class="keyword">for</span>(ll shift=<span class="number">32</span>;shift&gt;=<span class="number">0</span>;shift--)&#123;</span><br><span class="line">            ll msb=(<span class="number">1l</span>l&lt;&lt;shift);</span><br><span class="line">            <span class="keyword">int</span> one=<span class="number">0</span>,zero=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(msb&amp;data[i])one++;</span><br><span class="line">                <span class="keyword">else</span> zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(one%<span class="number">2</span>==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(zero%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;one%<span class="number">4</span>==<span class="number">3</span>)Lose=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> Win=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Lose)<span class="built_in">cout</span>&lt;&lt;<span class="string">"LOSE"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Win)<span class="built_in">cout</span>&lt;&lt;<span class="string">"WIN"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"DRAW"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>构造</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#659-B</title>
    <url>/2020/07/25/codeforces-659-B/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1384/problem/B2" target="_blank" rel="noopener">B2. Koa and the Beach (Hard Version)</a> </p>
<p><a href="https://codeforc.es/contest/1384/problem/B1" target="_blank" rel="noopener">B1. Koa and the Beach (Easy Version)</a> </p>
<p>题意</p>
<p>一个人从岸边位置0 游到 岛上位置n+1</p>
<p>中间n个水域的深度为d[i]</p>
<p>同时由于潮汐海水深度一直在周期的变化d[i]+p[tmod2k]</p>
<p>其中p=[0,1,2,…,k−2,k−1,k,k−1,k−2,…,2,1] </p>
<p>而这个人不能通过深度为L的水域 问最后这个人能否到达对岸</p>
<p>题解</p>
<p>easy version</p>
<p>可以将{位置,潮汐增加高度,是否处于涨潮期}这个状态视为一个结点</p>
<p>而当前结点是否能转移到其他结点x的条件是d[x]+潮汐增加高度&lt;=l</p>
<p>于是将所有状态点构成一个图 进行dfs搜素是否能够到达n+1位置 </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> deep[Max];</span><br><span class="line"><span class="keyword">int</span> n,k,l;<span class="keyword">bool</span> ok;</span><br><span class="line"><span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,pair&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; &gt; &gt;vis;</span><br><span class="line"><span class="comment">///官方用tuple&lt;int,int,bool&gt;可能编译器问题一直报错</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> tide,<span class="keyword">bool</span> down)</span></span>&#123;</span><br><span class="line">    <span class="comment">//vis[pos]++;</span></span><br><span class="line">    <span class="comment">//if(vis[pos]&gt;=17*k)return;</span></span><br><span class="line">    <span class="comment">///不用三元组标记每个状态是否访问</span></span><br><span class="line">    <span class="comment">///尝试用vis[pos]被访问到一定次数则表明不能通到下一个点</span></span><br><span class="line">    <span class="comment">///但是这种方式可能由于到达当前位置的状态太多</span></span><br><span class="line">    <span class="comment">///无法准确给出一个限定最多访问的次数上界</span></span><br><span class="line">    <span class="keyword">if</span>(pos&gt;n)&#123;</span><br><span class="line">        ok=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vis.count(&#123;pos,&#123;tide,down&#125;&#125;))<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> vis.insert(&#123;pos,&#123;tide,down&#125;&#125;);</span><br><span class="line">    tide+=(down?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(tide==k||tide==<span class="number">0</span>)down=!down;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;pos&lt;&lt;" "&lt;&lt;tide&lt;&lt;" "&lt;&lt;down&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(deep[pos+<span class="number">1</span>]+tide&lt;=l)dfs(pos+<span class="number">1</span>,tide,down);</span><br><span class="line">    <span class="keyword">if</span>(deep[pos]+tide&lt;=l)dfs(pos,tide,down);</span><br><span class="line">    <span class="comment">//if(deep[pos-1]+tide&lt;=l)dfs(pos-1,tide,down);</span></span><br><span class="line">    <span class="keyword">if</span>(deep[pos]+tide&lt;l&amp;&amp;deep[pos+<span class="number">1</span>]+tide&gt;l)<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ok=<span class="number">0</span>;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;l;</span><br><span class="line">        deep[<span class="number">0</span>]=-k,deep[n+<span class="number">1</span>]=-k;</span><br><span class="line">        vis.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;deep[i];</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!ok)<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hard version</p>
<p>先找到所有安全的水域 safepos即无论何时 他都不会溺水deep[i]+k&lt;=l</p>
<p>然后问题被分解成能否顺利从一个safepos到达下一个safepos</p>
<p><img src="/.io//timg.gif" data-original="example.png">v形曲线表示落潮-涨潮</p>
<p>策略是当他处于某个安全水域时</p>
<p>在落潮到下个点的深度在下一秒刚好不溺水时假设为 t0 游到下一个点</p>
<p>然后反复使用这个策略到达下一个安全点最后t1时刻到达下一个安全点</p>
<p>或者说落潮时当下一个点恰好能安全通过时最快的通过它的策略能避免溺水</p>
<p>假设不是处于t0时游到下一个点 而时t0’</p>
<p>那么最早到达下一个安全点时为t1’  </p>
<p>那么会比“在落潮到下个点的深度在下一秒刚好不溺水时”出发 在t1~t1’所在的水域会多出一些深度</p>
<p>当最优的策略也无法通过时就输出”NO”</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line">ll deep[Max];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">20 26 32</span></span><br><span class="line"><span class="comment">31 27 14 7 2 23 22 21 19 27 31 12 23 31 0 11 28 20 31 30</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n,k,l;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;l;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;safe;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;deep[i];</span><br><span class="line">            <span class="keyword">if</span>(deep[i]+k&lt;=l)safe.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        safe.push_back(n+<span class="number">1</span>);deep[n+<span class="number">1</span>]=-k;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;<span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:safe)&#123;</span><br><span class="line">            ll tide=<span class="built_in">min</span>(k,l-deep[now+<span class="number">1</span>]);<span class="comment">///下一秒到下一个点时涨潮的高度</span></span><br><span class="line">            <span class="keyword">if</span>(tide&lt;<span class="number">0</span>)flag=<span class="number">1</span>;<span class="keyword">bool</span> down=<span class="number">1</span>;<span class="comment">///若涨潮高度为负表示无论如何不能过,down表示是否在落潮</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;now&lt;&lt;" "&lt;&lt;tide&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">while</span>(now&lt;i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tide+deep[now+<span class="number">1</span>]&lt;=l)now++;<span class="comment">///如果下一秒能过就过</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">///当下一秒不能直接到达下一个点则选择等待合适的时机</span></span><br><span class="line">                    ll ntide=<span class="built_in">min</span>(k,l-deep[now+<span class="number">1</span>]);<span class="comment">///等到 到达下一个点恰好到不被淹死的高度</span></span><br><span class="line">                    <span class="keyword">if</span>(ntide&lt;<span class="number">0</span>)flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!down&amp;&amp;deep[now]+k&gt;l)flag=<span class="number">1</span>; </span><br><span class="line">                    <span class="comment">//如果已经处于涨潮阶段而且当前的水域到高潮时会被淹死则不能过</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(!down&amp;&amp;deep[now]+k&lt;=l)down=!down;</span><br><span class="line">                    <span class="comment">//否则可以通过得等到下次落潮</span></span><br><span class="line">                    tide=ntide;now++;</span><br><span class="line">                    <span class="comment">///这里直接当成我已经到达下一个点了</span></span><br><span class="line">                    <span class="comment">///于是直接讨论下下个点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tide==<span class="number">0</span>||tide==k)down=!down;<span class="comment">///判断下一秒时是涨潮还是落潮</span></span><br><span class="line">                <span class="keyword">if</span>(down)tide--;</span><br><span class="line">                <span class="keyword">else</span> tide++;</span><br><span class="line">                <span class="keyword">if</span>(flag)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>贪心</tag>
        <tag>dfs &amp; bfs</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#660-C</title>
    <url>/2020/07/31/codeforces-660-C/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1388/problem/C" target="_blank" rel="noopener">C. Uncle Bogdan and Country Happiness</a> </p>
<p>题意</p>
<p>有n个城市构成n-1条边的树 1号点为根</p>
<p>m个人每个人都在中心城市(根节点)工作</p>
<p>工作结束后回家 每个城市有live[i]个人居住</p>
<p>每个人都有mood值 1/-1当到达一个城市后他的mood值不变</p>
<p>但每个人可能再从某个城市到下一个城市的路中间改变他的mood值 1能变-1但是-1不能变1</p>
<p>现在每个城市都有happy值监测器 一个城市的happy值= 所有经过这个城市的人的mood值之和</p>
<p>现在给出每个城市happy预测值</p>
<p>问当所有人回到家后所有城市的happy值会不会出现预测值的情况</p>
<p>题解</p>
<p>我们发现一个城市i 的happy值最高不会超过以它为根的子树的城市中居住的人的总数sz[i]</p>
<p>最低也不会超过以它为根的子树的城市中居住的人的总数sz[i] 的相反值</p>
<p>同时一个城市i 的happy值-以它为根的子树的城市中居住的人的总数sz[i]应该是偶数</p>
<p>比如一个城市的happy值为7而sz[i]=10</p>
<p>假如10个人路过这里mood都为1那么 happy值为10</p>
<p>假如10个人中有一个mood为-1那么happy值为8</p>
<p>有两个mood为-1那么happy值为6 </p>
<p>发现一个人mood由1变-1总的happy值-2 所以这个城市i的happy值 - sz[i]=偶数</p>
<p>因为有的人经过这个城市后mood由1变为-1 而有的人住在这个城市不会继续往后走</p>
<p>假设留在这个城市i的人mood都是-1那么 happy[i]&gt;= sumhpson[i]-live[i]</p>
<p>假设留在这个城市i的人mood都是1那么 happy[i]&gt;=sumhpson[i]+live[i]</p>
<p>sumhpson[i]表示城市i直接连接的子节点城市的happy值之和</p>
<p>所以显然一个城市i 的happy值应该比sumhpson[i]-live[i] 大</p>
<p>dfs统计sz并维护sumhpson</p>
<p>依靠这几个条件判断每个城市是否符合要求</p>
<p><a href="https://blog.csdn.net/jziwjxjd/article/details/107705164" target="_blank" rel="noopener">还有另外一种判断方法</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> live[Max],hp[Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max];</span><br><span class="line"><span class="keyword">int</span> sumhpson[Max],sz[Max];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_size</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==f)<span class="keyword">continue</span>;</span><br><span class="line">        sumhpson[now]+=hp[i];</span><br><span class="line">        dfs_size(i,now);</span><br><span class="line">        sz[now]+=sz[i];</span><br><span class="line">        <span class="comment">//cout&lt;&lt;now&lt;&lt;" "&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)mp[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;live[i];</span><br><span class="line">            sz[i]=live[i];</span><br><span class="line">            sumhpson[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//minhpfa[0]=1e9+5;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;hp[i];</span><br><span class="line">            <span class="comment">//minhpfa[i]=hp[i];</span></span><br><span class="line">            <span class="comment">//maxhpson[i]=hp[i];</span></span><br><span class="line">            <span class="comment">//sumhpson[i]=hp[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v;<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            mp[u].push_back(v);</span><br><span class="line">            mp[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        dfs_size(<span class="number">1</span>,<span class="number">0</span>);<span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;hp[i]&lt;&lt;" "&lt;&lt;sumhpson[i]+sz[i]&lt;&lt;" "&lt;&lt;-sz[i]&lt;&lt;" "&lt;&lt;sz[i]&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>((hp[i]-sz[i])%<span class="number">2</span>||hp[i]&lt;-sz[i]||hp[i]&gt;sz[i]||sumhpson[i]-live[i]&gt;hp[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dfs &amp; bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#661-D</title>
    <url>/2020/08/06/codeforces-661-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1399/problem/D" target="_blank" rel="noopener">D. Binary String To Subsequences</a> </p>
<p>题意</p>
<p>给出一个01串要求取出尽量少的子序列使得每个子序列都形如01010…或1010…</p>
<p>输出最少分出几个子序列,并输出原来每个字符属于哪个子序列</p>
<p>题解</p>
<p>单纯的实现模拟 </p>
<p>具体的用两个栈zero,one存 以0 or 1结尾的子序列最后一个字符的原下标</p>
<p>每次遇到一个1 先看栈zero里面有没有以0为结尾的子序列有就取出一个以0为结尾的子序列 更新最后一个字符的</p>
<p>下标并塞入以1为结尾的栈one中 若没有以0为结尾的子序列那么就新开一个子序列以当前的1为结尾压入栈one中</p>
<p>同理遇到一个0也如此操作 最后最少需要分割为zero.size()+one.size()个子序列 </p>
<p>每个子序列都形如01010…或1010… </p>
<p>对于每个字符属于哪个子序列 此处设置了一个belong数组</p>
<p>譬如当前拿到一个1 存在以0为结尾的子序列( 它在原串的下标为zero.top() )</p>
<p>那么belong[i]=zero.top() 若不存在以0为结尾的那么</p>
<p>就新开一个以1为结尾的子序列belong[i]=i压入栈one中 最后用belong数组倒着回溯即可分组</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> belong[Max],ans[Max];</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">string</span> s;<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;zero,one;<span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(zero.empty())one.push(i),belong[i]=i;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    belong[i]=zero.top();</span><br><span class="line">                    zero.pop();one.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(one.empty())zero.push(i),belong[i]=i;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    belong[i]=one.top();</span><br><span class="line">                    one.pop();zero.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;one.<span class="built_in">size</span>()+zero.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> temp=i;</span><br><span class="line">            <span class="keyword">while</span>(belong[temp]!=temp)ans[temp]=cnt,temp=belong[temp],vis[temp]=<span class="number">1</span>;</span><br><span class="line">            ans[temp]=cnt;cnt++;vis[temp]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cout</span>&lt;&lt;ans[i]+<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者发现每次取得的字符1 or 0 若要重新开一个子序列它都属于 第zero.size()+one.size()个子序列</p>
<p>否则他就接入 zero.top() or one.top() 后 压入栈的信息为以0 or 1 为结尾的子序列是第几组</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">	freopen(<span class="string">"input.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">//	freopen("output.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos0, pos1;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> newpos = pos0.<span class="built_in">size</span>() + pos1.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pos1.empty()) &#123;</span><br><span class="line">					pos0.push_back(newpos);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					newpos = pos1.back();</span><br><span class="line">					pos1.pop_back();</span><br><span class="line">					pos0.push_back(newpos);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (pos0.empty()) &#123;</span><br><span class="line">					pos1.push_back(newpos);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					newpos = pos0.back();</span><br><span class="line">					pos0.pop_back();</span><br><span class="line">					pos1.push_back(newpos);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ans[i] = newpos;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pos0.<span class="built_in">size</span>() + pos1.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it : ans) <span class="built_in">cout</span> &lt;&lt; it + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>实现</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#660-D</title>
    <url>/2020/07/31/codeforces-660-D/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1388/problem/D" target="_blank" rel="noopener">D. Captain Flint and Treasure</a> </p>
<p>题意</p>
<p>有一个长度为n的数组 n&lt;2e5</p>
<p>每个位置有权值val[i] 和一个to[i]</p>
<p>假如取出它将会获得val[i] ,|val[i]|&lt;1e6</p>
<p>并且它的权值会加到 to[i] (假如to[i]!=-1)下标上的 权值上</p>
<p>比如</p>
<p>val: 1 2 3</p>
<p>to:  2 3 -1</p>
<p>那么取完1号位 ans+=1</p>
<p>并且2号位权重变为 2+1=3</p>
<p>然后取2号位  ans+=3</p>
<p>并且3号位权重变为 3+3=6</p>
<p>最后取3号位 ans+=6</p>
<p>每个位置的权值只能取一次</p>
<p>问最大的ans</p>
<p>题解</p>
<p>将每个点构建成图</p>
<p>发现这是一个森林 每个点最多一个出度 但可以有多个入度</p>
<p>假如先取出叶子结点那么叶子结点的权重会被加到其父节点上</p>
<p>于是贪心考虑从叶子结点开始选择取或不取 (这个点的权值是否为正数)</p>
<p>于是想到用拓扑排序的遍历方式搜索所有结点判断要不要先取出来</p>
<p>然后剩下没有被取过的点 从树的根节点开始拿 用dfs顺序遍历</p>
<p> 这样子节点的负权值不会被加到根上 而导致ans变小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line">ll val[Max],in[Max],out[Max],sum=<span class="number">0</span>,n;</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max],vmp[Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[now])&#123;</span><br><span class="line">        ans.push_back(now);</span><br><span class="line">        sum+=val[now];</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vmp[now])dfs(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!in[i])q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=q.front();q.pop();</span><br><span class="line">        <span class="comment">//dfn[pos]=cnt++;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;pos&lt;&lt;" ";</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[pos])&#123;</span><br><span class="line">            in[i]--;</span><br><span class="line">            <span class="keyword">if</span>(val[pos]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                val[i]+=val[pos];</span><br><span class="line">                sum+=val[pos];</span><br><span class="line">                ans.push_back(pos);</span><br><span class="line">                vis[pos]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!in[i]&amp;&amp;i)q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;val[i];</span><br><span class="line">        <span class="comment">//in[i]=0,vis[i]=0,out[i]=0;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> to;<span class="built_in">cin</span>&gt;&gt;to;</span><br><span class="line">        <span class="keyword">if</span>(to&lt;<span class="number">0</span>)to=<span class="number">0</span>;</span><br><span class="line">        mp[i].push_back(to);</span><br><span class="line">        vmp[to].push_back(i);</span><br><span class="line">        in[to]++;</span><br><span class="line">        <span class="keyword">if</span>(to)out[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="comment">//cout&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;out[i]&lt;&lt;" "&lt;&lt;vis[i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(out[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"dfs "&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:ans)<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
        <tag>dfs &amp; bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#661-E</title>
    <url>/2020/08/06/codeforces-661-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1399/problem/E1" target="_blank" rel="noopener">E1. Weights Division (easy version)</a> </p>
<p>题意</p>
<p>给出一个n个点n-1条边以1号点为根的树每条边有权重(距离)wi </p>
<p>现在定义一种操作：wi=wi/2  </p>
<p>现在要求在最小操作次数的前提下满足：</p>
<p>$∑_{v∈leaves}w(root,v)=sum≤S  $</p>
<p>S已经给出其中w(root,v)表示从根到某个叶子结点的距离</p>
<p>题解</p>
<p>很显然这需要算边的贡献</p>
<p>每条边要被算入总长度sum几次=这条路通到几个子节点 用一个dfs来搜索每个点下面有几个叶子结点</p>
<p>然后这条路对总长度sum的贡献为 val(i,j)*sz[j] 表示(i,j)这条路被使用过sz[j]次,sz[j]就是以j为根的子树中有几个叶子结点,而且对于一条路它肯定是由某个结点连它一个父节点 所有的结点它的父节点唯一，那么可以用这个点来表示指定的路比如val(i,j)表示父节点i -&gt; 子节点 j的路 可以直接用val[j]表示</p>
<p>然后就是怎么贪心做wi=wi/2的操作问题 首先想到根据 val[i]*sz[i] 排序 大的优先 /2 但是这里需要注意  </p>
<p>val[i]*sz[i] 是由val[i]和sz[i]共同决定的 而每次操作只能对val[i]=val[i]/2 </p>
<p>所以根据 val[i]*sz[i]排序贪心不合理 而根据这条路val[i]被减半后带来的收益来排序</p>
<p>也就是sz[i]×val[i]-(val[i]/2)×sz[i] 来排序 </p>
<p>具体的</p>
<p>将{sz[i]×val[i]-(val[i]/2ll)×sz[i],i}作为一个pair放入降序的优先队列</p>
<p>同时记录一个sum=∑sz[i]*val[i]</p>
<p>每次取出堆头 sum-( sz[i]×val[i]-(val[i]/2ll)×sz[i])</p>
<p>然后更新对这条边下一次操作的收益 </p>
<p>即将val[i]/=2后 再次压入{sz[i]×val[i]-(val[i]/2ll)×sz[i],i}到优先队列</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,ll&gt; &gt;mp[Max];</span><br><span class="line">priority_queue&lt;pair&lt;ll,ll&gt;,<span class="built_in">vector</span>&lt;pair&lt;ll,ll&gt; &gt;,less&lt;pair&lt;ll,ll&gt; &gt; &gt;q;</span><br><span class="line">ll sz[Max],val[Max];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_size</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> per)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp[now].<span class="built_in">size</span>()==<span class="number">1</span>)sz[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> sz[now]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i.first==per)<span class="keyword">continue</span>;</span><br><span class="line">        val[i.first]=i.second;</span><br><span class="line">        dfs_size(i.first,now);</span><br><span class="line">        sz[now]+=sz[i.first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n,s;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v,w;<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            mp[u].push_back(&#123;v,w&#125;);</span><br><span class="line">            mp[v].push_back(&#123;u,w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs_size(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;val[i]&lt;&lt;" "&lt;&lt;sz[i]&lt;&lt;" "&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">            q.push(&#123;sz[i]*val[i]-(val[i]/<span class="number">2l</span>l)*sz[i],i&#125;);</span><br><span class="line">            sum+=sz[i]*val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(sum&gt;s)&#123;</span><br><span class="line">            pair&lt;ll,ll&gt;temp=q.top();q.pop();</span><br><span class="line">            sum-=temp.first;</span><br><span class="line">            val[temp.second]/=<span class="number">2l</span>l;</span><br><span class="line">            temp.first=sz[temp.second]*val[temp.second]-(val[temp.second]/<span class="number">2l</span>l)*sz[temp.second];</span><br><span class="line">            q.push(temp);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)mp[i].<span class="built_in">clear</span>(),val[i]=<span class="number">0</span>,sz[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://codeforces.ml/problemset/problem/1399/E2" target="_blank" rel="noopener">E2. Weights Division (hard version)</a> </p>
<p>题意</p>
<p>和easy version类似 只不过每条边多了个属性 </p>
<p>对他做一次w/=2操作会产生对应的cost(1&lt;=cost&lt;=2)</p>
<p>现在问使得$∑_{v∈leaves}w(root,v)=sum≤S$</p>
<p>最小的花费</p>
<p>题解</p>
<p>将两种花费的边分别独立处理</p>
<p>只对cost=1的边进行操作,</p>
<p>将所有cost=1的边按照easy的贪心方法逐个操作</p>
<p>直到所有cost=1的边 的$∑wi=0$ 每次操作时将当前的$∑wi$单独存入v1</p>
<p>只对cost=2的边进行操作</p>
<p>将所有cost=2的边按照easy的贪心方法逐个操作</p>
<p>直到所有cost=2的边 的$∑wi=0$ 每次操作时将当前的$∑wi$单独存入v2</p>
<p>然后可以用二分或者双指针 对于所有v1[i] 寻找到一个最大的v2[j]且小于等于s-v1[i]</p>
<p>则最小花费更新为ans=min(ans,i+2*j)</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="comment">#define endl '\n'</span></span><br><span class="line"><span class="comment">#define Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line">const ll Max=<span class="number">1</span>e5+<span class="number">5</span>;</span><br><span class="line">const double PI=acos(-<span class="number">1</span>);</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>,pair&lt;ll,<span class="keyword">int</span>&gt; &gt; &gt;mp[Max];</span><br><span class="line">priority_queue&lt;pair&lt;ll,ll&gt;,vector&lt;pair&lt;ll,ll&gt; &gt;,less&lt;pair&lt;ll,ll&gt; &gt; &gt;<span class="string">q[3]</span>;</span><br><span class="line">ll sz[Max],val[Max],n,<span class="keyword">s</span>;</span><br><span class="line"><span class="keyword">int</span> cost[Max];</span><br><span class="line">/*</span><br><span class="line">*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">void dfs_size(int now,int per)&#123;</span></span><br><span class="line"><span class="regexp">    if(mp[now].size()==1)sz[now]=1;</span></span><br><span class="line"><span class="regexp">    else sz[now]=0;</span></span><br><span class="line"><span class="regexp">    for(auto i:mp[now])&#123;</span></span><br><span class="line"><span class="regexp">        if(i.first==per)continue;</span></span><br><span class="line"><span class="regexp">        val[i.first]=i.second.first;</span></span><br><span class="line"><span class="regexp">        cost[i.first]=i.second.second;</span></span><br><span class="line"><span class="regexp">        dfs_size(i.first,now);</span></span><br><span class="line"><span class="regexp">        sz[now]+=sz[i.first];</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">vector&lt;ll&gt; get(int c)&#123;</span></span><br><span class="line"><span class="regexp">    vector&lt;ll&gt;res;</span></span><br><span class="line"><span class="regexp">    ll sum=0;</span></span><br><span class="line"><span class="regexp">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/cout&lt;&lt;val[i]&lt;&lt;" "&lt;&lt;sz[i]&lt;&lt;" "&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line"><span class="regexp">        if(cost[i]!=c)continue;</span></span><br><span class="line"><span class="regexp">        q[c].push(&#123;sz[i]*val[i]-(val[i]/</span><span class="number">2</span>ll)*sz[i],i&#125;);</span><br><span class="line">        sum+=sz[i]*val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(sum);</span><br><span class="line">    <span class="keyword">while</span>(sum&gt;<span class="number">0</span>&amp;&amp;!<span class="string">q[c]</span>.empty())&#123;</span><br><span class="line">        pair&lt;ll,ll&gt;temp=<span class="string">q[c]</span>.top();<span class="string">q[c]</span>.pop();</span><br><span class="line">        sum-=temp.first;</span><br><span class="line">        res.push_back(sum);</span><br><span class="line">        val[temp.second]/=<span class="number">2</span>ll;</span><br><span class="line">        temp.first=sz[temp.second]*val[temp.second]-(val[temp.second]/<span class="number">2</span>ll)*sz[temp.second];</span><br><span class="line">        <span class="string">q[c]</span>.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="string">q[1]</span>.empty())<span class="string">q[1]</span>.pop();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="string">q[2]</span>.empty())<span class="string">q[2]</span>.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    //Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;<span class="keyword">s</span>;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v,w,c;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w&gt;&gt;c;</span><br><span class="line">            mp[u].push_back(&#123;v,&#123;w,c&#125;&#125;);</span><br><span class="line">            mp[v].push_back(&#123;u,&#123;w,c&#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs_size(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        //cout&lt;&lt;<span class="string">"ok"</span>&lt;&lt;endl;</span><br><span class="line">        vector&lt;ll&gt;v1=get(<span class="number">1</span>),v2=get(<span class="number">2</span>);</span><br><span class="line">        //cout&lt;&lt;<span class="string">"ok"</span>&lt;&lt;endl;</span><br><span class="line">        ll ans=<span class="number">1</span>e18,<span class="keyword">pos</span>=v2.size()-<span class="number">1</span>,len=v1.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            //cout&lt;&lt;<span class="string">"in"</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">pos</span>&gt;<span class="number">0</span>&amp;&amp;v1[i]+v2[<span class="keyword">pos</span>-<span class="number">1</span>]&lt;=<span class="keyword">s</span>)<span class="keyword">pos</span>--;</span><br><span class="line">            <span class="keyword">if</span>(v1[i]+v2[<span class="keyword">pos</span>]&lt;=<span class="keyword">s</span>)ans=min(ans,i+<span class="number">2</span>*<span class="keyword">pos</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)mp[i].clear(),val[i]=<span class="number">0</span>,sz[i]=<span class="number">0</span>,cost[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>dfs &amp; bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#662-D</title>
    <url>/2020/08/10/codeforces-662-D/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/problemset/problem/1393/D" target="_blank" rel="noopener">D. Rarity and New Dress</a> </p>
<p>题意</p>
<p>给出一个n*m的矩阵</p>
<p>每个位置被染成不同的颜色</p>
<p>问这个矩阵能取出多少个的相同颜色组成的斜正方形</p>
<p>(一个矩阵可以反复使用每次只取出一个斜正方形)</p>
<img src="/.io//timg.gif" data-original="example.png">

<p>题解:</p>
<p>以某个点为中心不断延伸扩大,发现以它为中心的斜正方形共有r(i,j)个 </p>
<p>定义r(i,j)表示以第i行第j列为中心点形成的斜正方形的最大半径</p>
<p>那么这个矩阵能形成共ans个菱形:</p>
<img src="/.io//timg.gif" data-original="formal.png">

<p>应为以每个点为中心辐射延伸的图形不会与以其他点为中心的辐射延伸重叠</p>
<p>所以不会产生重复统计</p>
<p>那么只要找到每个点对应的半径就能暴力求解出答案</p>
<p>对于矩阵中寻找某种特定图案构成的区域不妨考虑将图形”切片” 或 “分解”</p>
<p>从四个方向进行dp</p>
<p>设置L(i,j),R(i,j),U(i,j),D(i,j) 对于每一行维护L(i,j)与R(i,j) 即以(i,j)为端点向左/右延伸同种颜色最长的连续区间</p>
<p>利用一个中间变量mid(i,j)=min(L(i,j),R(i,j))找到以(i,j)为对称中心的最长半径，</p>
<p>这步可以抽象成将图形横向“切片”</p>
<p>更新U(i,j)若(i,j)与(i-1,j)颜色相同U(i,j)=min(U(i-1,j)+1,mid(i,j))否则U(i,j)=1</p>
<p>更新D(i,j)若(i,j)与(i+1,j)颜色相同D(i,j)=min(D(i+1,j)+1,mid(i,j))否则D(i,j)=1</p>
<p>这步是将每一层的”切片”摞在一起修成一个上三角和下三角</p>
<p>然后对于每个点的r(i,j)=min(U(i,j),D(i,j)) 一个菱形也就是斜正方形它是由上下两个对称的三角形组成</p>
<p>所以上三角与下三角中取小的尺寸组成的菱形是以(i,j)为中心的最大菱形</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define endl <span class="string">'\n'</span></span><br><span class="line">#define <span class="symbol">Turnoff</span> std::ios::sync_with_stdio(false)</span><br><span class="line">const ll <span class="symbol">Max</span>=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line">const double <span class="symbol">Pi</span>=acos(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">string s[<span class="symbol">Max</span>];</span><br><span class="line">int l[<span class="symbol">Max</span>][<span class="symbol">Max</span>],r[<span class="symbol">Max</span>][<span class="symbol">Max</span>];</span><br><span class="line">ll up[<span class="symbol">Max</span>][<span class="symbol">Max</span>],down[<span class="symbol">Max</span>][<span class="symbol">Max</span>],mid[<span class="symbol">Max</span>][<span class="symbol">Max</span>];</span><br><span class="line">int main()&#123;</span><br><span class="line">    <span class="symbol">Turnoff</span>;</span><br><span class="line">    int n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;s[i];</span><br><span class="line">    for(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        //l[i][<span class="number">0</span>]=<span class="number">1</span>,r[i][m<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        for(int j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            if(j&gt;<span class="number">0</span>&amp;&amp;s[i][j]==s[i][j<span class="number">-1</span>])l[i][j]=l[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            else l[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            if(j&lt;m<span class="number">-1</span>&amp;&amp;s[i][j]==s[i][j+<span class="number">1</span>])r[i][j]=r[i][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            else r[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=<span class="number">0</span>;j&lt;m;j++)mid[i][j]=min(l[i][j],r[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        for(int j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            if(i&lt;n<span class="number">-1</span>&amp;&amp;s[i+<span class="number">1</span>][j]==s[i][j])down[i][j]=min(mid[i][j],down[i+<span class="number">1</span>][j]+<span class="number">1</span>);</span><br><span class="line">            else down[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            //cout&lt;&lt;l[i][j]&lt;&lt;<span class="string">" "</span>&lt;&lt;r[i][j]&lt;&lt;<span class="string">" "</span>&lt;&lt;mid[i][j]&lt;&lt;endl;</span><br><span class="line">            if(i&gt;<span class="number">0</span>&amp;&amp;s[i][j]==s[i<span class="number">-1</span>][j])up[i][j]=min(mid[i][j],up[i<span class="number">-1</span>][j]+<span class="number">1</span>);</span><br><span class="line">            else up[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans=<span class="number">0</span>;</span><br><span class="line">    for(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            //cout&lt;&lt;up[i][j]&lt;&lt;<span class="string">" "</span>&lt;&lt;down[i][j]&lt;&lt;endl;</span><br><span class="line">            ans+=min(up[i][j],down[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#661-F</title>
    <url>/2020/09/03/codeforces-661-F/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1399/F" target="_blank" rel="noopener">F. Yet Another Segments Subset</a> </p>
<p>题意</p>
<p>给出n&lt;3000个区间[Li,Ri]分布在[1,2e5]的数轴上</p>
<p>问选出一种最大的区间集合(区间最多) 使得集合中的区间两两要么没有交集</p>
<p>要么其中一个是另一个的子集</p>
<p>题解</p>
<p>由于区间数很少而区间的左右端点在[1,2e5]上分布</p>
<p>所以首先需要离散化将左右端点根据排序后的大小映射到[1,6000]上</p>
<p>用区间dp统计答案 设计dp(L,R) 表示离散化后的坐标轴上</p>
<p>在[L,R]区间上(不一定为输入区间)能选出最大的符合条件的区间集合</p>
<p>根据区间dp的经验</p>
<p>首先枚举区间长度 在枚举区间左端点 枚举区间中间点mid</p>
<p>得到dp转移的伪代码</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for Len &lt; Maxlen:</span><br><span class="line">	for L &lt; Maxlen-len:</span><br><span class="line">		R=L+len-1;</span><br><span class="line">		for L &lt; mid &lt; R:</span><br><span class="line">			if(<span class="comment">[L,R]</span>是输入的区间)dp<span class="comment">[L]</span><span class="comment">[R]</span>=max(dp<span class="comment">[L]</span><span class="comment">[R]</span>,dp<span class="comment">[L]</span><span class="comment">[mid]</span>+dp<span class="comment">[mid+1]</span><span class="comment">[R]</span>+1)</span><br><span class="line">			else if(<span class="comment">[L,R]</span>不是输入的区间)dp<span class="comment">[L]</span><span class="comment">[R]</span>=max(dp<span class="comment">[L]</span><span class="comment">[R]</span>,dp<span class="comment">[L]</span><span class="comment">[mid]</span>+dp<span class="comment">[mid+1]</span><span class="comment">[R]</span>)</span><br></pre></td></tr></table></figure>

<p>但是这种dp时间复杂度为$On^3$ </p>
<p>发现可以通过枚举具体的分割点而不是粗略的[L,R]中所有的点作为分割点</p>
<p>为此我们需要设置vector Rg[L]存入以L为区间左端点对应的所有右端点R</p>
<p>当用传统区间dp时枚举左端L时若输入的区间中存在一个区间的左端点=L</p>
<p>那么以Rg[L]为mid 作为分割点 那么有</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">if([L,R]是输入的区间)dp(<span class="name">L</span>,R)=max(<span class="name">dp</span>(<span class="name">L</span>,R),dp(<span class="name">L</span>,Rg[L])+dp(<span class="name">Rg</span>[L]<span class="number">+1</span>,R)<span class="number">+1</span> )</span><br><span class="line"></span><br><span class="line">else if([L,R]不是输入的区间)dp(<span class="name">L</span>,R)=max(<span class="name">dp</span>(<span class="name">L</span>,R),dp(<span class="name">L</span>,Rg[L])+dp(<span class="name">Rg</span>[L]<span class="number">+1</span>,R) )</span><br></pre></td></tr></table></figure>

<p>这种枚举方式虽然表面上三层for循环也是$n^3$复杂度</p>
<p>实际上在枚举区间左端的和分割点这两个for循环 </p>
<p>相当于遍历了所有输入区间(n个区间)一次</p>
<p>所以内层两个循环实际上为$On$复杂度 </p>
<p>所以总体复杂度为$On^2$ </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">6e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segments</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> indx;</span><br><span class="line">    <span class="keyword">int</span> L,R;</span><br><span class="line">&#125;arr[Max];</span><br><span class="line"><span class="keyword">int</span> dp[Max][Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">	<span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;resort;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i].L&gt;&gt;arr[i].R;</span><br><span class="line">            arr[i].indx=i;</span><br><span class="line">            resort.push_back(arr[i].L);</span><br><span class="line">            resort.push_back(arr[i].R);</span><br><span class="line">            <span class="comment">//arr[i].len=(arr[i].R-arr[i].L+1);</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(resort.<span class="built_in">begin</span>(),resort.<span class="built_in">end</span>());</span><br><span class="line">        resort.erase(unique(resort.<span class="built_in">begin</span>(),resort.<span class="built_in">end</span>()),resort.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i].L=lower_bound(resort.<span class="built_in">begin</span>(),resort.<span class="built_in">end</span>(),arr[i].L)-resort.<span class="built_in">begin</span>();</span><br><span class="line">            arr[i].R=lower_bound(resort.<span class="built_in">begin</span>(),resort.<span class="built_in">end</span>(),arr[i].R)-resort.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="comment">//arr[i].len=arr[i].R-arr[i].L+1;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Rg[Max];<span class="keyword">int</span> Maxlen=resort.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)Rg[arr[i].L].push_back(arr[i].R);</span><br><span class="line">        <span class="comment">///memset(dp,0,sizeof dp);</span></span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;n;i++)sort(Rg[arr[i].L].begin(),Rg[arr[i].L].end());</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Maxlen;i++)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Maxlen;j++)dp[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Maxlen;i++)dp[i][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=Maxlen;len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">0</span>;L+len<span class="number">-1</span>&lt;Maxlen;L++)&#123;</span><br><span class="line">                <span class="keyword">int</span> R=L+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">bool</span> add=count(Rg[L].<span class="built_in">begin</span>(),Rg[L].<span class="built_in">end</span>(),R);</span><br><span class="line">                <span class="comment">//cout&lt;&lt;add&lt;&lt;endl;</span></span><br><span class="line">                dp[L][R]=<span class="built_in">max</span>(dp[L][R],dp[L+<span class="number">1</span>][R]+add);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> rg:Rg[L])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(rg&gt;=R)<span class="keyword">continue</span>;</span><br><span class="line">                    dp[L][R]=<span class="built_in">max</span>(dp[L][R],add+dp[L][rg]+dp[rg+<span class="number">1</span>][R]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">0</span>][Maxlen<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#664-D</title>
    <url>/2020/08/11/codeforces-664-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1394/A" target="_blank" rel="noopener">A. Boboniu Chats with Du</a> </p>
<p>题意</p>
<p>给出一个数组,已知数组长度n, m,d</p>
<p>从左至右依次取数,若数大于m则之后连续的d个数不能拿</p>
<p>要求获得一个排列使得最后取到的数最大</p>
<p>题解</p>
<p>考虑贪心取数 我们需要尽量多的取出更大的数</p>
<p>首先将数组中的数依据&gt;m分成两组</p>
<p>我们需要让取出的数的总和最大那么两组按照降序排列</p>
<p>假设有la个大于m的数记A ，lc个小于等于m的数记为B</p>
<p>贪心的策略是:</p>
<p>ABB..(d个B)..BBABB…BB ..(多出的B)A</p>
<p>因为最后一个位置取了之后不会因为连续d个数不能拿导致损失</p>
<p>所以安排最后一个为A,还能在前面多拿几个B</p>
<p>观察发现假如拿x个A那么会消耗(x-1)×(1+d)+1个数其中x数被记入答案</p>
<p>而其他的数将不被计入答案，这些数可以是A也可以是B</p>
<p>那么让余下的n-(x-1)×(1+d)-1个数从B中挑选最大的几个</p>
<p>所以枚举拿多少个A 更新答案 需要求出两组数降序排列的前缀和</p>
<p>(只能从B中选因为它们不会产生损失使之后d个数不能拿)</p>
<p>若B的总数无法提供n-(x-1)×(1+d)-1个数</p>
<p>那么相当于拿走一个A后面连续的d个数都是A</p>
<p>唯一可能的合法的策略是AA…AABB….BBB (AA…AAA) 后面可能没有A</p>
<p>确保能取走所有的B以及x个A其他A则需要被舍弃</p>
<p>它不符合ABB..ABBB..ABBB..BBA的策略</p>
<p>而用n-(x-1)×(1+d)-1公式得到所需的B会超过B的总数与实际情况不符</p>
<p>所以为了将这个情况纳入枚举中 我们将B的前缀和延展至长度n</p>
<p>当n-(x-1)×(1+d)-1 &gt;lc 我们不选择直接跳过而是计算取出x个最大的A和所有B的和更新答案</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll data[Max];</span><br><span class="line">ll pera[Max],perc[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    ll n,d,m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt;anger,clame;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;d&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ll temp;<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;m)anger.push_back(temp);</span><br><span class="line">        <span class="keyword">else</span> clame.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(anger.<span class="built_in">begin</span>(),anger.<span class="built_in">end</span>(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    sort(clame.<span class="built_in">begin</span>(),clame.<span class="built_in">end</span>(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=anger.<span class="built_in">size</span>();i++)pera[i]=pera[i<span class="number">-1</span>]+anger[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=clame.<span class="built_in">size</span>();i++)perc[i]=perc[i<span class="number">-1</span>]+clame[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=clame.<span class="built_in">size</span>()+<span class="number">1</span>;i&lt;=n;i++)perc[i]=perc[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(anger.empty())<span class="keyword">for</span>(<span class="keyword">auto</span> i:clame)ans+=i;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll x=<span class="number">1</span>;x&lt;=anger.<span class="built_in">size</span>();x++)&#123;</span><br><span class="line">            ll rest=n-(x<span class="number">-1</span>)*(d+<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;rest&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">//if(rest&gt;clame.size())continue;</span></span><br><span class="line">            <span class="keyword">if</span>(rest&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            ll temp=pera[x];</span><br><span class="line">            temp+=perc[rest];</span><br><span class="line">            <span class="comment">//cout&lt;&lt;x&lt;&lt;" "&lt;&lt;rest&lt;&lt;" "&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#664-C</title>
    <url>/2020/08/11/codeforces-664-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1395/C" target="_blank" rel="noopener">C. Boboniu and Bit Operations</a></p>
<p>题意</p>
<p>给出n个数ai 和m个数bi (n,m&lt;200) (ai,bi&lt;2^9)</p>
<p>令ci=ai&amp;bj i∈[1,n],每个bj可以被多个ai选中 </p>
<p>求最小的c1|c2|c3|…|cn</p>
<p>题解</p>
<p>位运算 相关 想到枚举每一位</p>
<p>由于最后求c1|c2|..|cn 只要有一个ci的第i位为1那么最后答案这一位也有1</p>
<p>于是从最高位枚举到最低位</p>
<p>对于某位二进制 找到ai&amp;bj 不为1的bj保留下来 </p>
<p>若对于某个ai找不到ai&amp;bj使的这一位为0那么最后答案中必定有这位二进制产生的贡献</p>
<p>枚举完这一位二进制后 每个ai都有对应的bj被保留下来</p>
<p>到下一位二进制 对于某个ai从被保留下来的bj中选择不会有此位ai&amp;bj为1的 bj保留下来</p>
<p>依次逐位操作筛选得到答案</p>
<p>但这样想过程比较复杂虽然复杂度为O(9nm)</p>
<p>对于最终答案的范围&lt;2^9=512 的条件下</p>
<p>完全可以选择枚举最终答案 然后对于每个答案ans判定是否合法</p>
<p>即是否所有(ai&amp;bj)|ans=ans </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll a[Max],b[Max];</span><br><span class="line"><span class="keyword">bool</span> vis[Max][Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line"> </span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">8</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        ll bits=(<span class="number">1l</span>l&lt;&lt;i);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;<span class="built_in">get</span>[n+<span class="number">5</span>];<span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[j][k])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(bits&amp;(a[j]&amp;b[k]))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">///可用的入队</span></span><br><span class="line">                temp.push_back(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.empty())&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.front()==k)&#123;</span><br><span class="line">                    temp.pop_front();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">get</span>[j].push_back(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)ans+=bits;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> num:<span class="built_in">get</span>[j])&#123;</span><br><span class="line">                    vis[j][num]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#663-C</title>
    <url>/2020/08/11/codeforces-663-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1391/C" target="_blank" rel="noopener">C. Cyclic Permutations</a> </p>
<p>题意</p>
<p>给出一个排列p长度为n ,排列指n个数[1,n]每个数出现1次</p>
<p>现在有如下情况会使两点之间存在无向边:</p>
<p>对于一个位置i 找到最大的位置j (1&lt;=j&lt;i) 且pj&gt;pi</p>
<p>对于一个位置i 找到最小的位置j (i&lt;j&lt;=n) 且pj&gt;pi</p>
<p>翻译一下就是对于一个位置i 往两侧找最靠近i且大于pi的数的位置j建立无向边</p>
<p>给出一个排列长度n 问其中有多少种排列情况会出现环</p>
<p>输出mod 1e9+7</p>
<p>​    </p>
<p>题解</p>
<p>什么情况会出现环</p>
<p>画几个例子之后就发现 两侧大中间小 (低洼点) 会出现环</p>
<p>于是题目变成了寻找有多少中排列 会出现 先递减后递增的情况</p>
<p>直接求需要考虑重复计算的情况非常复杂 </p>
<p>考虑间接求法 :总排列数- 没有低洼的排列(即排列中只有一个极值点)</p>
<p>具体的没有低洼点的排列是:递减排列，递增排列，先递增后递减排列</p>
<p>如何求这种排列的种数呢</p>
<p>一个排列只有一个最大值 依次从大往小放数字(保证排列没有低洼点)</p>
<p>其他数要么在它左边要么在它右边</p>
<p>比如n=5</p>
<p>取4 放在5的左边/右边</p>
<p>取3 放在5的左边/右边</p>
<p>….</p>
<p>一共有$2^{(n-1)}$中排列方式</p>
<p>而总共有$A_n^n$ 个排列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=(ans*x)%mod;</span><br><span class="line">        x=(x*x)%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="comment">//int t;cin&gt;&gt;t;</span></span><br><span class="line">    ll n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    ll tot=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)tot=(tot*i)%mod;</span><br><span class="line">    ll temp=qpow(<span class="number">2</span>,n<span class="number">-1</span>)%mod;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;tot&lt;&lt;" "&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(mod+tot-temp)%mod&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#663-D</title>
    <url>/2020/08/11/codeforces-663-D/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1391/problem/D" target="_blank" rel="noopener">D. 505</a> </p>
<p>题意</p>
<p>给出一个n*m的01矩阵 其中(n&lt;=m&lt;1e6)</p>
<p>要求0/1置换其中的某些位置使得这个01矩阵中</p>
<p>任意偶数边长的正方形区域内都有奇数个1</p>
<p>问最小操作次数若不行则输出-1</p>
<p>题解</p>
<p>在分析如何计算最小操作次数前要发现</p>
<p>若 min(n,m)&gt;3 无论如何都无法构造出符合题意的01矩阵</p>
<p>假设n=m=4 对于最小的偶数边长为2的矩阵 它们要满足其区域内只有奇数个1</p>
<img src="/.io//timg.gif" data-original="example.png">

<p>如上图红框区域内都有奇数个1,但对于橙框区域即整个4×4的区域 4个奇数相加无论如何都为偶数</p>
<p>所以min(n,m)&gt;3误解，另外当min(n,m)==1时不存在偶数边的正方形区域所以输出0</p>
<p>解决了这些问题之后 在考虑如何统计最小次数</p>
<p>构造dp(i,num)表示从左到右第i列01串组成的十进制数为num时转变为合法构造所需要的最小次数</p>
<p>于是dp的状态转移公式为</p>
<p>dp(i,cnum)=min(dp(i,cnum),dp(i-1,pnum)+bitcnt(a[i]^pnum) )</p>
<p>其中bitcount(a[i]^pnum)意思是若构造该列为pnum那与原本该列的01串 ai有多少位不同需要0/1置换操作</p>
<p>判断能否转移的前提是前一列的01串构造为cnum当前列01串构造为pnum是否合法 </p>
<p>即是否会出现2×2的矩阵中有偶数个1 这里用到位运算</p>
<p>要求最小值则初始化dp项为无穷大</p>
<p>答案为 ans=min(ans,dp(m-1,i) ) i∈[0,1&lt;&lt;n)  (从0开始所以第m-1列为最后一列)</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">string</span> s[Max];</span><br><span class="line"><span class="keyword">int</span> bits[Max],dp[Max][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> cnum,<span class="keyword">int</span> pnum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>,cnt=<span class="number">0</span>,ti=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>;<span class="keyword">int</span> carry[<span class="number">2</span>];</span><br><span class="line">    carry[<span class="number">0</span>]=carry[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(maxn)&#123;</span><br><span class="line">        <span class="keyword">if</span>((cnum&amp;<span class="number">1</span>)^(pnum&amp;<span class="number">1</span>))cnt++;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;cnt&lt;&lt;" "&lt;&lt;carry[ti%2]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(ti)&#123;</span><br><span class="line">            cnt-=carry[ti%<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(!(cnt&amp;<span class="number">1</span>))flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        carry[ti%<span class="number">2</span>]=(cnum&amp;<span class="number">1</span>)^(pnum&amp;<span class="number">1</span>);</span><br><span class="line">        ti++;</span><br><span class="line">        cnum&gt;&gt;=<span class="number">1</span>;pnum&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        maxn&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int a,b;</span></span><br><span class="line"><span class="comment">    cin&gt;&gt;a&gt;&gt;b;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;check(a,b)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)dp[i][j]=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;m;c++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>,ti=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;n;r++)&#123;</span><br><span class="line">            temp+=(s[r][c]==<span class="string">'1'</span>)*ti;</span><br><span class="line">            ti*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bits[c]=temp;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;bits[c]&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> up=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;up&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnum=<span class="number">0</span>;cnum&lt;up;cnum++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>,temp=cnum^bits[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp&amp;<span class="number">1</span>)cnt++;</span><br><span class="line">            temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][cnum]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cnum=<span class="number">0</span>;cnum&lt;up;cnum++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pnum=<span class="number">0</span>;pnum&lt;up;pnum++)&#123;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;cnum&lt;&lt;" "&lt;&lt;pnum&lt;&lt;" "&lt;&lt;check(cnum,pnum)&lt;&lt;endl;</span></span><br><span class="line">                    <span class="keyword">if</span>(check(cnum,pnum))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> cnt=<span class="number">0</span>,temp=(pnum^bits[i]);</span><br><span class="line">                <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp&amp;<span class="number">1</span>)cnt++;</span><br><span class="line">                    temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][pnum]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][cnum]+cnt,dp[i][pnum]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)ans=<span class="built_in">min</span>(ans,dp[m<span class="number">-1</span>][i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>实现</tag>
        <tag>dp</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#666-B</title>
    <url>/2020/08/28/codeforces-666-B/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1397/problem/B" target="_blank" rel="noopener">B. Power Sequence</a>  </p>
<p>题意</p>
<p>给出一个数组a 长度为n&lt;1e5 任意元素ai&lt;1e9</p>
<p>要求通过两步操作：</p>
<p>1.交换其中元素的位置，不产生花费</p>
<p>2.使其中某个元素+1or-1 这个操作每次产生1个花费</p>
<p>将它变成新的序列满足 第i项为 $c^i$ (i从0开始)最少花费是多少</p>
<p>题解</p>
<p>想让操作次数最少 首先想到的是将数组a升序排列最优</p>
<p>其次想到c的上界满足 $c^{n-1}$大于等于$a_n$ 的最小的c</p>
<p>所以我们二分c的上界, 此处我们不用“乘” 来check $c^{n-1} &gt; a_n$</p>
<p>而用“除” 来check $a_n/=c$ 需要几次才能除完即$a_n$ 是c的几次幂 因为乘会爆ll,</p>
<p>求得c的上界然后枚举c 更新最优解</p>
<p>这里需要注意：$c^i$ 或$∑(a_i-c^i)$ 可能爆ll 结果会导致小于0  </p>
<p>wa4 输出结果尽然比正确答案小 想不明白。。。</p>
<p>第4个测试点n=100 按理说c=1 所以答案=$∑abs(a_i-c^{i-1})$ 怎么的也不会溢出。。</p>
<p>猜测c=1的答案被其他c(用骚操作看到c=2) 错误更新了虽然$c^i$没溢出 (明明2的62次会溢出)</p>
<p>但是$∑(a_i-c^i)$ 溢出了 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll pi=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    pi*=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(pi&lt;=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pi&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///研究发现这个循环在本地运行pi&lt;=0仍然会输出,cf上也是</span></span><br></pre></td></tr></table></figure>

<p>(由于二分了c的上界,$c^i$并不会溢出) </p>
<p>当出现这种情况表示已经可以break了因为最后不会超过上限</p>
<p>假如$c^{n-1}&gt;a_n$ 那么有 $abs(c^{n-1}-a_n) ≈ 1e9$  的量级</p>
<p>而$abs(c^{i-1}-a_i)$不超过$abs(c^{n-1}-a_n)$的量级</p>
<p>溢出则说明肯定不是最优解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">ll data[Max],n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        num/=c;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;qpow(2,99)&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">    sort(data,data+n);</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">2</span>,R=<span class="number">100000</span>,c=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(R&gt;L)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid,data[n<span class="number">-1</span>]))&#123;</span><br><span class="line">            c=mid;</span><br><span class="line">            R=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> L=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;c&lt;&lt;endl;</span></span><br><span class="line">    ll ans=<span class="number">2e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll p=<span class="number">1</span>;p&lt;=c;p++)&#123;</span><br><span class="line">        ll temp=<span class="number">1</span>,need=<span class="number">0</span>,per=<span class="number">0</span>;<span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            need+=<span class="built_in">abs</span>(data[i]-temp);</span><br><span class="line">            temp*=p;<span class="comment">///二分后c有上界不会使temp溢出</span></span><br><span class="line">            <span class="keyword">if</span>(temp&lt;=<span class="number">0</span>||per&gt;need)&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            per=need;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;need&lt;&lt;endl;</span></span><br><span class="line">        ans=<span class="built_in">min</span>(ans,need);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考其他博客的代码，感觉剪枝的更合理的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> i,n,c,cnt,ans,C,a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">	ans=-n;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]),ans+=a[i];</span><br><span class="line">	sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (c=<span class="number">1</span>; c&lt;=<span class="number">1000000</span>; c++)&#123;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>,C=<span class="number">1</span>; i&lt;=n; i++,C*=c)&#123;</span><br><span class="line">			<span class="keyword">if</span> (C&gt;a[i]) cnt+=C-a[i]; <span class="keyword">else</span> cnt+=a[i]-C;</span><br><span class="line">			<span class="keyword">if</span> (cnt&gt;=ans) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt&lt;ans) ans=cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#665-D</title>
    <url>/2020/08/28/codeforces-665-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1401/D" target="_blank" rel="noopener">D. Maximum Distributed Tree</a> </p>
<p>题意</p>
<p>给出一棵n个点n-1条边的树</p>
<p>现在要求给每条边赋值,</p>
<p>要求：</p>
<p>所有边的权值乘积为k,由于k比较大,给出k的素因子prime(有m个);</p>
<p>所有边权大于0;</p>
<p>令边权为1的边尽可能少;</p>
<p>现在要求树上任意两点的简单路径边权和最大</p>
<p>即$∑<em>{i=1}^{n-1}(∑</em>{j=i+1}^nf(i,j))$</p>
<p>定义$f(i,j)$为树上两点$(i,j)$ 简单路径的边权和</p>
<p>题解</p>
<p>显然要统计每条边权对答案产生的贡献</p>
<p>假设1号点为根 求出每个点的子树大小sz</p>
<p>则对于边$(i,j)$ 其中j为i的子节点</p>
<p>那么它将会被计入答案sz[i]×(n-sz[i])次</p>
<p>于是根据每条边被计入的次数vistime排序</p>
<p>被使用较多的优先分配更大的权值</p>
<p>由于m个素因子可能不能正好给n-1条边分配</p>
<p>于是根据题意首先对所有因子降序排列</p>
<p>若m&lt;n-1那么剩下的边以1为边权</p>
<p>若m&gt;n-1则将大的因子相乘合并为一个因子</p>
<p>反复操作使得最后存在n-1个因子最后分配给所有边</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt;vistime;</span><br><span class="line">ll sz[Max];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_size</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">//sz[now]=1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dfs_size(i,now);</span><br><span class="line">        sz[now]+=sz[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_cnt</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa||i==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        vistime.push_back(sz[i]*(sz[<span class="number">1</span>]-sz[i]));</span><br><span class="line">        dfs_cnt(i,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;vistime.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v;<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            mp[u].push_back(v);</span><br><span class="line">            mp[v].push_back(u);</span><br><span class="line">            sz[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;sz[n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m;<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ll&gt;prime;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p;<span class="built_in">cin</span>&gt;&gt;p;</span><br><span class="line">            prime.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(prime.<span class="built_in">begin</span>(),prime.<span class="built_in">end</span>(),greater&lt;ll&gt;());</span><br><span class="line">        dfs_size(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dfs_cnt(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        sort(vistime.<span class="built_in">begin</span>(),vistime.<span class="built_in">end</span>(),greater&lt;ll&gt;());</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">0</span>,mm=m;</span><br><span class="line">        <span class="keyword">while</span>(mm&gt;n<span class="number">-1</span>&amp;&amp;pos+<span class="number">1</span>&lt;m)&#123;</span><br><span class="line">            prime[pos+<span class="number">1</span>]=((prime[pos+<span class="number">1</span>]%Mod)*(prime[pos]%Mod))%Mod;</span><br><span class="line">            mm--;pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for(int i=pos;i&lt;m;i++)cout&lt;&lt;prime[i]&lt;&lt;" ";</span></span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:vistime)&#123;</span><br><span class="line">            ll temp=pos&lt;m?prime[pos]:<span class="number">1</span>;</span><br><span class="line">            sum=(sum%Mod+((i%Mod)*(temp%Mod))%Mod)%Mod;pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)mp[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dfs &amp; bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#666-C</title>
    <url>/2020/08/28/codeforces-666-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1397/problem/C" target="_blank" rel="noopener">C. Multiples of Length</a> </p>
<p>题意</p>
<p>给出一个数组a 长度为n&lt;1e5 任意元素-1e9&lt;ai&lt;1e9</p>
<p>要求3次操作将原数组变为全0数组</p>
<p>一次操作为：</p>
<p>选取一段区间[L,R] 将其中的数加上或减去 bi×(R-L+1)</p>
<p>输出每次操作的区间和对应位置的bi (bi可以为0)</p>
<p>题解</p>
<p>十分巧妙的构造</p>
<p>首先对[1,n-1]位置上的数-a[i]×(n-1) 那么对于第i位数则变为</p>
<p>a[i]-(n-1)×a[i]=n×a[i]</p>
<p>再令[n,n]位置变为n的倍数</p>
<p>两步操作后所有的数都变为了n的倍数</p>
<p>最后一步让[1,n]上的数-n的倍数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line">ll data[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    ll n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)<span class="built_in">cout</span>&lt;&lt;(n<span class="number">-1</span>)*data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n-data[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)<span class="built_in">cout</span>&lt;&lt;-n*data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;-n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;data[i]&lt;&lt;endl;</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#666-D</title>
    <url>/2020/08/28/codeforces-666-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1397/problem/D" target="_blank" rel="noopener">D. Stoned Game</a> </p>
<p>题意</p>
<p>给出n堆石子</p>
<p>每堆石子有ai个石子</p>
<p>现在两个人轮流取某个非0的石堆中的1个石子</p>
<p>但是不能取上一轮对手取的那堆石子</p>
<p>谁不能再取出石子则输掉比赛</p>
<p>问谁赢</p>
<p>题解</p>
<p>是一个关于奇偶博弈和制高点的博弈</p>
<p><a href="https://blog.csdn.net/DevourPower/article/details/108315229" target="_blank" rel="noopener">参考题解</a></p>
<p>若没有“不能取上一轮对手取的那堆石子”这个条件则</p>
<p>就是普通的奇偶博弈</p>
<p>但是加入这个条件后就形成了制高点 先手能强制占领优势局面不变</p>
<p>所以当(sum-max&lt;max)时先手可以一直拿最大堆的石子 必胜</p>
<p>否则通过sum的奇偶性判断 若sum为奇数</p>
<p>先手一直从当前剩下最多且能拿的石子堆中拿 最后先手必胜</p>
<p>否则后手必胜</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line">ll data[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    ll n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)<span class="built_in">cout</span>&lt;&lt;(n<span class="number">-1</span>)*data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n-data[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)<span class="built_in">cout</span>&lt;&lt;-n*data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;-n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;data[i]&lt;&lt;endl;</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#667-F</title>
    <url>/2020/09/16/codeforces-667-F/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1409/F" target="_blank" rel="noopener">F. Subsequences of Length Two</a> </p>
<p>题意</p>
<p>给出一个长为n的串s(n&lt;200)和一个只有两个字符的串t</p>
<p>一次修改可以将s串中的某个字符变成任意其他字符</p>
<p>要求在不超过k次修改的情况下 使s中等于t的子序列最多</p>
<p>题解</p>
<p>n&lt;200可以考虑$n^3$ 的dp</p>
<p>最初想到dp(pos,修改成t[0]的次数,修改成t[1]的次数) dp值表示以pos未结尾有多少个子序列=t</p>
<p>后来根据题解设dp(pos,修改次数,到pos前s中有多少个字符=t[0])</p>
<p>同样dp值表示以pos未结尾有多少个子序列=t;</p>
<p>那么存在三种情况下的状态转移</p>
<p>e0=s[i]==t[0]; </p>
<p>e1=s[i]==t[1];</p>
<ul>
<li>不修改:dp(i+1,c,cnt+e0)=max(self,dp(i,c,cnt)+e1?cnt:0);</li>
<li>修改成t[0]：dp(i+1,c+1,cnt+1)=max(self,dp(i,c,cnt));</li>
<li>修改成t[1]：dp(i+1,c+1,cnt)=max(self,dp(i,c,cnt)+cnt);</li>
</ul>
<p>可以将t[0]==t[1]的情况单独考虑 也可以直接在转移中处理</p>
<p>先将dp初始化为-inf 无法转移到的状态直接跳过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e18</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll dp[<span class="number">205</span>][<span class="number">205</span>][<span class="number">205</span>];<span class="comment">///pos,changetime,num of t[1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n,k;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">string</span> s,t;<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t[<span class="number">0</span>]==t[<span class="number">1</span>])&#123;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k&amp;&amp;s[i]!=t[<span class="number">0</span>])cnt++,k--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==t[<span class="number">0</span>])cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=cnt*(cnt<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++)dp[i][j][k]=-Max;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">///dp第一维从1到n 有实际意义</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;=<span class="built_in">min</span>(k,i);c++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> cnt=<span class="number">0</span>;cnt&lt;=i;cnt++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][c][cnt]&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">///此处若不将非法点跳过可能会把 cnt&gt;修改次数+s[i]==t[0]个数的情况错误更新</span></span><br><span class="line">                    <span class="keyword">int</span> e0=s[i]==t[<span class="number">0</span>],e1=s[i]==t[<span class="number">1</span>];</span><br><span class="line">                    dp[i+<span class="number">1</span>][c][cnt+e0]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][c][cnt+e0],dp[i][c][cnt]+(e1?cnt:<span class="number">0</span>));</span><br><span class="line">                    <span class="keyword">if</span>(c&lt;k)&#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][c+<span class="number">1</span>][cnt+<span class="number">1</span>]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][c+<span class="number">1</span>][cnt+<span class="number">1</span>],dp[i][c][cnt]);</span><br><span class="line">                        dp[i+<span class="number">1</span>][c+<span class="number">1</span>][cnt]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][c+<span class="number">1</span>][cnt],dp[i][c][cnt]+cnt);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;=k;c++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> cnt=<span class="number">0</span>;cnt&lt;=n;cnt++)ans=<span class="built_in">max</span>(dp[n][c][cnt],ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#668-D</title>
    <url>/2020/09/24/codeforces-668-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1405/problem/D" target="_blank" rel="noopener">D. Tree Tag</a> </p>
<p>题意</p>
<p>有两个人A/B在一颗n个点n-1条边的树上</p>
<p>A在a点，B在b点</p>
<p>他们轮流行动，每次行动A可以移动最多da长度的距离</p>
<p>B则最多移动db长度的距离</p>
<p>问A先手能否追到B</p>
<p>题解</p>
<p>A能追到B有且仅有三种情况</p>
<ul>
<li><p>A第一次就能到达B的位置即 dis A to B&lt;=da</p>
</li>
<li><p>A的最大移动距离&gt;=树的直径/2 ,只要A到达树直径的中心点上无论B怎么走都能抓到他</p>
</li>
<li><p>2倍A的最大移动距离&gt;=B的移动距离,B为了和A保持距离</p>
<p>B会被A逼到角落使B不得不往A的方向跳跃 此时B必定落在A的移动范围内</p>
</li>
</ul>
<p>对于求树的直径 先从任意一点到达它的最远端p 再从p跳到p的最远端p’ 两者距离为树的直径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max];</span><br><span class="line"><span class="keyword">int</span> Twopoint,fardis,farpoint;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa,<span class="keyword">int</span> dis,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now==to)Twopoint=dis;</span><br><span class="line">    <span class="keyword">if</span>(dis&gt;fardis)&#123;</span><br><span class="line">        fardis=dis;</span><br><span class="line">        farpoint=now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dfs(i,now,dis+<span class="number">1</span>,to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,a,da,b,db;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;da&gt;&gt;db;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v;<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            mp[u].push_back(v);</span><br><span class="line">            mp[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        fardis=<span class="number">0</span>,farpoint=a;</span><br><span class="line">        dfs(a,<span class="number">0</span>,<span class="number">0</span>,b);</span><br><span class="line">        <span class="keyword">if</span>(Twopoint&lt;=da)<span class="built_in">cout</span>&lt;&lt;<span class="string">"Alice"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//int now=farpoint;</span></span><br><span class="line">            dfs(farpoint,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(fardis&lt;=<span class="number">2</span>*da||<span class="number">2</span>*da&gt;=db)<span class="built_in">cout</span>&lt;&lt;<span class="string">"Alice"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Bob"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)mp[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dfs &amp; bfs</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#667-E</title>
    <url>/2020/09/09/codeforces-667-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1409/problem/E" target="_blank" rel="noopener">E. Two Platforms</a> </p>
<p>题意</p>
<p>在二维直角坐标中给出n个球的坐标</p>
<p>以及两块长为k的板子 要求在二维平面中平行于x轴放置两块板子</p>
<p>n个球垂直于x轴落下</p>
<p>问这两个板子接到最多几个球</p>
<p>题解</p>
<p><a href="https://www.cnblogs.com/ygxcj/p/13620184.html" target="_blank" rel="noopener">参考题解</a></p>
<p>实际上我们只关心n个球的x坐标</p>
<p>于是对n个球的x坐标排序</p>
<p>显然球落到板子边界时可能存在最优解</p>
<p>于是我们设计dp </p>
<p>求出第i个球落到一块板子的右端点时 这个板子最多能接住几个球</p>
<p>记L[i]作为记录从第1个点到第i个点之间长度为k的平台能保存的最多的点 </p>
<p>求出第i个球落到一块板子的左端点时 这个板子最多能接住几个球</p>
<p>记R[i]作为记录从第n个点往前到第i个点之间长度为k的平台能保存的最多的点数 </p>
<p> 于是最后答案为ans=max(ans,L[i]+R[i+1])</p>
<p>由于L[i]是以第i个球作为右端点 R[i+1]以第i+1个点为左端点</p>
<p>所以i和i+1个球有同一个x (重叠) 也不会重复统计</p>
<p>对求出第i个球落到一块板子的左/右端点时 这个板子最多能接住几个球</p>
<p>这个问题可以用单调队列解决</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll x[Max],L[Max],R[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k,y;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;x[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;y;</span><br><span class="line">        sort(x,x+n);</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!q.empty()&amp;&amp;q.front()&lt;x[i]-k)q.pop();</span><br><span class="line">            q.push(x[i]);</span><br><span class="line">            L[i]=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)L[i]=<span class="built_in">max</span>(L[i],L[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!q.empty()&amp;&amp;q.front()&gt;x[i]+k)q.pop();</span><br><span class="line">            q.push(x[i]);</span><br><span class="line">            R[i]=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>)R[i]=<span class="built_in">max</span>(R[i],R[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        R[n]=<span class="number">0</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)ans=<span class="built_in">max</span>(ans,R[i+<span class="number">1</span>]+L[i]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#670-D</title>
    <url>/2020/09/18/codeforces-670-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1406/problem/D" target="_blank" rel="noopener">D. Three Sequences</a> </p>
<p>题意</p>
<p>给出一个长度为n&lt;1e5的数组a</p>
<p>要求构造出两个数组b和c，使得满足以下条件：</p>
<ul>
<li>b数组非减</li>
<li>c数组非增</li>
<li>bi+ci=ai</li>
</ul>
<p>多组询问</p>
<p>每次将数组a的区间[L,R]的数+x</p>
<p>问能构造出两个数组中最大的数max(c1,bn)最小是多少</p>
<p>题解</p>
<p>根据如下方式贪心构造数组c和b：</p>
<ul>
<li><p>b数组非减</p>
<p>那么$a_i&gt;a_{i-1}$时令$c_i=c_{i+1}$</p>
<p>则有  $b_i&gt;b_{i-1}$ </p>
</li>
<li><p>c数组非增</p>
<p>那么$a_i&lt;a_{i-1}$时令$b_i=b_{i+1}$</p>
<p>则有  $c_i&lt;c_{i-1}$</p>
</li>
</ul>
<p>求b1到bn的增量为$sum=∑_{i=2}^n max(0,a_i−a_{i−1}) $</p>
<p> 于是对于$b_1=a_1-c_1,b_n=b_1+sum$</p>
<p>那么有$max(c_1,b_n)=max(c_1,a_1-c_1+sum)$</p>
<p>为了让最大值最小 $c_1=(a_1-sum)/2$ </p>
<p>对于每次询问将a的区间[L,R]的数+x</p>
<p>考虑到我们求得答案所需要的量</p>
<p>实际上只会改变$a_L-a_{L-1},a_{R+1}-a_R$ 以及a1(可能会被改变)</p>
<p>所以每次询问更新a1和sum就能O1求出解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll data[Max],de[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)de[i]=data[i]-data[i<span class="number">-1</span>],sum+=<span class="built_in">max</span>(<span class="number">0l</span>l,de[i]);</span><br><span class="line">    ll c1=(data[<span class="number">0</span>]+sum)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">max</span>(c1,data[<span class="number">0</span>]+sum-c1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> q;<span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        ll L,R,add;<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;R&gt;&gt;add;L--;</span><br><span class="line">        <span class="keyword">if</span>(L&gt;<span class="number">0</span>&amp;&amp;L&lt;n)sum-=<span class="built_in">max</span>(<span class="number">0l</span>l,de[L]);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;<span class="number">0</span>&amp;&amp;R&lt;n)sum-=<span class="built_in">max</span>(<span class="number">0l</span>l,de[R]);</span><br><span class="line">        <span class="keyword">if</span>(L==<span class="number">0</span>||R<span class="number">-1</span>==<span class="number">0</span>)data[L]+=add;</span><br><span class="line">        de[L]+=add;de[R]-=add;</span><br><span class="line">        <span class="keyword">if</span>(L&gt;<span class="number">0</span>&amp;&amp;L&lt;n)sum+=<span class="built_in">max</span>(<span class="number">0l</span>l,de[L]);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;<span class="number">0</span>&amp;&amp;R&lt;n)sum+=<span class="built_in">max</span>(<span class="number">0l</span>l,de[R]);</span><br><span class="line">        ll c1=(data[<span class="number">0</span>]+sum)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">max</span>(c1,data[<span class="number">0</span>]+sum-c1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#672-D</title>
    <url>/2020/09/28/codeforces-672-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1420/problem/D" target="_blank" rel="noopener">D. Rescue Nibel!</a> </p>
<p>题意</p>
<p>给出n&lt;1e5个区间[Li,Ri]  ,(Li,Ri&lt;1e9)</p>
<p>要求找到k个区间他们有公共点 </p>
<p>问有多少组区间 (每组k个)满足要求</p>
<p>题解</p>
<p>有关区间统计问题 想到差分前缀 按端点排序 和离散化</p>
<p>我们定义P(x)为覆盖x点的区间有多少个</p>
<p>定义S(x)为以x为起点的区间有多少个</p>
<p>由于区间端点值的范围较大而区间个数很小 可以离散化左右端点</p>
<p>然后对于每个区间的端点值Li处 Psum[Li]++ , Ri处Psum[Ri+1]–;</p>
<p>对Psum求前缀和 那么对于Psum[i] 就相当于覆盖i点的区间有多少个</p>
<p>对于S(x)可以在离散化后直接统计记为Cnt[i]</p>
<p>那么以一个点x作为起始点 求有多少组区间可以满足他们的公共点包括x</p>
<p>那么对于这个点对答案产生的贡献=C(Psum[x],k)-C(Psum[x]-Cnt[x],k)</p>
<p>减去C(Psum[x]-Cnt[x],k)是因为 </p>
<p>统计的标准是以x作为起始点有多少组区间可以满足他们的公共点包括x</p>
<p>那么Psum[x]-Cnt[x]个区间虽然在x处有公共点但是不以x为起始点</p>
<p>它们会在以y,(y&lt;x)为起始点时被统计入答案 所以要减去 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line">ll fac[Max],inv[Max];</span><br><span class="line"><span class="keyword">int</span> Psum[Max],Cnt[Max];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span>&#123;</span><span class="keyword">int</span> L,R;&#125;seg[Max];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%Mod;</span><br><span class="line">        x=x*x%Mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Max;i++)fac[i]=fac[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">    inv[Max]=qpow(fac[Max],Mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Max<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;<span class="keyword">return</span> n&gt;=m?fac[n]*inv[m]%Mod*inv[n-m]%Mod:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;data;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    ll ans=<span class="number">0</span>;init();</span><br><span class="line">    <span class="comment">///cout&lt;&lt;C(3,1)&lt;&lt;" "&lt;&lt;C(1,3)&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> n,k;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> L,R;<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;R;</span><br><span class="line">        seg[i]=&#123;L,R&#125;;</span><br><span class="line">        data.push_back(L);</span><br><span class="line">        data.push_back(R);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(data.<span class="built_in">begin</span>(),data.<span class="built_in">end</span>());</span><br><span class="line">    data.erase(unique(data.<span class="built_in">begin</span>(),data.<span class="built_in">end</span>()),data.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        seg[i].L=lower_bound(data.<span class="built_in">begin</span>(),data.<span class="built_in">end</span>(),seg[i].L)-data.<span class="built_in">begin</span>();</span><br><span class="line">        seg[i].R=lower_bound(data.<span class="built_in">begin</span>(),data.<span class="built_in">end</span>(),seg[i].R)-data.<span class="built_in">begin</span>();</span><br><span class="line">        Cnt[seg[i].L]++;Psum[seg[i].L]++,Psum[seg[i].R+<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len=data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)Psum[i]+=Psum[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        ans=(Mod+ans+C(Psum[i],k)-C(Psum[i]-Cnt[i],k))%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>离散化</tag>
        <tag>差分前缀</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#672-C</title>
    <url>/2020/09/28/codeforces-672-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1420/problem/C2" target="_blank" rel="noopener">C2. Pokémon Army (hard version)</a> </p>
<p>题意</p>
<p>给出两两互不相同的数组a (长度&lt;3e5)</p>
<p>要求从a中取出一个长度为k子序列b</p>
<p>使得val=b1-b2+b3-b4…bk 的值最大 </p>
<p>多组询问 每次交换两个位置上的数</p>
<p>输出交换后最大的val</p>
<p>题解</p>
<p>easy version 解决后 发现能构成最大val的子序列b</p>
<p>一定是取数组a中连续出现的极大值，极小值，极大值…..</p>
<p>那么这个val值它的含义就变成了 所有谷底到峰顶的高度差之和</p>
<p>即 $∑_{i=1}^nmax(0,a[i]-a[i-1])$ </p>
<img src="/.io//timg.gif" data-original="example.png">

<p>将某个数组a抽象成上图连续曲线</p>
<p>那么val=红线处高度差之和</p>
<p>那么多组询问交换两个位置(L,R)上的数 输出val就容易操作了</p>
<p>减去a[L]和a[R]的贡献 交换后在加上各自的贡献</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"></span><br><span class="line">ll data[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,q;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">        data[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">        ll ans=<span class="number">0</span>;data[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans+=<span class="built_in">max</span>(<span class="number">0l</span>l,data[i]-data[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="keyword">int</span> L,R;<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;R;</span><br><span class="line">            <span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans-=<span class="built_in">max</span>(<span class="number">0l</span>l,data[L]-data[L<span class="number">-1</span>]);</span><br><span class="line">            ans-=<span class="built_in">max</span>(<span class="number">0l</span>l,data[L+<span class="number">1</span>]-data[L]);</span><br><span class="line">            <span class="keyword">if</span>(R&gt;L+<span class="number">1</span>)ans-=<span class="built_in">max</span>(<span class="number">0l</span>l,data[R]-data[R<span class="number">-1</span>]);</span><br><span class="line">            ans-=<span class="built_in">max</span>(<span class="number">0l</span>l,data[R+<span class="number">1</span>]-data[R]);</span><br><span class="line">            swap(data[L],data[R]);</span><br><span class="line">            ans+=<span class="built_in">max</span>(<span class="number">0l</span>l,data[L]-data[L<span class="number">-1</span>]);</span><br><span class="line">            ans+=<span class="built_in">max</span>(<span class="number">0l</span>l,data[L+<span class="number">1</span>]-data[L]);</span><br><span class="line">            <span class="keyword">if</span>(R&gt;L+<span class="number">1</span>)ans+=<span class="built_in">max</span>(<span class="number">0l</span>l,data[R]-data[R<span class="number">-1</span>]);</span><br><span class="line">            ans+=<span class="built_in">max</span>(<span class="number">0l</span>l,data[R+<span class="number">1</span>]-data[R]);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>实现</tag>
        <tag>贪心</tag>
        <tag>问题转化</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#673-C</title>
    <url>/2020/10/02/codeforces-673-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1417/problem/C" target="_blank" rel="noopener">C. k-Amazing Numbers</a> </p>
<p>题意</p>
<p>给出一个长度为n&lt;1e5的数组a (0&lt;ai&lt;=n)</p>
<p>对于每个长度为k的子区间都存在的最小的数为ans[i]</p>
<p>输出k从1到n对应的ans[i]</p>
<p>​    </p>
<p>题解</p>
<p>对于”求每个长度为k的子区间都存在的最小的数”不好直接处理</p>
<p>不妨先考虑相同数之间最少需要多长的k才能都包含到 </p>
<p>因为对于一个数A它成为所有长度为k的子区间都存在的数 一定要满足 </p>
<p>任意一个区间都有A 那么就要求对应区间长度k&gt;=max(相邻两个A的间隔)</p>
<p>所有长度为k+1的子区间都存在的最小的数=min(所有长度为k+1的子区间都存在的数,对于所有长度为k的子区间都存在的最小的数)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> data[Max],ans[Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pos[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans[i]=<span class="number">1e9</span>,pos[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">            pos[data[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">/// 枚举最小的数</span></span><br><span class="line">            <span class="keyword">if</span>(pos[i].empty())<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> dis=<span class="built_in">max</span>(pos[i].front(),n-pos[i].back()+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;pos[i].<span class="built_in">size</span>();j++)dis=<span class="built_in">max</span>(dis,pos[i][j]-pos[i][j<span class="number">-1</span>]);</span><br><span class="line">            ans[dis]=<span class="built_in">min</span>(ans[dis],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)ans[i]=<span class="built_in">min</span>(ans[i<span class="number">-1</span>],ans[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i]==<span class="number">1e9</span>)<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>实现</tag>
        <tag>问题转化</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#673-E</title>
    <url>/2020/10/04/codeforces-673-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1417/problem/E" target="_blank" rel="noopener">E. XOR Inverse</a> </p>
<p>题意</p>
<p>给出一个长度为n&lt;3e5的数组a </p>
<p>求一个x使得 bi=ai^x得到 新的数组bi</p>
<p>它的逆序对inv个数最少 </p>
<p>输出最小的x和对应数组b 的逆序对个数</p>
<p>​     </p>
<p>题解</p>
<p>当许多数的前x位二进制相同时 决定它们之间是否形成逆序对的就是第x位</p>
<p>比如对于样例8 10 3</p>
<p>变为二进制为 01000 01010 00011</p>
<p>对于第1位二进制 则分为1000 1010 | 0011 </p>
<p>假如x此位为0 那么异或得到的b中 会产生 2个逆序对</p>
<p>假如x此位为1 那么异或得到的b中 会产生 0个逆序对</p>
<p>所以x此为需要为1来减少b数组中的逆序对</p>
<p>根据 1000 1010 的第3位二进制分组 1000 | 1010 它们前两位都相同</p>
<p>假如x此位为0 那么异或得到的b中会产生0个逆序对</p>
<p>假如x此位为1 那么异或得到的b中会产生1个逆序对</p>
<p>所以得到x=8 b数组逆序对为0</p>
<p>上面描述的就是根据每一位上的bit分治递归求解的过程</p>
<p>对于分治分组求逆序对可以先将n个数转化成二进制串插入到字典树中</p>
<p>那么就能直接通过字典树某个结点上记录二进制的前缀相同的串的个数</p>
<p><a href="https://blog.csdn.net/weixin_39778570/article/details/81990417" target="_blank" rel="noopener">字典树介绍</a></p>
<img src="/.io//timg.gif" data-original="example.jpg">



<p>点中的编号记为point </p>
<p>树的空间上限取决于能延伸出多少点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,int&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">1</span>,maxpoint=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">2</span>][Max&lt;&lt;<span class="number">4</span>];</span><br><span class="line">ll sum[<span class="number">2</span>][<span class="number">33</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">point</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">bit</span>=((num&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!tree[<span class="built_in">bit</span>][<span class="built_in">point</span>])tree[<span class="built_in">bit</span>][<span class="built_in">point</span>]=id++;</span><br><span class="line">        <span class="built_in">point</span>=tree[<span class="built_in">bit</span>][<span class="built_in">point</span>];</span><br><span class="line">        mp[<span class="built_in">point</span>].push_back(pos);</span><br><span class="line">        <span class="comment">///a[pos]二进制前缀=从根到当前点</span></span><br><span class="line">        <span class="comment">///mp[point]表示经过这个结点的数有那些</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> <span class="built_in">point</span>,<span class="keyword">int</span> <span class="built_in">bit</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L=tree[<span class="number">0</span>][<span class="built_in">point</span>],R=tree[<span class="number">1</span>][<span class="built_in">point</span>];</span><br><span class="line">    <span class="comment">///左子树表示下一位为0，右子树表示下一位为1;</span></span><br><span class="line">    <span class="keyword">if</span>(L)solve(L,<span class="built_in">bit</span><span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(R)solve(R,<span class="built_in">bit</span><span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!L||!R)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">///若下一位为0/1的数有0个那么显然不存在逆序对</span></span><br><span class="line">    ll inv=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">///按照当前bit位找逆序对，对于此位为0的找在它之前此位为1的数有几个</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos:mp[L])&#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;mp[R].<span class="built_in">size</span>()&amp;&amp;mp[R][cnt]&lt;pos)cnt++;</span><br><span class="line">        inv+=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[<span class="number">0</span>][<span class="built_in">bit</span>]+=inv;</span><br><span class="line">    <span class="comment">///若x这一位为0,即不取反(异或后0变1,1变0)则会多inv个逆序对</span></span><br><span class="line">    sum[<span class="number">1</span>][<span class="built_in">bit</span>]+=<span class="number">1l</span>l*mp[R].<span class="built_in">size</span>()*mp[L].<span class="built_in">size</span>()-inv;</span><br><span class="line">    <span class="comment">///若x这一位为1,即取反 则会多 (这一位为0的个数)*(这一位为1的个数)-inv</span></span><br><span class="line">    <span class="comment">///可以理解成 每对(0,1)连线-原来已经有的(1,0)边剩下的就是正序数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        add(temp,i);</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">0</span>,<span class="number">31</span>);</span><br><span class="line">    ll inv=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        inv+=<span class="built_in">min</span>(sum[<span class="number">0</span>][i],sum[<span class="number">1</span>][i]);</span><br><span class="line">        <span class="comment">///取产生逆序对少的加到总数上</span></span><br><span class="line">        <span class="keyword">if</span>(sum[<span class="number">1</span>][i]&lt;sum[<span class="number">0</span>][i])x+=(<span class="number">1l</span>l&lt;&lt;i);</span><br><span class="line">        <span class="comment">///若这一位取反产生的逆序对少那么x这一位二进制为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;inv&lt;&lt;<span class="string">" "</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>位运算</tag>
        <tag>逆序对</tag>
        <tag>分治</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#674-D</title>
    <url>/2020/09/28/codeforces-674-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1426/D" target="_blank" rel="noopener">D. Non-zero Segments</a> </p>
<p>题意</p>
<p>给出一个长度为n&lt;1e5的数组a (0&lt;|ai|&lt;1e9且)</p>
<p>求至少要插入多少个数使得 不存在 子区间和为0</p>
<p>​    </p>
<p>题解</p>
<p>贪心的想若有多个区间和为0</p>
<p>那么我们需要在尽量多的区间公共处插入大数那样操作的次数最少</p>
<p>对于找到区间和为0的区间 可以用set或map 存之前出现过的前缀和</p>
<p>若当前的前缀和 pre在容器中出现 则说明这两个前缀和之间的子区间和为0</p>
<p>那么如何插入能符合上述贪心过程能减少最多和为0的区间</p>
<p>当遇到一个前缀和在容器中已经出现 则向当前位置插入一个非常大的数</p>
<p>并清空容器 并将前缀置为当前数的值</p>
<img src="/.io//timg.gif" data-original="example.png">





<p>为什么这样插入符合要求，观察上图 </p>
<p>一种颜色表示一个和为0的区间的左右端点</p>
<p>我们最先遇到红色区间的右端点处要插入大数，插入后整个数组被这个数隔开</p>
<p>不会再存在区间跨越这个数且和为0</p>
<p>也就是说插入后 黄色 绿色区间和一定不为0 那就符合我们的贪心策略了</p>
<p>这种方法因为插入的是为0区间的最右侧 </p>
<p>所以无论是否存在和为0的区间与当前区间有交集 </p>
<p>它都能一次操作后减少最多个和为0的区间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"></span><br><span class="line">ll data[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;ll sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">    <span class="built_in">set</span>&lt;ll&gt;pre;ll Psum=<span class="number">0</span>;pre.insert(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        Psum+=data[i];</span><br><span class="line">        <span class="keyword">if</span>(pre.count(Psum))&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            pre.<span class="built_in">clear</span>();</span><br><span class="line">            pre.insert(<span class="number">0</span>);</span><br><span class="line">            Psum=data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        pre.insert(Psum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#674-F</title>
    <url>/2020/09/30/codeforces-674-F/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1426/F" target="_blank" rel="noopener">F. Number of Subsequences</a> </p>
<p>题意</p>
<p>给出一个长度为2e5的字符串只含有a,b,c,? 四个字符</p>
<p>可以将”?”替换成a/b/c,</p>
<p>问所有情况下 有多少子序列为”abc”</p>
<p>对于第一个样例：</p>
<p>ac?b?c 共有 24个”abc”子序列</p>
<ul>
<li>“acabac” — there are 2 subsequences “abc”,</li>
<li>“acabbc” — there are 4 subsequences “abc”,</li>
<li>“acabcc” — there are 4 subsequences “abc”,</li>
<li>“acbbac” — there are 2 subsequences “abc”,</li>
<li>“acbbbc” — there are 3 subsequences “abc”,</li>
<li>“acbbcc” — there are 4 subsequences “abc”,</li>
<li>“accbac” — there is 1 subsequence “abc”,</li>
<li>“accbbc” — there are 2 subsequences “abc”,</li>
<li>“accbcc” — there are 2 subsequences “abc”.</li>
</ul>
<p>题解</p>
<p><a href="https://www.cnblogs.com/MrIsland/p/13752120.html" target="_blank" rel="noopener">参考题解</a></p>
<p>设计dp(i,char) 表示第i个字符为b/c 时前i个字符构成的子序列ab/abc有几个</p>
<p>单独统计a的前缀数量和‘?’的前缀数量(记为q) </p>
<ul>
<li><p>当这一位的字符为‘a’的时候, 只有a的数量会发生变化。</p>
<p>这里需要思考的是，‘a’字符的变化不只是单纯的+1，而是$3^q$, q 为这个位置之前的‘?’字符的个数。 </p>
</li>
<li><p>当这一位的字符为‘b’的时候 , 只有dp(i,b),(即ab )的数量+a；</p>
</li>
<li><p>当这一位的字符为‘c’的时候 , 只有dp(i,c),(即abc)的数量+b;</p>
</li>
<li><p>当这一位的字符为‘?’的时候 , dp(i,c)=dp(i,c)×3+b,dp(i,b)×3+a,a=3×a+$3^q$;</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[Max][<span class="number">2</span>];<span class="comment">///dp(i,b)和dp(i,c)</span></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%Mod;</span><br><span class="line">        x=x*x%Mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> s;<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    ll a=<span class="number">0</span>,q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'a'</span>)&#123;</span><br><span class="line">            a=(a+qpow(<span class="number">3</span>,q))%Mod;</span><br><span class="line">            <span class="comment">///继承前一项的a同时这个a会产生的贡献=前面的?产生的所有子串数个</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'b'</span>)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][<span class="number">0</span>]+a)%Mod;</span><br><span class="line">            <span class="comment">///继承前一项同时以b为结尾的'ab'子序列多了a个</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'c'</span>)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>]=(dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>])%Mod;</span><br><span class="line">            <span class="comment">///继承前一项同时以c为结尾的'abc'子序列多了dp[i-1][0]个</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>]=(dp[i<span class="number">-1</span>][<span class="number">1</span>]*<span class="number">3l</span>l%Mod+dp[i<span class="number">-1</span>][<span class="number">0</span>])%Mod;</span><br><span class="line">            <span class="comment">///这一位为?那会导致前面的abc的个数多3倍并且当?变为c时子序列abc的个数多了dp[i-1][0]个</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][<span class="number">0</span>]*<span class="number">3l</span>l%Mod+a)%Mod;</span><br><span class="line">            <span class="comment">///这一位为?那会导致前面的ab的个数多3倍并且当?变为b时子序列ab的个数多了a个</span></span><br><span class="line">            a=(<span class="number">3l</span>l*a%Mod+qpow(<span class="number">3</span>,q))%Mod;</span><br><span class="line">            <span class="comment">///这一位为?那会导致前面的a的个数多3倍并且当?变为a时会增加qpow(3,q)个a</span></span><br><span class="line">            <span class="comment">///比如a?? 共有3^2个字符串,以?=a为结尾的字符串有3^1个字符串那么最后一位?对a个数的贡献+3^1</span></span><br><span class="line">            q++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#674-E</title>
    <url>/2020/09/30/codeforces-674-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1426/E" target="_blank" rel="noopener">E. Rock, Paper, Scissors</a> </p>
<p>题意</p>
<p>AB两人玩n轮猜拳</p>
<p>A会出a1次石头a2次剪刀a3次布</p>
<p>A会出b1次石头b2次剪刀b3次布</p>
<p>问A的最小胜场和最大胜场</p>
<p>题解</p>
<p>最大胜场贪心求解 maxn=min(a[2],b[3])+min(a[1],b[2])+min(a[3],b[1]);</p>
<p>最小胜场可以将问题转化为最大流问题</p>
<img src="/.io//timg.gif" data-original="example1.png">



<p>也可以贪心考虑：结合下图和文字描述</p>
<img src="/.io//timg.gif" data-original="example2.png">



<p>首先需要知道A的最小胜场次数只会是A出1种拳时产生 不会存在A出布胜同时A出剪刀胜</p>
<p>就比如上图若B的S+P&lt;A的P那么只能用B的R来填补A的P导致Awin</p>
<p>所以只需要分别求A出剪刀/石头/布取胜种最大的情况</p>
<p>minn=max({0,a[1]-b[3]-b[1],a[2]-b[2]-b[1],a[3]-b[3]-b[2]})</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>],b[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)<span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="built_in">min</span>(a[<span class="number">1</span>],b[<span class="number">2</span>])+<span class="built_in">min</span>(a[<span class="number">2</span>],b[<span class="number">3</span>])+<span class="built_in">min</span>(a[<span class="number">3</span>],b[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;maxn&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> minn=<span class="built_in">max</span>(&#123;<span class="number">0</span>,a[<span class="number">1</span>]-b[<span class="number">3</span>]-b[<span class="number">1</span>],a[<span class="number">2</span>]-b[<span class="number">2</span>]-b[<span class="number">1</span>],a[<span class="number">3</span>]-b[<span class="number">3</span>]-b[<span class="number">2</span>]&#125;);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;minn&lt;&lt;<span class="string">" "</span>&lt;&lt;maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#675-D</title>
    <url>/2020/10/18/codeforces-675-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1422/D" target="_blank" rel="noopener">D. Returning Home</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个n×n的网格图(n&lt;1e5)</p>
<p>要求从$(S_x,S_y)$走到$(F_x,F_y)$ </p>
<p>只能上下左右走格子 消耗一单位体力</p>
<p>有m&lt;1e5个特殊点</p>
<p>若当前位置处于和m个特殊点中某一个同一行或同一列</p>
<p>则可以从这个位置瞬移到这个特殊点 瞬移不耗费体力</p>
<p>问最少消耗多少体力</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>特殊点的存在使得一行或者一列等效成一个点</p>
<ul>
<li>将特殊点所在列中的点等效成同一点时 </li>
</ul>
<p>从某个特殊点到达下一个相邻的特殊点所需要的体力=两个特殊点的行数差</p>
<ul>
<li>将特殊点所在行中的点等效成同一点时</li>
</ul>
<p>从某个特殊点到达下一个相邻的特殊点所需要的体力=两个特殊点的列数差</p>
<p>注意我们只考虑相邻两个特殊点的建边</p>
<p>假如特殊点有A-&gt;B,B-&gt;C 若从A-&gt;C不会比A-&gt;B-&gt;C更优 </p>
<p>这步就优化了任意两点建边的冗余</p>
<p>两个相邻特殊点的最短距离出现在上述两种情况中</p>
<p>所以相邻特殊点需要建两条边：</p>
<p>将一行缩成一点在列上移动/一列缩成一点在行上移动</p>
<p>注意初始位置和终点可能不经过任意一个特殊点时存在最优解</p>
<p>所以起始点到终点需要直接建立一条边</p>
<p>建完图后就已经把问题转化成最短路问题 可以直接使用Dijsktra算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"></span><br><span class="line">ll data[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;ll sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">    <span class="built_in">set</span>&lt;ll&gt;pre;ll Psum=<span class="number">0</span>;pre.insert(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        Psum+=data[i];</span><br><span class="line">        <span class="keyword">if</span>(pre.count(Psum))&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            pre.<span class="built_in">clear</span>();</span><br><span class="line">            pre.insert(<span class="number">0</span>);</span><br><span class="line">            Psum=data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        pre.insert(Psum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#677-G</title>
    <url>/2020/10/30/codeforces-677-G/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1433/G" target="_blank" rel="noopener">G. Reducing Delivery Cost</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出n&lt;1000个点m&lt;1000条边的无向图</p>
<p>现在只能从m条边中删去一条边</p>
<p>求删去某条边后使得k个点对间的最短路和最短</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>由于n和m都只有1000 首先想到的就是$Onmlogn$</p>
<p>若考虑某对点的最短路，在删除某条边后会对它们的最短路有什么影响比较困难</p>
<p>应该反过来考虑 先枚举删除某条边再求这对点的最短路就比较容易了</p>
<p>于是Om枚举删除的边 然后对于每条删除边两个端点(设为(u,v) )跑Dijkstra </p>
<p>求得它们到k个点对的最短路</p>
<p>那么删除这条边后对于一个点对(i,j)而言</p>
<p>它们的之间的最短路=min{dis(i,j),dis(i,u)+dis(v,j),dis(i,v)+dis(u,j) }</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">bool</span> vis[Max],visp[Max][Max];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt;mp[Max],Pair;</span><br><span class="line">ll dis[Max][Max];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> u,v;&#125;edge[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)vis[i]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt;q;</span><br><span class="line">    dis[start][start]=<span class="number">0</span>;</span><br><span class="line">    q.push(&#123;<span class="number">0</span>,start&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        P temp=q.top();q.pop();</span><br><span class="line">        <span class="keyword">int</span> now=temp.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[now])<span class="keyword">continue</span>;</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edges:mp[now])&#123;</span><br><span class="line">            <span class="keyword">int</span> cost=edges.second,to=edges.first;</span><br><span class="line">            <span class="comment">//if(vis[to])continue;</span></span><br><span class="line">            <span class="keyword">if</span>(dis[start][now]+cost&lt;dis[start][to])&#123;</span><br><span class="line">                dis[start][to]=dis[start][now]+cost;</span><br><span class="line">                q.push(&#123;dis[start][to],to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v)swap(u,v);</span><br><span class="line">        <span class="keyword">if</span>(visp[u][v])<span class="keyword">continue</span>;</span><br><span class="line">        visp[u][v]=<span class="number">1</span>;</span><br><span class="line">        mp[u].push_back(&#123;v,w&#125;);</span><br><span class="line">        mp[v].push_back(&#123;u,w&#125;);</span><br><span class="line">        edge[cnt++]=&#123;u,v&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        Pair.push_back(&#123;u,v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)Dijkstra(i);</span><br><span class="line">    ll ans=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cutA=edge[i].u,cutB=edge[i].v;</span><br><span class="line">        ll temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:Pair)&#123;</span><br><span class="line">            <span class="keyword">int</span> a=p.first,b=p.second;</span><br><span class="line">            ll mindis=<span class="built_in">min</span>(dis[a][cutA]+dis[b][cutB],dis[b][cutA]+dis[a][cutB]);</span><br><span class="line">            mindis=<span class="built_in">min</span>(mindis,dis[a][b]);</span><br><span class="line">            temp+=mindis;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#678-D</title>
    <url>/2020/10/18/codeforces-678-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1436/problem/D" target="_blank" rel="noopener">D. Bandit in a City</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个n个点n-1条边的有向树(n&lt;2e5)</p>
<p>每个点有一些居民 ,他们可以选择一条出边进行移动(或留在原地) </p>
<p>晚上强盗从1号点出发,一直走到不能移动 </p>
<p>强盗想抓到更多的人，而居民则不想让他抓到更多的人</p>
<p>问最后强盗能抓到多少人</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p><a href="https://blog.csdn.net/jziwjxjd/article/details/109270991" target="_blank" rel="noopener">参考题解</a></p>
<p>若所有居民都在1号点 那么显然最后强盗能抓到最多=round up(total/leaves)</p>
<p>即总人数/叶子结点上取整人数</p>
<p>但是这么做存在问题：有的居民不能从当前的点走到1号点再平均分配</p>
<p>由于这个问题 某些点的子树中居民人数较多那么最后强盗抓到的人数会比</p>
<p>假设所有居民都从1号点出发要多</p>
<p>因为一旦假设的平均值需要这个子树上的居民到1号点(实际则不能到1号点)</p>
<p>再分配给所有叶子结点</p>
<p>说明这以这个点为根的子树人数更多 就算不给它分配一个居民,最后还是它子树内的叶</p>
<p>子节点居民数最大,那么就把问题规模缩小成以这个点为根的子树了(其他儿子就没用了) </p>
<p>如果不存在这种子节点,就存在一种分配方式使得两边尽量平均</p>
<p>此时在以u为根的子树内最大的叶子节点就是$roundup(sum_u/leaves_u)$ </p>
<p>所以最终答案是最大的$roundup(sum_u/leaves_u)$ 值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">ll num[Max];</span><br><span class="line">ll leaves[Max],sz[Max],maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    sz[now]=num[now];</span><br><span class="line">    <span class="keyword">if</span>(mp[now].empty())leaves[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> to:mp[now])&#123;</span><br><span class="line">        dfs(to);</span><br><span class="line">        sz[now]+=sz[to];</span><br><span class="line">        leaves[now]+=leaves[to];</span><br><span class="line">    &#125;</span><br><span class="line">    ll di=sz[now]%leaves[now]?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;sz[now]&lt;&lt;" "&lt;&lt;leaves[now]&lt;&lt;endl;</span></span><br><span class="line">    maxn=<span class="built_in">max</span>(maxn,sz[now]/leaves[now]+di);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v=i;<span class="built_in">cin</span>&gt;&gt;u;</span><br><span class="line">        mp[u].push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>性质发现</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#678-E</title>
    <url>/2020/11/14/codeforces-678-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1436/E" target="_blank" rel="noopener">E. Complicated Computations</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个长度为n&lt;1e5的数组a</p>
<p>求出它所有子串的MEX组成的新数组b的MEX</p>
<p>对于一个给定数组 其MEX是 最小的不出现在数组中的正数</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p><a href="https://www.cnblogs.com/hznumqf/p/13879185.html" target="_blank" rel="noopener">参考博客</a></p>
<p>如 数组a为1 3 2</p>
<p>数组b为 2 2 4 1 1 1</p>
<p>所以答案为3</p>
<p>首先要求出所有子串的MEX 而n为1e5 显然 暴力求解出b数组不可取</p>
<p>但是存在一个事实：对于一个数组 若去除其中重复的数字 剩下 的数组成的MEX</p>
<p>仍然与原来相同</p>
<p>那么我们不需要暴力枚举出所有a的子串求得其MEX</p>
<p>反过来想 我们只需要判断某个数x是否会是某个a的子串的MEX</p>
<p>于是我们枚举x (1~n+1) 每次判断是否存在一个a的子串它的MEX=x</p>
<p>若存在 那么数组b中加入 x 最终答案则直接求b的MEX</p>
<p>如果一个区间的MEX=x，那么容易发现只需满足如下条件 ：</p>
<ul>
<li><p>区间中没有出现x</p>
</li>
<li><p>区间中出现了1到x−1</p>
<p>于是 考虑枚举每个以x为端点的子段</p>
</li>
</ul>
<p>比如…. x (1 4 2 4 6) x ….</p>
<p>MEX=x的子段不会出现在一个包含x的子串中 于是满足条件一</p>
<p>对于第二个条件 维护一个权值线段树 </p>
<p>以权值为点 存对应数在原数组中出现的最后位置</p>
<p>因为要确保 两个x 之间存在1到x-1所有数</p>
<p>所以只需要确保 (1,x-1)所以有数最后一次出现的位置在 两个x之间</p>
<p>若符合条件那么 显然 a中存在子串MEX=x 那么x被加入b数组</p>
<p>我们枚举可能存在的MEX=x</p>
<p>判断区间…. x (1 4 2 4 6) x …. 的MEX而不是 …. x (1 4 2) 4 6 x ….的MEX</p>
<p>为什么后者不需要枚举？ 首先我们是在判断x是否会成为a的子串的MEX</p>
<p>于是我们找最有可能出现MEX=x的子串 即夹在两个x之间的子段</p>
<p>他们不包含x且元素最多最有可能包含(1,x-1)所有数</p>
<p>从而减小了暴力枚举a的子串的复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="comment">//#define P pair&lt;ll,ll&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format, ...)                                                                          \</span></span><br><span class="line">&#123;                                                                                                   \</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"\[%s:%d] \" format "</span> <span class="string">",                                                        \</span></span><br><span class="line"><span class="string">    __FUNCTION__ , __LINE__, ##__VA_ARGS__);                                                        \</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#else</span></span><br><span class="line"><span class="string">#define DeBug(format,...)</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string">class SegTree&#123;</span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">    #define mid ((L+R)&gt;&gt;1)</span></span><br><span class="line"><span class="string">    #define Leftson now&lt;&lt;1</span></span><br><span class="line"><span class="string">    #define Rightson now&lt;&lt;1|1</span></span><br><span class="line"><span class="string">    struct segtree&#123;int L,R,pos;&#125;;</span></span><br><span class="line"><span class="string">    segtree tree[Max&lt;&lt;2];</span></span><br><span class="line"><span class="string">    void push_up(int now)&#123;</span></span><br><span class="line"><span class="string">        tree[now].pos=min(tree[Leftson].pos,tree[Rightson].pos);</span></span><br><span class="line"><span class="string">        return;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    void build(int L,int R,int now=1)&#123;</span></span><br><span class="line"><span class="string">        tree[now]=&#123;L,R,0&#125;;</span></span><br><span class="line"><span class="string">        //cout&lt;&lt;L&lt;&lt;"</span> <span class="string">"&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line"><span class="string">        if(L==R)return;</span></span><br><span class="line"><span class="string">        //int mid=(L+R)&gt;&gt;1;</span></span><br><span class="line"><span class="string">        build(L,mid,Leftson);</span></span><br><span class="line"><span class="string">        build(mid+1,R,Rightson);</span></span><br><span class="line"><span class="string">        push_up(now);</span></span><br><span class="line"><span class="string">        return;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    void updata(int qL,int qR,int val,int now=1)&#123;</span></span><br><span class="line"><span class="string">        if(qL&lt;=tree[now].L&amp;&amp;qR&gt;=tree[now].R)&#123;</span></span><br><span class="line"><span class="string">            tree[now].pos=val;</span></span><br><span class="line"><span class="string">            return;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if(qL&lt;=tree[Leftson].R)updata(qL,qR,val,Leftson);</span></span><br><span class="line"><span class="string">        if(qR&gt;=tree[Rightson].L)updata(qL,qR,val,Rightson);</span></span><br><span class="line"><span class="string">        push_up(now);return;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    int query(int qL,int qR,int now=1)&#123;</span></span><br><span class="line"><span class="string">        if(qL&gt;qR)return inf;</span></span><br><span class="line"><span class="string">        if(tree[now].R&lt;=qR&amp;&amp;tree[now].L&gt;=qL)return tree[now].pos;</span></span><br><span class="line"><span class="string">        int minnpos=inf;</span></span><br><span class="line"><span class="string">        if(tree[Leftson].R&gt;=qL)minnpos=min(minnpos,query(qL,qR,Leftson));</span></span><br><span class="line"><span class="string">        if(tree[Rightson].L&lt;=qR)minnpos=min(minnpos,query(qL,qR,Rightson));</span></span><br><span class="line"><span class="string">        push_up(now);</span></span><br><span class="line"><span class="string">        return minnpos;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;Val;</span></span><br><span class="line"><span class="string">bool vis[Max];</span></span><br><span class="line"><span class="string">int arr[Max],last[Max];</span></span><br><span class="line"><span class="string">int main()&#123;</span></span><br><span class="line"><span class="string">    //Turnoff;</span></span><br><span class="line"><span class="string">    int n;cin&gt;&gt;n;</span></span><br><span class="line"><span class="string">    Val.build(1,n);</span></span><br><span class="line"><span class="string">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];</span></span><br><span class="line"><span class="string">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="string">        if(arr[i]!=1)vis[1]=1;</span></span><br><span class="line"><span class="string">        if(arr[i]&gt;1&amp;&amp;Val.query(1,arr[i]-1)&gt;last[arr[i]])vis[arr[i]]=1;</span></span><br><span class="line"><span class="string">        last[arr[i]]=i;</span></span><br><span class="line"><span class="string">        Val.updata(arr[i],arr[i],i);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for(int i=2;i&lt;=n+1;i++)&#123;</span></span><br><span class="line"><span class="string">        if(Val.query(1,i-1)&gt;last[i])vis[i]=1;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    int Mex=1;</span></span><br><span class="line"><span class="string">    while(vis[Mex])Mex++;</span></span><br><span class="line"><span class="string">    cout&lt;&lt;Mex&lt;&lt;endl;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>MEX</tag>
        <tag>权值线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#679-C</title>
    <url>/2020/11/04/codeforces-679-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1435/problem/C" target="_blank" rel="noopener">C. Perform Easily</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出6根弦,每根对应一个$a_i$</p>
<p>现在有一个乐谱 每个音符用$b_i$ 表示</p>
<p>例如样例：</p>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">琴弦的值ai：<span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">有几个音符：<span class="number">7</span></span><br><span class="line">每个音符的值bi：<span class="number">13</span> <span class="number">4</span> <span class="number">11</span> <span class="number">12</span> <span class="number">11</span> <span class="number">13</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
</blockquote>
<img src="/.io//timg.gif" data-original="example.png">

<p>每个音符在不同琴弦的对应位置不同 </p>
<p>例如$b_i=13$ 在$a_i=3$的琴弦上 所在位置为$b_i-a_i=10$</p>
<p>定义一个乐谱的难度等于 相距最大的两个音符的位置差</p>
<p>每个音符要在哪根琴弦上弹奏由你来定使得这个乐谱最小的难度</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>利用set模拟</p>
<p>假设最初所有音符都在最后一根琴弦上(ai已经升序排列)</p>
<p>将所有音符以pair(${b_i-a_6,i}$)存入set</p>
<p>于是模拟贪心的过程</p>
<img src="/.io//timg.gif" data-original="example2.png">

<p>每次将最右端即$(b_i-a_x)$ 最小的音符移动到上一根琴弦变为$(b_i-a_{x-1})$</p>
<p>注意$a_x$已经是升序排列 移动到上一根琴弦的音符一定会往左移动</p>
<img src="/.io//timg.gif" data-original="example3.png">

<p>反复操作每次将位置最右的音符往左靠 能使得所有音符相邻间距尽量小</p>
<p>只要每次计算出最左端音符和最右端音符的距离差更新答案即可</p>
<p>这个模拟过程实际上是固定了$(b_i-a_x)$的最大值 贪心移动最小值</p>
<p>“定一值动一值”这种处理方法比较常见且实用 在许多题目中也有类似应用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set</span>&lt;P&gt;st;</span><br><span class="line">ll a[<span class="number">10</span>],b[Max];</span><br><span class="line"><span class="keyword">int</span> id[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    sort(a,a+<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        id[i]=<span class="number">5</span>;<span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">        st.insert(&#123;b[i]-a[id[i]],i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=(*st.rbegin()).first-(*st.<span class="built_in">begin</span>()).first;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> p=st.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> u=(*p).second;</span><br><span class="line">        st.erase(p);</span><br><span class="line">        <span class="keyword">if</span>(!id[u])<span class="keyword">break</span>;</span><br><span class="line">        id[u]--;</span><br><span class="line">        st.insert(&#123;b[u]-a[id[u]],u&#125;);</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,(*st.rbegin()).first-(*st.<span class="built_in">begin</span>()).first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#680-D</title>
    <url>/2020/11/05/codeforces-680-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1445/problem/D" target="_blank" rel="noopener">D. Divide and Sum</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个长度为2n的数组A</p>
<p>要求从中选出一个长度为n的子序列重新排序变为一个非降序的数组p</p>
<p>剩下n个数则重新排列变为一个非升序的数组q</p>
<p>定义这对(p,q)有一个花费为$f(p,q)=∑_{i=1}^n|p_i-q_i|$ </p>
<p>求出这个长度为2n的数组中能产生的所有 (p,q)的花费和 mod 998244353</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>首先题目要求从2n个数中找出n个数重新排序得到一个非降序的数组p和一个非升序的数组q</p>
<p>于是干脆给原数组A排序再讨论</p>
<img src="/.io//timg.gif" data-original="example.png">



<p>现在假定A数组已经升序排列</p>
<p>现在从A数组中取出一个数作为$p_i$ </p>
<p>那么由于p是非递减数列那么$p_{i+1}$~ $p_n$ 一定在$p_i$的右侧</p>
<p>同时取出一个数作为$q_i$</p>
<p>那么由于q是非递增数列那么$q_{i+1}$~ $p_n$ 一定在$p_i$的左侧</p>
<p>有一种比较直观的感受是若$p_i$在A数组中的左侧那么$q_i$就在A数组的右测</p>
<p>反之若$p_i$在A数组的右测那么$q_i$就在A数组的左侧</p>
<img src="/.io//timg.gif" data-original="example2.png">

<p>由于q是非严格递减 p是非严格递增 </p>
<p>所以在A数组中pi的取值往右侧移动时 qi的取值则在往左侧移动</p>
<img src="/.io//timg.gif" data-original="example3.png">

<p>现在假如一个中间点mid=n 它左侧为L区域右侧为R区域,根据这种模糊的感觉</p>
<p>得到假设pi和qi一定会在中点mid的两侧 </p>
<p>若这个假设成立那么无论如何选择n个数组成$q$和$p$ </p>
<p>他们对应的花费$f(p,q)=∑_{i=1}^n|p_i-q_i|$ 总等于 $SumR-SumL$ </p>
<p>即排序后A数组右侧n个数之和-A数组左侧n个数之和</p>
<ul>
<li><p>为什么对于任意一对$(p,q)$ 它的花费$f(p,q)=∑_{i=1}^n|p_i-q_i|$ 总等于 $SumR-SumL$ </p>
<p>假设pi在L区域内 ,qi在R区域内 那么有$p_i-q_i&lt;0$ 变为$L_x-R_y&lt;0$ </p>
<p>取绝对值后得到 $|p_i-q_i|=R_y-L_x$ </p>
<p>假设pi在R区域内 ,qi在L区域内 那么有$p_i-q_i&gt;0$ 变为$R_x-L_y&gt;0$</p>
<p>取绝对值后得到 $|p_i-q_i|=R_x-L_y$ </p>
<p>所以对于任意一对(p,q)总有 $f(p,q)=∑_{i=1}^n|p_i-q_i|= SumR-SumL$ 成立</p>
</li>
<li><p>为什么$p_i$和$q_i$ 一定在mid两侧</p>
<p>假若$p_i$和$q_i$ 都在R区域 那么$p_{i+1}$~$p_n$ 都在R区域</p>
<p>同时$q_1$~$q_i$ 都在R区域 那么R区域共有n+1个数 。这与事实不符</p>
<p>假若假若$p_i$和$q_i$ 都在L区域 那么$p_{1}$~$p_{i}$ 都在L区域</p>
<p>同时$q_{i}$~$q_{n}$ 都在L区域 那么L区域共有n+1个数</p>
</li>
</ul>
<p>于是只要求出可以选出多少对(p,q) 就能直接得到答案</p>
<p>设T为共有多少对(p,q)则 T=C(2n,n) 即从2n个数中选出n个数放入p剩下的自然分组到q</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>; inv[<span class="number">0</span>]=<span class="number">0</span>; ///将<span class="number">0</span>的逆元定为<span class="number">1</span>是因为 求组合数时C(<span class="built_in">n</span>,<span class="number">0</span>)=C(<span class="built_in">n</span>,<span class="built_in">n</span>)=<span class="number">1</span></span><br><span class="line">inv[i]=(<span class="built_in">Mod</span>-<span class="built_in">Mod</span>/i)*inv[<span class="built_in">Mod</span>%i]%<span class="built_in">Mod</span>;</span><br></pre></td></tr></table></figure>

<p>对于组合数求逆元可以先$On$ 递推预处理得到 。顺便提一下组合数公式</p>
<h3 id="C-n-a-n-a-×-n-a"><a href="#C-n-a-n-a-×-n-a" class="headerlink" title="C(n,a)=n!/a!×(n-a)!"></a>C(n,a)=n!/a!×(n-a)!</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll F[Max];</span><br><span class="line">ll arr[Max];</span><br><span class="line">ll inv[Max];</span><br><span class="line">ll C[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;F[<span class="number">1</span>]=<span class="number">1</span>;inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;</span><br><span class="line">        F[i]=F[i<span class="number">-1</span>]*i%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)inv[i]=inv[i]*inv[i<span class="number">-1</span>]%Mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    sort(arr,arr+<span class="number">2</span>*n);ll L=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)L=(L+arr[i])%Mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;<span class="number">2</span>*n;i++)R=(R+arr[i])%Mod;</span><br><span class="line">    ll T=F[<span class="number">2</span>*n]*inv[n]%Mod*inv[n]%Mod;<span class="comment">///C(2n,n)</span></span><br><span class="line">    ll ans=(Mod+R-L)%Mod*T%Mod;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#681-D</title>
    <url>/2020/11/05/codeforces-681-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1443/problem/D" target="_blank" rel="noopener">D. Extreme Subtraction</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个长度为n的数组</p>
<p>有两种操作：</p>
<p>1.选择一个前缀 将所有元素-1</p>
<p>2.选择一个后缀 将所有元素-1</p>
<p>问是否能将原数组变为全0数组</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>对数组的区间操作 联想到差分前缀</p>
<p>于是将原数组 转化成与它等价的差分数组</p>
<p>那么对原矩阵的区间操作就变成了对差分矩阵的两个端点操作：</p>
<ul>
<li><p>将 $arr_1$-1 同时将 $arr_{i+1}$ +1 </p>
<p>等价为将差分数组中某个负数变为0 同时将$arr_1$减小相同的量</p>
</li>
<li><p>将$arr_i$-1 同时将$arr_{n+1}$+1</p>
<p>等价为将差分数组中某个正数变为0 同时将$arr_n$变大(实际上我们不关心$arr_n$)</p>
</li>
</ul>
<p>发现 若能通过上述两个操作将差分数组变为全0数组 那么还原成原数组就为全0数组</p>
<p>于是 直接判断若差分数组中$arr_1$ 足矣”填平”数组中所有负数 那么就输出YES </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">2 3 1 3 2 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll diff[Max],arr[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        diff[<span class="number">0</span>]=diff[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">            diff[i]=arr[i]-arr[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(diff[i]&lt;<span class="number">0</span>)sum+=diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum+arr[<span class="number">1</span>]&lt;<span class="number">0</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)cout&lt;&lt;per[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)cout&lt;&lt;suf[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>问题转化</tag>
        <tag>差分前缀</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#681-E</title>
    <url>/2020/11/10/codeforces-681-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1443/problem/E" target="_blank" rel="noopener">E. Long Permutation</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个长度为n的排列 :1,2,3,4,5,6…,n (n&lt;2e5)</p>
<p>有q次操作：(q&lt;2e5)</p>
<p>1 l r 询问区间[L,R]内的元素和</p>
<p>2 x 将当前排列的字典序变大 x (x&lt;1e5)</p>
<p>例如 ：</p>
<p>1 2 3 4 5  字典序=1</p>
<p>1 2 3 5 4  字典序=2</p>
<p>1 2 4 3 5  字典序=3</p>
<p>…</p>
<p>对于 1 2 3 4 5 的字典序变大2</p>
<p>则新的排列为 1 2 4 3 5</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>首先需要意识到 一个长度为n的排列 共有n! 个</p>
<p>这意味着 最差情况下 原排列的字典序会增大 xq次 也就是增大2e10</p>
<p>而只需要15个数 就能产生大于2e10的排列个数</p>
<p>意思是 最差情况下 增大排列的字典序只会改变最后15位的排列</p>
<p>前面的数 仍保持1 2 3 ….. n-15 不变</p>
<p>于是对区间和的询问可以拆分成两段处理</p>
<p>对于[1,n-15] 前缀和处理</p>
<p>对于[n-15,n] 需要使用到一个黑科技</p>
<h3 id="康托展开-amp-逆康托展开"><a href="#康托展开-amp-逆康托展开" class="headerlink" title="康托展开&amp;逆康托展开"></a>康托展开&amp;逆康托展开</h3><p><a href="https://blog.csdn.net/ltrbless/article/details/87696372" target="_blank" rel="noopener">参考博客</a></p>
<p>为了解决 排列 与其字典序的 双映射问题</p>
<p>即 知道排列可以直接求得其 对应字典序大小 (康托展开)</p>
<p>或已知字典序大小和排列长度n 求出对应排列的问题 (逆康托展开)</p>
<img src="/.io//timg.gif" data-original="example.png">

<p>X是排列对应字典序</p>
<p>$a_i$表示此排列从右到左第i位在当前未出现的元素(它左侧的数已经出现)中是排第几个</p>
<p>实际可以类比进制转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******打出1-n的阶乘表*******/</span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jie_cheng</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 0的阶乘为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] * i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**************康托展开****************/</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kangtuo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;  <span class="comment">//注意，因为 12345 是算作0开始计算的，最后结果要把12345看作是第一个</span></span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;<span class="comment">//用来计数的</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &gt; str[j]) tmp++;</span><br><span class="line">            <span class="comment">//计算str[i]是第几大的数，或者说计算有几个比他小的数</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ans += tmp * f[len - i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************康托逆展开**************/</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vec; <span class="comment">//存需要排列的字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev_kangtuo</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">//输出序号为 k 的字符序列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>(), len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">    k--; <span class="comment">// 算的时候是按 12345 是第0位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = k / f[n - i]; <span class="comment">// 第 i 位需要 第 t + 1 大的数</span></span><br><span class="line">        k %= f[n - i];        <span class="comment">//剩下的几位需要提供的排列数</span></span><br><span class="line">        ans += vec[t] ; <span class="comment">//  vec[t] 就是第 t + 1 大的数</span></span><br><span class="line">        vec.erase(vec.<span class="built_in">begin</span>() + t); </span><br><span class="line"><span class="comment">//用过就删了，不用vector用暴力也可以，就是说枚举，然后一个一个的比较大小，并记录有几个没用过的字符且字典序比它小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是康托展开的具体代码 (算法的具体原理参考链接中的博客)</p>
<p>对于本题 需要对最后15个数进行康托展开 求得对应字典序now</p>
<p>对于每次增加它字典序的操作则对now+=x</p>
<p>用逆康托展开求得对应排列 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="comment">//#define P pair&lt;ll,ll&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll sum[Max],p[Max];</span><br><span class="line">ll F[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    F[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)F[i]=F[i<span class="number">-1</span>]*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ConTor</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> Mid)</span></span>&#123;</span><br><span class="line">    ll X=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Mid+<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ll temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j]&gt;p[i])<span class="keyword">continue</span>;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;temp&lt;&lt;" "&lt;&lt;F[n-i]&lt;&lt;endl;</span></span><br><span class="line">        X+=temp*F[n-i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invConTor</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> Mid,ll X)</span></span>&#123;</span><br><span class="line">    X--;ll rest=X;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Mid+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">        vec.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Mid+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num=rest/F[n-i];</span><br><span class="line">        rest=rest%F[n-i];</span><br><span class="line">        p[i]=vec[num];</span><br><span class="line">        vec.erase(vec.<span class="built_in">begin</span>()+num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n,q;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=i;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;ConTor(n,0)&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> Mid=<span class="built_in">max</span>(<span class="number">0</span>,n<span class="number">-15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Mid;i++)sum[i]=sum[i<span class="number">-1</span>]+p[i];</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op;<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l,r;<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            <span class="keyword">if</span>(r&lt;=Mid)<span class="built_in">cout</span>&lt;&lt;sum[r]-sum[l<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l&lt;=Mid)&#123;</span><br><span class="line">                ll temp=sum[Mid]-sum[l<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=Mid+<span class="number">1</span>;i&lt;=r;i++)temp+=p[i];</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ll temp=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)temp+=p[i];</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll x;<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            ll now=ConTor(n,Mid);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;now&lt;&lt;endl;</span></span><br><span class="line">            now+=x;</span><br><span class="line">            invConTor(n,Mid,now);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            for(int i=1;i&lt;=n;i++)cout&lt;&lt;p[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>问题转化</tag>
        <tag>差分前缀</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#682-D</title>
    <url>/2020/11/16/codeforces-682-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1438/problem/D" target="_blank" rel="noopener">D. Powerful Ksenia</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个长度为3&lt;n&lt;1e5的数组a</p>
<p>要求经过最多n次操作后所有元素相等</p>
<p>每次操作为：</p>
<p>选择(i,j,k) 将三个位置上的(ai,aj,ak)替换成 X=ai xor aj xor ak</p>
<p>若能在n次内将所有元素相等输出YES</p>
<p>并输出操作次数和每次操作的三个下标</p>
<p>若不能则输出NO</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>每次操作能将三个数变成相同的数 (a,b,c)-&gt;(x,x,x)</p>
<p>考虑到异或的性质 ：</p>
<ul>
<li>若存在两个数相同 则 a xor a =0</li>
<li>且0 xor x =x 即任意数与0异或为0</li>
</ul>
<p>那么对于n=奇数的情况</p>
<p>我可以将原数组 如：a b c d e f g h i</p>
<p>经过操作变为：a a b b c c x x x</p>
<p>除了后3位相同其余均是两两相同 </p>
<p>那么之后可以根据异或性质操作：</p>
<p>a a b b (c c x) x x  -&gt; a a b b x x x x x</p>
<p>a a (b b x) x x x x -&gt; a a x x x x x x x</p>
<p>(a a x) x x x x x x -&gt; x x x x x x x x x</p>
<p>通过上述构造能在n-2次内将任意长度为奇数的数组a均能变为全部相同的数组</p>
<p>而n为偶数时则需要判断是否能将所有数变为相等</p>
<p>回忆操作过程</p>
<p>将(a,b,c) -&gt; (x,x,x) 其中x= a xor b xor c</p>
<p>发现 a xor b xor c = x xor x xor x = x</p>
<p>所以 对于数组 a b c d  经过操作后 其异或和都不会发生变化</p>
<p>那么 若最初的数组其异或和 不为0那么无论如何操作都不会将所有元素变为相同解</p>
<p>(偶数个相同数异或为0)</p>
<p>若异或和为0 那么随便选出一个数ax</p>
<p>将剩余的奇数个数通过n为奇数情况的构造方式将这n-1个数变为一个相同的数Y</p>
<p>最后Y 一定等于 ax  因为最初数组的异或和为0 </p>
<p>即：a1 xor a2 xor a3 …. xor an =0</p>
<p>那么把ax从左侧取出 则有 ：a1 xor a2 xor a3 …. =ax</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="comment">//#define P pair&lt;ll,ll&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//#define __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format, ...)                                                                            \</span></span><br><span class="line">&#123;                                                                                                   \</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"[%s:%d]"</span> format <span class="string">""</span>,                                            \</span><br><span class="line">    __FUNCTION__ , __LINE__, ##__VA_ARGS__);                                                        \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format,...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">ll mat[Max][Max];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i+j)%<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mat[i][j]%<span class="number">2</span>)mat[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mat[i][j]%<span class="number">2</span>==<span class="number">0</span>)mat[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;mat[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#682-C</title>
    <url>/2020/11/16/codeforces-682-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1438/C" target="_blank" rel="noopener">C. Engineer Artem</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个n×m(m,n&lt;100)的矩阵 其中每个位置有一个数a(i,j)</p>
<p>现在可以选择其中任意几个位置(i,j)使得其数值变为a(i,j) +1</p>
<p>得到一个新的矩阵b(i,j)</p>
<p>问如何构造得到一个任意两个相邻的位置的数值都不相同的矩阵b(i,j)</p>
<p>并输出b(i,j)  </p>
<p>(一定存在一个b(i,j)矩阵满足条件)</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>考虑到对某些位置的数值+1</p>
<p>实际上是改变其奇偶性</p>
<p>那么对于矩阵a 可以将其中的元素改成奇偶交替 就能得到矩阵b了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="comment">//#define P pair&lt;ll,ll&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//#define __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format, ...)                                                                            \</span></span><br><span class="line">&#123;                                                                                                   \</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"[%s:%d]"</span> format <span class="string">""</span>,                                            \</span><br><span class="line">    __FUNCTION__ , __LINE__, ##__VA_ARGS__);                                                        \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format,...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">ll mat[Max][Max];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i+j)%<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mat[i][j]%<span class="number">2</span>)mat[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mat[i][j]%<span class="number">2</span>==<span class="number">0</span>)mat[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;mat[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#683-E</title>
    <url>/2020/12/03/codeforces-683-E/</url>
    <content><![CDATA[<p> <a href="https://codeforces.ml/contest/1446/problem/C" target="_blank" rel="noopener">C. Xor Tree</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出n (1e5)个点，每个点有一个值ai，对于每个点，它将找到其余所有点中与其异或和最小的点，并且与之连上双向边，问最少要在给出数组中删掉多少数才能使得剩余的数经过这样的操作能变成一颗树。 </p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>位运算题目不变的套路就是要想到 按位运算 </p>
<p>根据题目中两点建立边的条件 需要想到</p>
<p>两个数的最高位 不同 时 才有可能建立联系 </p>
<p>所以 按二进制最高位到最低位 逐个 分组</p>
<p>对于第 i 位 为0 的数分成 一组 为1的分成 一组</p>
<p>同一组的数 之间可能建立联系(边) 但具体怎么建 需要继续递归到下一位继续分组 才能看出来</p>
<p>而对于当前情况 若想最终剩余的点能构成数 则需要将 其中一个集合的数 删掉只剩1个</p>
<p>比如 某种情况下 几个数的二进制为：</p>
<p>{1xxxx ，1xxxx，1xxxx}，{0xxxx，0xxxx}</p>
<p>根据最高位分组后 需要将某个集合的数删去只剩1个 </p>
<p>才能迫使他从另一个集合中寻找 和他异或值最小的数建立边</p>
<p>同时这样递归分组也说明了 不会导致多个数之间成环的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="comment">//#define P pair&lt;ll,ll&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format, ...)                                                                            \</span></span><br><span class="line">&#123;                                                                                                   \</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"[%s:%d]"</span> format <span class="string">""</span>,                                            \</span><br><span class="line">    __FUNCTION__ , __LINE__, ##__VA_ARGS__);                                                        \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format,...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; arr;</span><br><span class="line"><span class="keyword">int</span> n,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt;num,ll bios)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cnt++;</span></span><br><span class="line">    <span class="comment">//if(cnt&gt;20)return 0;</span></span><br><span class="line">    <span class="keyword">if</span>(!bios||num.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt;zero,one;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:num)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bios&amp;i)one.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> zero.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">min</span>(<span class="built_in">max</span>(<span class="number">0</span>,(<span class="keyword">int</span>)one.<span class="built_in">size</span>()<span class="number">-1</span>)+dfs(zero,bios&gt;&gt;<span class="number">1</span>),<span class="built_in">max</span>(<span class="number">0</span>,(<span class="keyword">int</span>)zero.<span class="built_in">size</span>()<span class="number">-1</span>)+dfs(one,bios&gt;&gt;<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll num;<span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">        arr.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line">    ans=dfs(arr,<span class="number">1l</span>l&lt;&lt;<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#683-D</title>
    <url>/2020/11/16/codeforces-683-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1447/problem/D" target="_blank" rel="noopener">D. Catching Cheaters</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个长度为n的字符串S和一个长度为m的字符串T</p>
<p>(n,m&lt;5000)</p>
<p>求4LCS(C,D)-|C|-|D|的最大值 (LCS为最长公共子序列)</p>
<p>其中C为S的任意子串 D为T的任意子串 (均可以为空串)</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>考虑LCS的dp过程</p>
<p>dp(i,j)表示S串前i位和T串前j位构成的最大公共子序列长度 (不一定包含第i位和第j位)</p>
<p>状态转移有:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(S[i]==T[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure>

<p>本题涉及求LCS 于是思考能否从这个角度进行类似的dp求解</p>
<p>设计dp(i,j)表示取S串第i位字符且取T串第j位字符能构成4LCS(C,D)-|C|-|D|的最大值</p>
<p>状态转移有:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(S[i]==T[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i][j],<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>对于S[i]==T[j]的情况 将这两个字符作为子串C和D的末尾</p>
<p>则根据公式4LCS(C,D)-|C|-|D|对答案产生+2的贡献</p>
<p>对于S[i]!=T[j]的情况 根据公式4LCS(C,D)-|C|-|D|</p>
<p>要么给C串加入S[i]要么给D串加入T[j] 对答案的贡献-1</p>
<p>当这两种情况导致当前的子串C和D得到的答案4LCS(C,D)-|C|-|D|&lt;0</p>
<p>那么将这两个子串C和D舍去 保留之前更新的dp(i,j)</p>
<h3 id="有点类似贪心求解最大子段和的过程："><a href="#有点类似贪心求解最大子段和的过程：" class="headerlink" title="有点类似贪心求解最大子段和的过程："></a>有点类似贪心求解最大子段和的过程：</h3><ul>
<li>当某个子段和已经小于0那么没必要将这段子串和加入答案</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="comment">//#define P pair&lt;ll,ll&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format, ...)                                                                            \</span></span><br><span class="line">&#123;                                                                                                   \</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"\033[33m[%s:%d] \033[0m"</span> format <span class="string">""</span>,                                            \</span><br><span class="line">    __FUNCTION__ , __LINE__, ##__VA_ARGS__);                                                        \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format,...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> dp[Max][Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n,m,ans=<span class="number">0</span>;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">string</span> s,t;<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==t[j])dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j]+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j+<span class="number">1</span>],<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>])<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>最大子段和</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#686-F</title>
    <url>/2020/11/27/codeforces-686-F/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1454/problem/F" target="_blank" rel="noopener">F. Array Partition</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个长为 n (3≤n≤2e5) 的数组 an，问是否能把它分成三段，</p>
<p>第一段的最大值等于第二段的最小值等于第三段的最大值。若能，输出分割方案。 </p>
</li>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><a href="https://www.cnblogs.com/AEMShana/p/14040408.html" target="_blank" rel="noopener">参考博客</a></p>
<p>很显然题目 需要处理一个前缀最大值 后缀最大值 以及用线段树</p>
<p>之类的数据结构维护中间部分的最小值 枚举分割方式判定是否符合要求。</p>
<p>解决问题的关键在于如何枚举分割区域。</p>
<img src="/.io//timg.gif" data-original="example.png">

<p>根据题目要求 符合条件的分割方式一定能使得中间区域的Min &gt;= x  两侧区域的Max&lt;=x 且都能取到 = x</p>
<p>所以枚举的x必然存在于三个区域中。</p>
<p>于是可以枚举每个 $a_i$ 作为上述的变量x 向左寻找最后一个以$a_i$为Max的 边界点L，</p>
<p>同时向右寻找最后一个以$a_i$ 为Max的边界点R  (下图中黑圈表示等于$a_i$)</p>
<p>当然$a_i$是否能成为中间区域的Min 需要进行验证</p>
<img src="/.io//timg.gif" data-original="example1.png">

</li>
</ul>
<p>目前已经确保中间部分存在$a_i$ (但仍不能确定$a_i$是Min)且左右区间确保最大值为$a_i$ </p>
<p>为什么取以当前位置$a_i$ 左右两侧最近的能同时使得$a_i$成为前后缀最大值的 位置作为L,R </p>
<p>因为[1,L]的前缀确保了所有数都小于等于$a_i$ [R,n]的后缀确保了所有数都小于等于$a_i$ 那么</p>
<p>让[L+1,R-1]作为中间区域 能尽量避免两边小于$a_i$的数加入 成为其最小值</p>
<p>于是我们只要判定 Max[1,L] == Min[L+1,R-1] == Max [R,n] 是否成立就行 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="comment">//#define P pair&lt;ll,ll&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format, ...)                                                                            \</span></span><br><span class="line">&#123;                                                                                                   \</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"[%s:%d]"</span> format <span class="string">""</span>,                                            \</span><br><span class="line">    __FUNCTION__ , __LINE__, ##__VA_ARGS__);                                                        \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format,...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegTree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Mid ((L+R)&gt;&gt;1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Leftson now&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Rightson now&lt;&lt;1|1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span><span class="keyword">int</span> L,R,minn,lazy;&#125;;</span><br><span class="line">    segtree tree[Max&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">        tree[now].minn=<span class="built_in">min</span>(tree[Leftson].minn,tree[Rightson].minn);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        tree[now]=&#123;L,R,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;L&lt;&lt;" "&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(L==R)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//int mid=(L+R)&gt;&gt;1;</span></span><br><span class="line">        build(L,Mid,Leftson);</span><br><span class="line">        build(Mid+<span class="number">1</span>,R,Rightson);</span><br><span class="line">        push_up(now);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> qL,<span class="keyword">int</span> qR,<span class="keyword">int</span> val,<span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(qL&lt;=tree[now].L&amp;&amp;qR&gt;=tree[now].R)&#123;</span><br><span class="line">            tree[now].minn+=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(qL&lt;=tree[Leftson].R)updata(qL,qR,val,Leftson);</span><br><span class="line">        <span class="keyword">if</span>(qR&gt;=tree[Rightson].L)updata(qL,qR,val,Rightson);</span><br><span class="line">        push_up(now);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> qL,<span class="keyword">int</span> qR,<span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(qL&gt;qR)<span class="keyword">return</span> inf;</span><br><span class="line">        <span class="keyword">if</span>(tree[now].R&lt;=qR&amp;&amp;tree[now].L&gt;=qL)<span class="keyword">return</span> tree[now].minn;</span><br><span class="line">        <span class="keyword">int</span> minn=inf;</span><br><span class="line">        <span class="keyword">if</span>(tree[Leftson].R&gt;=qL)minn=<span class="built_in">min</span>(minn,query(qL,qR,Leftson));</span><br><span class="line">        <span class="keyword">if</span>(tree[Rightson].L&lt;=qR)minn=<span class="built_in">min</span>(minn,query(qL,qR,Rightson));</span><br><span class="line">        push_up(now);</span><br><span class="line">        <span class="keyword">return</span> minn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Min;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[Max];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;per,suf;</span><br><span class="line"><span class="keyword">int</span> pos[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        Min.build(<span class="number">1</span>,n);</span><br><span class="line">        suf.<span class="built_in">clear</span>(),per.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">            pos[i]=n+<span class="number">1</span>;</span><br><span class="line">            suf[arr[i]]=n+<span class="number">1</span>;</span><br><span class="line">            Min.updata(i,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            pos[i]=suf[arr[i]];</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,arr[i]);</span><br><span class="line">            suf[maxn]=i;</span><br><span class="line">            <span class="comment">///cout&lt;&lt;i&lt;&lt;" "&lt;&lt;pos[i]&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,z=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,arr[i]);</span><br><span class="line">            <span class="keyword">int</span> L=per[arr[i]],R=pos[i];</span><br><span class="line">            per[maxn]=i;</span><br><span class="line">            <span class="keyword">if</span>(R&gt;n||L&lt;<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(Min.query(L+<span class="number">1</span>,R<span class="number">-1</span>)==arr[i])&#123;</span><br><span class="line">                x=L,y=R-L<span class="number">-1</span>,z=n-R+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>&lt;&lt;y&lt;&lt;<span class="string">" "</span>&lt;&lt;z&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#687-D</title>
    <url>/2020/11/27/codeforces-687-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1457/D" target="_blank" rel="noopener">D. XOR-gun</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度为1e5d 非递减数列, 每个数ai&lt;1e9</p>
<p>现在给出一种操作：</p>
<p>选择两个连续的数 异或后替换进去 </p>
<p>如[2,5,6,8]  选择(5,6) 得到[2,3,8] </p>
<p>问最小需要几次操作才能使得打破原来数列的非递减性质</p>
<p>或者输出-1表示不可能</p>
</li>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>同样 位运算相关问题一定要想到 按位运算的性质</p>
<p>我们发现 在题目所给的非递减数列中</p>
<p>当且仅当 存在三个连续的 数 他们的most significant bit 在同一位上时</p>
<p>才能通过异或后两个数 打破原来的非递减性质</p>
<p>那么由于数列非递减 所以超过60个数并且要保证ai的值一定小于1e9</p>
<p>只能至少存在三个连续的数 他们的most significant bit 在同一位上</p>
<p>例如</p>
<p>00..001x</p>
<p>00..001x</p>
<p>00..01xx</p>
<p>00..01xx</p>
<p>…</p>
<p>1xxxxxx</p>
<p>1xxxxxx</p>
<p>60个数是两个连续最高位在同一位上且ai不超过1e9的情况</p>
<p>于是当n&gt;60时 只用异或1次就能 达到目的</p>
<p>题目的量级一下缩小到n=60 以下 可以直接暴力枚举</p>
<p>n在60以下时 只有两个 相邻区间</p>
<p>它俩内的数求异或和 记为A和B  </p>
<p>这两个数A&gt;B是才能打破非递减性质</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="comment">//#define P pair&lt;ll,ll&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//#define __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format, ...)                                                                            \</span></span><br><span class="line">&#123;                                                                                                   \</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"[%s:%d]"</span> format <span class="string">""</span>,                                            \</span><br><span class="line">    __FUNCTION__ , __LINE__, ##__VA_ARGS__);                                                        \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format,...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">ll arr[Max],narr[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)narr[i]=narr[i<span class="number">-1</span>]^arr[i];</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">60</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">1</span>;L&lt;=n;L++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> lenL=<span class="number">0</span>;lenL+L&lt;=n;lenL++)&#123;</span><br><span class="line">            <span class="keyword">int</span> R=L+lenL+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//DeBug("%d,%d -&gt;%d\n",L,L+lenL,R);</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(R&gt;n)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lenR=<span class="number">0</span>;lenR+R&lt;=n;lenR++)&#123;</span><br><span class="line">                DeBug(<span class="string">"in\n"</span>);</span><br><span class="line">                <span class="keyword">if</span>((narr[L<span class="number">-1</span>]^narr[L+lenL])&gt;(narr[R<span class="number">-1</span>]^narr[R+lenR]))&#123;</span><br><span class="line">                    <span class="comment">//DeBug("%d,%d\n",R,R+lenR);</span></span><br><span class="line">                    DeBug(<span class="string">"(%d,%d):%d "</span>,L,L+lenL,(narr[L<span class="number">-1</span>]^narr[L+lenL]));</span><br><span class="line">                    DeBug(<span class="string">"(%d,%d):%d \n"</span>,R,R+lenR,(narr[R<span class="number">-1</span>]^narr[R+lenR]));</span><br><span class="line">                    ans=<span class="built_in">min</span>(ans,lenL+lenR);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans!=inf)<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-#688-D</title>
    <url>/2020/11/27/codeforces-688-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1453/problem/D" target="_blank" rel="noopener">D.CheckPoint</a></p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>构造一个0/1序列 ，1表示当前关卡有存档点 0表示没有存档点</p>
<p>每一关通过的概率为1/2 ,问怎么构造才能使得通过所有关卡的期望步数 = k</p>
<p>到达当前关卡 若通过挑战 则步数++，通向下一关;</p>
<p>若不通过 则步数++, 回到目前为止最近一个有存档点的关卡 </p>
<p>(回到存档点的关卡也要重新挑战)</p>
<p>若不能构造则输出-1</p>
<p>所有情况下第一关 必然有存档点</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>题目样例给出了几个情况 </p>
<p>当k=8 时 关卡设计为 1 1 1 1</p>
<p>当k=4 时 关卡设计为 1 1</p>
<p>由于通过本关之后到达下一关激活了复活点 所以失败后仍在本关复活</p>
<p>相当于它与前面的关卡设计已经无关</p>
<p>所以通过第i关的期望次数=2 通过所有关的期望是2n</p>
<p>当关卡设计中存在有不含检查点的关卡时 </p>
<p>不能通过就会复活在目前为止最近一个有存档点的关卡 </p>
<img src="/.io//timg.gif" data-original="example.png">

<p>状态如上图所示</p>
<p>设$f_x$ 表示从第x关出发 到达下一个检查点所需要的期望步数 (终点也视为检查点)</p>
<p>那么 对于第x 关 它有 1/2 的概率 通关到达下一关 则需要的步数为(1+$f_{x+1}$)</p>
<p>也有1/2的概率失败 回到 上一个检查点 y 则需要的步数为 (1+ $f_y$) </p>
<p>若第x+1关存在检查点 那么 它有 1/2 的概率 通关到达检查点 视为 一个临时的终点 需要1步</p>
<p>也有1/2的概率失败 回到 上一个检查点 y 则需要的步数为 (1+ $f_y$) </p>
<p>若到达一个新的检查点 由于之后的关卡失败也是从这一个检查点重新开始 </p>
<p>所以后半段的期望步数与前半段期望步数不相干 通关的期望步数 是所有 (1 0 0 0 …) 段独立 期望的和</p>
<p>对于长度为m形如：1 0 0 0 0 ….. 的连续关卡 </p>
<p>可以视为 连续投掷m个硬币 所有正面朝上所需要的期望次数 (若有一枚为反面 则全部重来)</p>
<p>这个问题模型推导 可以参考<a href="https://www.codechef.com/wiki/tutorial-expectation" target="_blank" rel="noopener">此处</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="comment">//#define P pair&lt;ll,ll&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">0x3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format, ...)                                                                            \</span></span><br><span class="line">&#123;                                                                                                   \</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"[%s:%d]"</span> format <span class="string">""</span>,                                            \</span><br><span class="line">    __FUNCTION__ , __LINE__, ##__VA_ARGS__);                                                        \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format,...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans*=x;</span><br><span class="line">        x*=x;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> arr[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            ll L=<span class="number">-1</span>,R=<span class="number">61</span>;</span><br><span class="line">            <span class="keyword">while</span>(R-L&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                ll mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(qpow(<span class="number">2</span>,mid+<span class="number">1</span>)<span class="number">-2</span>&lt;=n)L=mid;</span><br><span class="line">                <span class="keyword">else</span> R=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(qpow(<span class="number">2</span>,L+<span class="number">2</span>)<span class="number">-2</span>&lt;=n)L++;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;qpow(2,L+1)-2&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">//break;</span></span><br><span class="line">            arr[now]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;L;i++)&#123;</span><br><span class="line">                arr[now+i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            now+=L;</span><br><span class="line">            n-=qpow(<span class="number">2</span>,L+<span class="number">1</span>)<span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;now&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;now;i++)<span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed72-B</title>
    <url>/2020/07/11/codeforces-Ed72-B/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1217/problem/B" target="_blank" rel="noopener">B. Zmei Gorynich</a> </p>
<p>题意</p>
<p>要杀死生命值为x的龙</p>
<p>有n个武器</p>
<p>每种造成伤害为di 同时龙会恢复hi生命</p>
<p>问最少使用几次杀死怪物</p>
<p>题解</p>
<p>当出现有一种武器能直接杀死龙时输出1</p>
<p>当所有武器都不能杀死龙时输出-1</p>
<p>否则反复使用最大的di-hi武器</p>
<p>最后一次用最大的di攻击能保证次数最少///即龙的血量小于等于斩杀线max di</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ms(x, n) memset(x,n,sizeof(x));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL T, x, n, d, h;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL ans = <span class="number">1</span>, maxD = <span class="number">0</span>, maxDif = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; d &gt;&gt; h;</span><br><span class="line">            maxD = <span class="built_in">max</span>(d, maxD);</span><br><span class="line">            <span class="keyword">if</span>(d - h &gt; <span class="number">0</span>)</span><br><span class="line">                maxDif = <span class="built_in">max</span>(d-h, maxDif);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxD &gt;= x)</span><br><span class="line">            ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!maxDif)</span><br><span class="line">            ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(maxD &lt; x)</span><br><span class="line">            ans += (LL)<span class="built_in">ceil</span>((<span class="keyword">double</span>)(x-maxD)/maxDif);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2 100</span></span><br><span class="line"><span class="comment">100 101</span></span><br><span class="line"><span class="comment">1 101</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed72-C</title>
    <url>/2020/07/11/codeforces-Ed72-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1217/problem/C" target="_blank" rel="noopener">C. The Number Of Good Substrings</a> </p>
<p>题意<br>给出一个01串<br>问有多少子串满足<br>r-l+1=十进制的值<br>即长度=子串所表示的十进制数大小<br>如011=3  长度为3 且011的值为3 (右侧开始最低位)</p>
<p>题解</p>
<p>因为2^20&gt;最大字符串长度2e5可以剪枝<br>意思是最长能满足要求的01串不会超过20位<br>因为2^20&gt;整个字符串长度</p>
<p>预处理每个1之前的0</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;<span class="built_in">cin</span>&gt;&gt;s;<span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> zero=<span class="number">0</span>;<span class="keyword">int</span> per[s.<span class="built_in">size</span>()+<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'1'</span>)&#123;per[i]=zero;zero=<span class="number">0</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> zero++;</span><br><span class="line">        &#125;<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">///枚举每个左端点</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;<span class="keyword">int</span> p;</span><br><span class="line">            <span class="keyword">for</span>(p=i;p&lt;<span class="built_in">min</span>(n,i+<span class="number">20</span>);p++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[p]==<span class="string">'1'</span>)sum=(sum&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> sum&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum&lt;=p-i+<span class="number">1</span>+per[i])ans++;</span><br><span class="line">	<span class="comment">///如果子串长度+左端点前无效0的长度&gt;=二进制所表示的值则可行</span></span><br><span class="line">	<span class="comment">///为什么不用加入sum&gt;=p-i+1？</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed76-D</title>
    <url>/2020/07/08/codeforces-Ed76-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1257/problem/D" target="_blank" rel="noopener">D. Yet Another Monster Killing Problem</a></p>
<p>题意<br>有n个怪物每个怪物有ai攻击力<br>有m个勇者每个勇者有pi攻击力和si耐力<br>当且仅当pi&gt;=ai时这个勇者才可击败怪物<br>一个勇者最多能战斗si次<br>消耗完si次或遇到打不过的一天结束<br>问最少几天打完所有怪物</p>
<p>先判断能否打败所有怪物<br>贪心关键：<br>建立一个hero[si]存耐力值大于等于si的攻击力最大的勇士<br>然后双指针遍历去一个连续区间len怪物攻击力最大值maxn假如hero[len]&gt;=maxn那么可以继续寻找更长len是否满足<br>len大于最大勇士耐久或不满足等式时天数++<br>(原来想的是找到每种耐力值下最大攻击力的勇士但是还不够贪心)</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> <span class="keyword">int</span> mon[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line"> <span class="keyword">int</span> hero[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,maxm=<span class="number">0</span>;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;mon[i];hero[i]=<span class="number">0</span>;</span><br><span class="line">            maxm=<span class="built_in">max</span>(maxm,mon[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m,maxs=<span class="number">0</span>;<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p,s;<span class="built_in">cin</span>&gt;&gt;p&gt;&gt;s;</span><br><span class="line">            hero[s]=<span class="built_in">max</span>(hero[s],p);maxs=<span class="built_in">max</span>(maxs,s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxp=hero[maxs];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=maxs<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            maxp=<span class="built_in">max</span>(maxp,hero[i]);</span><br><span class="line">            hero[i]=maxp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxp&lt;maxm)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxm=<span class="number">0</span>;<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            maxm=<span class="built_in">max</span>(maxm,mon[i]);</span><br><span class="line">            <span class="keyword">if</span>(hero[x]&gt;=maxm)&#123;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;maxs||i==n)x=<span class="number">1</span>,maxm=<span class="number">0</span>,cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt++;x=<span class="number">1</span>;i--;</span><br><span class="line">                maxm=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>标程</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="keyword">int</span>(<span class="number">2e5</span>) + <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> p[N], s[N];</span><br><span class="line"><span class="keyword">int</span> bst[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> tc = <span class="number">0</span>; tc &lt; t; ++tc)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) bst[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, p + i, s + i);</span><br><span class="line">			bst[s[i]] = <span class="built_in">max</span>(bst[s[i]], p[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">			bst[i] = <span class="built_in">max</span>(bst[i], bst[i + <span class="number">1</span>]);	</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">while</span>(pos &lt; n)&#123;</span><br><span class="line">			++res;</span><br><span class="line">			<span class="keyword">int</span> npos = pos;</span><br><span class="line">			<span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">				mx = <span class="built_in">max</span>(mx, a[npos]);</span><br><span class="line">				<span class="keyword">if</span>(mx &gt; bst[npos - pos + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">				++npos;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(pos == npos)&#123;</span><br><span class="line">				ok = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			pos = npos;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!ok) res = <span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed77-C</title>
    <url>/2020/07/08/codeforces-Ed77-C/</url>
    <content><![CDATA[<p><a href="http://codeforces.ml/contest/1260/problem/C" target="_blank" rel="noopener">C. Infinite Fence</a></p>
<p>题意</p>
<p>找到nb到(n+1)b之间最多有几个r的倍数<br>判断最多会不会超过k个r</p>
<p>倍数分部性质</p>
<p>利用gcd首先寻找b和r的倍数间最小间隔然后尽可能填充r时判断是否会超过k个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll r,b,k;<span class="built_in">cin</span>&gt;&gt;r&gt;&gt;b&gt;&gt;k;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;b)swap(r,b);</span><br><span class="line">        ll gcd=__gcd(r,b);<span class="comment">///每间隔n*gcd会出现一个r或b那么r和b之间最小间距等于gcd</span></span><br><span class="line">        <span class="comment">///b之后第一个r和之后(k-1)个r需要的区间为r*(k-1)+gcd要严格大于等于b时才不会出现连续k个r</span></span><br><span class="line">        <span class="keyword">if</span>(r*(k<span class="number">-1</span>)+gcd&lt;b)<span class="built_in">cout</span>&lt;&lt;<span class="string">"REBEL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"OBEY"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>gcd</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed63-D</title>
    <url>/2020/07/08/codeforces-Ed63-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1155/problem/D" target="_blank" rel="noopener">D. Beautiful Array</a> </p>
<p>题意<br>给一串数组</p>
<p>要求最多选一个连续子串乘x</p>
<p>问形成新的数组的最大连续子串和(子串可以为空)</p>
<p>题解</p>
<p>把整个序列分成三段来dp。</p>
<p>dp[0]表示没有乘过x序列的最大值。</p>
<p>dp[1]表示正在乘x的序列的最大值。</p>
<p>dp[2]表示已经乘完x的序列的最大值。</p>
<p>则dp[0]=max(dp[0],dp[0]+val);</p>
<p>dp[1]=max(dp[0],dp[1]+x*val);</p>
<p>dp[2]=max(dp[1],dp[2]+val);</p>
<p>版本1</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> maxn 300005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll dp[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll m,res=<span class="number">-1e18</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="built_in">max</span>(<span class="number">0l</span>l,dp[<span class="number">0</span>]+x);</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>],dp[<span class="number">1</span>]+x*m); <span class="comment">///以当前数作为乘m的子串的起始或不作为起始继承dp[0]</span></span><br><span class="line">        dp[<span class="number">2</span>]=<span class="built_in">max</span>(dp[<span class="number">1</span>],dp[<span class="number">2</span>]+x);<span class="comment">///以当前数作为乘m的子串的结束之后第一个或作为乘m的子串的最后一个继承dp[1]</span></span><br><span class="line">        res=<span class="built_in">max</span>(res,dp[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>版本2</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll dp[<span class="number">3</span>][(<span class="keyword">int</span>)<span class="number">3e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;x;ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll a;<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        dp[<span class="number">0</span>][i]=<span class="built_in">max</span>(dp[<span class="number">0</span>][i<span class="number">-1</span>]+a,<span class="number">0l</span>l);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[<span class="number">0</span>][i]);</span><br><span class="line">        dp[<span class="number">1</span>][i]=<span class="built_in">max</span>(dp[<span class="number">0</span>][i<span class="number">-1</span>],dp[<span class="number">1</span>][i<span class="number">-1</span>])+x*a;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[<span class="number">1</span>][i]);</span><br><span class="line">        dp[<span class="number">2</span>][i]=<span class="built_in">max</span>(dp[<span class="number">2</span>][i<span class="number">-1</span>],dp[<span class="number">1</span>][i<span class="number">-1</span>])+a;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[<span class="number">2</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed78-B</title>
    <url>/2020/07/08/codeforces-Ed78-B/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1278/problem/B" target="_blank" rel="noopener">B. A and B</a></p>
<p>题意<br>给出两个数 a b<br>第i次操作可以给a+=i或给b+=i；<br>问最少几次操作使得a==b</p>
<p>启发点:因为对于两数和a’+b’=sum一定等于a+b+(n+1)*n/2<br>a’= =b’所以sum%2= =0 且有a’&gt;=a b’&gt;=b<br>循环累加i判断是否成立即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll a,b;<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        ll sum=a+b;ll i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(sum%<span class="number">2</span>!=<span class="number">0</span>||sum/<span class="number">2</span>&lt;a||sum/<span class="number">2</span>&lt;b)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed77-D</title>
    <url>/2020/07/08/codeforces-Ed77-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1260/problem/D" target="_blank" rel="noopener">D. A Game with Traps</a></p>
<p>题意<br>有m个士兵每个士兵有属性值ai<br>k个陷阱每个陷阱分布在1到n上<br>每个陷阱(陷阱位置在li)有一个属性值di和一个接触此陷阱的开关在ri位置 注意 ri&gt;=li<br>你需要在t时间内将尽量多的士兵从0带到n+1<br>你可以解除陷阱，由士兵组成的队伍不能通过某个陷阱当且仅当陷阱的属性值大于队伍中某一士兵的属性值</p>
<p>二分挑出能力最大的mid个士兵筛选有威胁的陷阱<br>对于当前前面有炸弹时，我们要考虑拆这个炸弹，拆完之后是继续往后拆，还是直接回去。<br>这个我们画图就能知道，如果两个炸弹起点和终点位置有交叉，那么就继续拆，否则直接回去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> <span class="keyword">int</span> sold[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line"> <span class="keyword">int</span> m,n,k,t;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,d;</span><br><span class="line"> &#125;trap[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line"> <span class="keyword">int</span> cnt[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minn=mid!=<span class="number">0</span>?sold[mid<span class="number">-1</span>]:(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(trap[i].d&lt;=minn)<span class="keyword">continue</span>;<span class="comment">///筛选有威胁的陷阱</span></span><br><span class="line">        cnt[trap[i].l]++;<span class="comment">///差分思想</span></span><br><span class="line">        cnt[trap[i].r+<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)sum+=(cnt[i]&gt;=<span class="number">1</span>);<span class="comment">///若大于1那么还需要向右走找需要解除炸弹的最右处的机关</span></span><br><span class="line">    <span class="keyword">return</span> sum*<span class="number">2</span>+n+<span class="number">1</span>&lt;=t;<span class="comment">///对于cnt[i]&gt;=1的路段需要留下士兵先去解除炸弹后在返回所以乘2</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;k&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="built_in">cin</span>&gt;&gt;sold[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;trap[i].l&gt;&gt;trap[i].r&gt;&gt;trap[i].d;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(sold,sold+m,cmp);</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">0</span>,R=m,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(L+R+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            L=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> R=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>差分前缀</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed78-C</title>
    <url>/2020/07/08/codeforces-Ed78-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1278/problem/C" target="_blank" rel="noopener">C - Berry Jam</a></p>
<p>题意<br>n个jam 梯子 n个jam<br>一共2*n个jam 1代表草莓酱 2代表蓝莓酱</p>
<p>一个人从中间向两侧中任意一侧取第一个未吃过的酱吃掉<br>问最少吃几罐能让剩下的草莓酱和蓝莓酱数量相等</p>
<p>发现吃的区间一定连续</p>
<p>可以利用前缀预处理和倒序遍历<br>前缀预1到n处理记录前i个草莓酱和蓝莓酱差值cnt<br>对于最后一次出现的差值cnt 记录/last[cnt]=i/ 它的位置<br>然后倒序遍历2n到n 对于右侧某位置i 草莓酱和蓝莓酱的差值为cnt<br>那么对应的左边前i个需要有差值-cnt 才能使得两端两者的数量相同</p>
<p>蓝莓酱比草莓酱多 cnt个 （位置last[-cnt]） ……需要吃掉……  蓝莓酱比草莓酱少cnt个 （位置i）<br>因为cnt会出现负数可以用map来存前缀预处理的结果</p>
<p>其次注意last[0]=0 左边第0个位置 两者差值为0<br>倒序遍历时可能不会出现cnt=0的情况需要提前处理</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> data[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; last;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        last.<span class="built_in">clear</span>();last[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">            <span class="keyword">if</span>(data[i]==<span class="number">1</span>)cnt++;</span><br><span class="line">            <span class="keyword">else</span> cnt--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=n)last[cnt]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=<span class="number">0</span>;<span class="keyword">int</span> ans=<span class="built_in">min</span>(<span class="number">2</span>*n,<span class="number">2</span>*n-last[cnt]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*n;i&gt;n;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i]==<span class="number">1</span>)cnt--;</span><br><span class="line">            <span class="keyword">else</span> cnt++;</span><br><span class="line">            <span class="comment">///cout&lt;&lt;cnt&lt;&lt;" "&lt;&lt;last[cnt]&lt;&lt;" "&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(last.count(cnt))ans=<span class="built_in">min</span>(ans,i<span class="number">-1</span>-last[cnt]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>实现</tag>
        <tag>贪心</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed80-C</title>
    <url>/2020/07/08/codeforces-Ed80-C/</url>
    <content><![CDATA[<p><a href="http://codeforces.ml/contest/1288/problem/C" target="_blank" rel="noopener">C. Two Arrays</a></p>
<p>题意<br>要求构造出两个长度为m 且每一位数在1到n之间取值的数列a b<br>且 a要为非递减 b要为非递增<br>ai&lt;=bi<br>问能构造出多少对a和b</p>
<p>由于am&lt;=bm &amp;&amp; a非递减 b非递增<br>那么问题转化为构造 一个长为2*m的非递减数列且每个数在1到n之间的方案数 mod1e9+7 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">"\n"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=(ll)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll sum[<span class="number">30</span>][<span class="number">1005</span>];<span class="comment">/// 表示第i个数为1~j的方案数</span></span><br><span class="line">ll dp[<span class="number">30</span>][<span class="number">1005</span>];<span class="comment">/// 表示第i个数为j的方案数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[i][j]=(dp[i][j]+sum[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">            sum[i][j]=(sum[i][j<span class="number">-1</span>]+dp[i][j])%mod;<span class="comment">///前缀和优化dp</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum[<span class="number">2</span>*m][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>问题转化</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed81-B</title>
    <url>/2020/07/08/codeforces-Ed81-B/</url>
    <content><![CDATA[<p><a href="https://links.jianshu.com/go?to=https://codeforces.com/contest/1295/problem/B" target="_blank" rel="noopener">B - Infinite Prefixes</a></p>
<p>题意<br>给出一个长度为n 的01串 s 和一个空串t<br>你可以在t后接任意个s<br>问 t中可以出现几个位置<br>他的前缀 0的数量cnt0 和前缀1的数量cnt1<br>满足 cnt0-cnt1=x<br>如果有无限个输出-1</p>
<p>一个s中它的cnt0-cnt1=de是固定的<br>t无论接多少s 它总的cnt0-cnt1=k<em>de<br>所以题意转化成 k</em>de+vis[i]=x 求符合要求的k有几个<br>vis[i]=一个s中出现的所有 前缀cnt0-cnt1的值<br>比如 s=00111<br>vis[]={1,2,0,-1} 0比1多一个 0比1多两个 ，，，<br>枚举vis[i]求(x-vis[i])%de==0</p>
<p>注意de=0 时特判 如果有vis[i]==x那一定有无限个<br>如果没有那么输出0</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IO std::ios::sync_with_stdio(false);</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s,t;</span><br><span class="line"><span class="comment">//int de[(int)1e5+5];</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,x;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;x;</span><br><span class="line">        <span class="built_in">string</span> s;<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis;</span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;len;i++)de[i]=0;</span></span><br><span class="line">        <span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt0=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'1'</span>)cnt1++;</span><br><span class="line">            <span class="keyword">else</span> cnt0++;</span><br><span class="line">            <span class="comment">//de[i]=cnt0-cnt1;</span></span><br><span class="line">            vis.push_back(cnt0-cnt1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> de=cnt0-cnt1;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;de&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(de==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:vis)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==x)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//else if((de&gt;0&amp;&amp;x&lt;0)||(de&lt;0&amp;&amp;x&gt;0))cout&lt;&lt;0&lt;&lt;endl;//这一步多余且会造成错误两者不同号也有可能出现有限个解</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//bool flag=0;</span></span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">0</span>)ans++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:vis)&#123;</span><br><span class="line">                <span class="keyword">int</span> val=x-i;</span><br><span class="line">                <span class="keyword">if</span>(val&lt;<span class="number">0</span>&amp;&amp;de&gt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(val&gt;<span class="number">0</span>&amp;&amp;de&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(de!=<span class="number">0</span>&amp;&amp;<span class="built_in">abs</span>(val)%<span class="built_in">abs</span>(de)==<span class="number">0</span>)ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">///if(flag)cout&lt;&lt;-1&lt;&lt;endl;</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed81-C</title>
    <url>/2020/07/08/codeforces-Ed81-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1295/problem/C" target="_blank" rel="noopener">C - Obtain The String</a></p>
<p>题意<br>给出s串 和目标串t<br>你可以从s串中取出任意子序列拼接<br>问最少取出几个子序列才能拼出目标串t</p>
<p>题解</p>
<p>发现 如果t串某个字母需要取到 t上一个字母在s串中取得字符的位置之前<br>那么结果就需要增加一个子序列产能拼接出t</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IO std::ios::sync_with_stdio(false);</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s,t;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=(<span class="keyword">int</span>)<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> first[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> have[<span class="number">30</span>][(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        <span class="keyword">int</span> lens=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)first[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lens;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first[s[i]-<span class="string">'a'</span>]==<span class="number">-1</span>)first[s[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">30</span>;j++)have[j][i]=maxn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)have[i][lens]=maxn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lens<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            have[s[i]-<span class="string">'a'</span>][i]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">30</span>;j++)&#123;</span><br><span class="line">                have[j][i]=<span class="built_in">min</span>(have[j][i],have[j][i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lent=t.<span class="built_in">size</span>();<span class="keyword">int</span> per=<span class="number">-1</span>,ans=<span class="number">1</span>;<span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lent;i++)&#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;first[t[i]-'a']&lt;&lt;" "&lt;&lt;per&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(first[t[i]-<span class="string">'a'</span>]==<span class="number">-1</span>)&#123;flag=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">bool</span> vis=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(first[t[i]-<span class="string">'a'</span>]&lt;=per&amp;&amp;have[t[i]-<span class="string">'a'</span>][per+<span class="number">1</span>]==maxn)ans++,vis=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis)per=first[t[i]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">else</span> per=have[t[i]-<span class="string">'a'</span>][per+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed81-D</title>
    <url>/2020/07/08/codeforces-Ed81-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1295/D" target="_blank" rel="noopener">D.Same GCDs</a></p>
<p>题意<br>求有多少x符合gcd(a+x,m)=gcd(a,m)=gcd;<br>且m&gt;x&gt;=0;<br>直接求phi[m/gcd(a,m)];<br>存在gcd(y,m)=gcd(a,m) y&lt;a:<br>但由于a+x&gt;m,<br>gcd(y,m)=gcd(y+m,m) (更相减损术)<br>y+m&gt;=a且 y+m&lt;a+m </p>
<p>[a,a+m]中总有一个数z可以通过更相减损变成y</p>
<p>所以问题变成了有多少个y&lt;a 使得gcd(y,m)=gcd(a,m)</p>
<p>这里用到一个性质gcd(y,m)=gcd(a,m)=d -&gt; 两边同除d -&gt; gcd(y,m/d)=1</p>
<p>那问题又从有多少个y&lt;a 使得gcd(y,m)=gcd(a,m) 变成了有多少个 小于m/gcd(a,m)的数与m/gcd(a,m)互质 这个就是欧拉函数所表示的 phi [n]= 有多少个[i&lt;n] gcd(i,n)==1</p>
<p>即1到m/gcd(a,m)中与m/gcd(a,m)互质的个数 == phi[m/gcd(a,m)] </p>
<p> gcd(y,m)==gcd的数量其实就是 gcd(a+x,m) ==gcd  (a+x&gt;=m) 的数量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IO std::ios::sync_with_stdio(false);</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s,t;</span><br><span class="line"><span class="comment">//int de[(int)1e5+5];</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ll a,m;<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;m;</span><br><span class="line">        ll gcd=__gcd(a,m);</span><br><span class="line">        a/=gcd;m/=gcd;</span><br><span class="line">        ll ans=m;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m%i==<span class="number">0</span>)&#123;</span><br><span class="line">                ans-=ans/i;<span class="comment">///1~m中有ans/i个数是i的倍数</span></span><br><span class="line">                <span class="keyword">while</span>(m%i==<span class="number">0</span>)m/=i;<span class="comment">///将m中的因子i剔除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;<span class="number">1</span>)ans-=ans/m;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>更相减损法</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed83-D</title>
    <url>/2020/07/08/codeforces-Ed83-D/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1312" target="_blank" rel="noopener">D. Count the Arrays</a></p>
<p>题意</p>
<p>构造一个长度n的序列</p>
<p>要求每个数都是在1到m数中的一个</p>
<p>序列中只有一对数相等</p>
<p>这个序列必须先严格递增 再严格递减</p>
<p>现在给出n和m 问能构造出多少个符合这种要求的序列</p>
<p>题解见代码</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"># include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line"># define endl <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">const ll <span class="keyword">mod</span>=<span class="number">998244353</span>;</span><br><span class="line">const ll maxn=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line">ll fac[maxn];</span><br><span class="line">ll qpow(ll <span class="symbol">x</span>,ll <span class="symbol">y</span>)&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="symbol">y</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="symbol">y</span>&amp;<span class="number">1</span>)ans=(ans*<span class="symbol">x</span>)%<span class="keyword">mod</span>;</span><br><span class="line">        <span class="symbol">x</span>=(<span class="symbol">x</span>*<span class="symbol">x</span>)%<span class="keyword">mod</span>;<span class="symbol">y</span>&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll C(ll <span class="symbol">x</span>,ll <span class="symbol">y</span>)&#123;<span class="keyword">return</span> ((fac[<span class="symbol">x</span>]*qpow(fac[<span class="symbol">y</span>],<span class="keyword">mod</span><span class="number">-2</span>)%<span class="keyword">mod</span>)*qpow(fac[<span class="symbol">x</span>-<span class="symbol">y</span>],<span class="keyword">mod</span><span class="number">-2</span>))%<span class="keyword">mod</span>;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll n,m;cin&gt;&gt;n&gt;&gt;m;fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;maxn;i++)fac[i]=(fac[i<span class="number">-1</span>]*i)%<span class="keyword">mod</span>;</span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="comment">/// 从m个数中选出n-1个不同的数 </span></span><br><span class="line">    <span class="comment">///从n-1个数中选出成对的那个数有(n-2)种</span></span><br><span class="line">    <span class="comment">///最大的那个数不能成对否则不能满足严格先递增后递减</span></span><br><span class="line">    <span class="comment">///其次所有数要么在最大数的左边要么右边 成对的那个数两边都有</span></span><br><span class="line">    <span class="comment">///因为剩下的数都是唯一的 决定放在哪一侧后一定存在唯一的排序方式 </span></span><br><span class="line">    <span class="comment">///所以再乘上2^(n-3) (原来有n-1个数 去掉最大的那个数 去掉重复的那个数 剩下n-3个数要选择在右边或左边)</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">2</span>)ans=((C(m,n<span class="number">-1</span>)*(n<span class="number">-2</span>))%<span class="keyword">mod</span>*qpow(<span class="number">2</span>,n<span class="number">-3</span>))%<span class="keyword">mod</span>;</span><br><span class="line">    <span class="keyword">else</span> ans=(C(m,n<span class="number">-1</span>)*(n<span class="number">-2</span>)/<span class="number">2</span>)%<span class="keyword">mod</span>;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed82-D</title>
    <url>/2020/07/08/codeforces-Ed82-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1303/problem/D" target="_blank" rel="noopener">D.Fill The Bag</a></p>
<p>题意</p>
<p>你有一个 n 码的袋子，你还有 m 个盒子，第 i 个盒子的尺寸是 ai ，这里的每一个 </p>
<p>ai 都是 2 的非负幂整数。</p>
<p>你可以把盒子分成大小相等的两部分。你的目标是完全装满袋子。</p>
<p>例如 n=10,a=[1,1,32] ，那么你必须把 32 码的盒子分成 16 码的两部分，然后把 </p>
<p>16 码的盒子分开，你可以用 1 码，1 码，8 码的盒子装满袋子。</p>
<p>///被分割出来的16码 8码还有剩下的并不是直接扔掉</p>
<p>计算填充尺寸为 n 的袋子所需的最小分割数。</p>
<p>多组数据，无解输出 -1 。 </p>
<p>先来讨论一下 -1 的情况：</p>
<p>考虑到分裂一个数不会影响到所有数的和。</p>
<p>那么我们将所有数都分裂成 1 ，由于和不变，此时 1 的个数为 ∑(i=1to m) a[i] ，</p>
<p>也就是说小于等于 ∑(i=1to m) a[i] 的数都可以被填出来。</p>
<p>故当 n&gt;∑(i=1to m) a[i]  时，无解。</p>
<p>将 n 二进制拆分成 2^{k1}, 2^{k2},…, 2^{kc} 。</p>
<p>然后从低位（2^{k1} )到高位（2^{kc}）贪心填数。</p>
<p>假设我们当前处理到的数为 2^ki 。</p>
<p>首先考虑位数小于等于 ki 的所有数中，能不能凑成 2^ki ，若可以，直接填上去；否则考虑分裂位数大于 ki 的所有数中最小的那一个，使其经过若干次分裂，分裂成 2^ki 。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll box[(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">4</span>];</span><br><span class="line">ll <span class="built_in">bit</span>[<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n,m,sum=<span class="number">0</span>;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        ll cnt,temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>;i++)<span class="built_in">bit</span>[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;box[i];</span><br><span class="line">            sum+=box[i];</span><br><span class="line">            temp=box[i];cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(temp%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                temp/=<span class="number">2</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">bit</span>[cnt]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;n)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">60</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;(<span class="number">1l</span>l&lt;&lt;i))&#123;<span class="comment">/// 若n的二进制第i位 为1 那么从第i位到最高位找是否有1可以直接用或分解</span></span><br><span class="line">                <span class="keyword">for</span>(ll j=i;j&lt;<span class="number">60</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">bit</span>[j])&#123;<span class="comment">///找到从第i位开始最低位的1 模拟减法 </span></span><br><span class="line">			<span class="comment">///比如需要一个1000 找到最低位的1在100000 那么100000 - 001000 =011000</span></span><br><span class="line">                        <span class="built_in">bit</span>[j]--;</span><br><span class="line">                        <span class="keyword">for</span>(ll k=i;k&lt;j;k++)<span class="built_in">bit</span>[k]++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans++;<span class="comment">///还未找到那么相当于 除2平分操作多一次</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">bit</span>[i+<span class="number">1</span>]+=<span class="built_in">bit</span>[i]/<span class="number">2</span>;<span class="comment">///在for循环到下一位时如果这一位的二进制1的个数大于2那么选择进位</span></span><br><span class="line">			       <span class="comment">///等价于考虑位数小于等于 ki 的所有数中，能不能凑成 2^ki </span></span><br><span class="line">			       <span class="comment">///无法进位的数将不会被用到所以不用考虑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed86-D</title>
    <url>/2020/07/08/codeforces-Ed86-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1342/problem/D" target="_blank" rel="noopener">D.Multiple Testcases</a></p>
<p>题意<br>有n个数 m[i] 每个数小于k<br>要求分成最少组 每个组内大于等于 i(1~k) 的数不超过c[i]</p>
<p>首先要求出最小分组 q<br>引入新数组 ar，让 ar[i] 表示数组 m 中大于等于 i 的数字的个数<br>又因为 c[i] 数组表示每个分组大于等于 i 的数字的最大个数<br>所以就能得到，单对于数字 i 而言，最小分组数为 ar[i] 除以 c[i] 向上取整<br>写作 ceil(1.0*ar[i]/c[i]) 或者 (ar[i]+c[i]-1)/c[i]<br>最后，让答案分组 q 在这些最小分组中取大即可</p>
<p>得出最小分组 q 后<br>贪心可得，将数组 m 进行排序后<br>将 m[1], m[2], m[3]… m[n] 循环放入组 T[1], T[2] … T[q], T[1], T[2] … 即可得出分组方案<br>//为什么一定要这样分成q组 对于q=max{(i=1<del>k) | ceil(1.0 × ar[i]/c[i] )  } 所以每组有m/q&lt;= m/ceil(1.0×ar[i]/c[i]) {i=1</del>k} 个数 不会超过任意一个 c[i]限制 。<br>//为什么一定需要排序后循环放入T？不能理解<br>//分成q组后从大到小放入后放入的限制比先放入的宽一定可以放入<br>//且取余q一定不会超过最短的连续相等的c[m[i]]长度这样才能保证不冲突<br>//<a href="https://blog.csdn.net/tourist1412/article/details/105792592" target="_blank" rel="noopener">https://blog.csdn.net/tourist1412/article/details/105792592</a><br>即对于第 i 组 T[i] 而言，它所包含的数为 m[i], m[q+i], m[2q+i], m[3q+i] …<br>根据上面对于 q 的解法，能够保证同一组中的数不会与题意产生冲突</p>
<p>ps. 虽然根据 ar 和 c 数组的定义，m 数组应该是从大到小排序后，从较大的数字开始循环放入的，但实际上从小到大也是可行<br>很明显可以想到，尽量满足i值大的数最优。因为i越大,c[i]越小，限制既然越大，那么先安排，后面再让限制小的插入。用一个优先队列维护</p>
<p>//贪心实现</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">"\n"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TurnoffIO std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> data[Max];</span><br><span class="line"><span class="keyword">int</span> c[Max],maxc[Max];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//TurnoffIO;</span></span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;data[i],maxc[data[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">    sort(data+<span class="number">1</span>,data+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> up=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        maxc[i]+=maxc[i+<span class="number">1</span>];</span><br><span class="line">        up=<span class="built_in">max</span>(up,(<span class="keyword">int</span>)<span class="built_in">ceil</span>(<span class="number">1.0</span>*maxc[i]/c[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans[up];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans[i%up].push_back(data[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;up&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;up;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i].<span class="built_in">size</span>()&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:ans[i])<span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>///优先队列 对指定struct 使用优先队列 实现</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> c[maxn],b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;rhs)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt; rhs.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="number">1</span>,b + <span class="number">1</span> + n);</span><br><span class="line">    priority_queue&lt;Node&gt;q;</span><br><span class="line">    Node a;</span><br><span class="line">    a.cnt = <span class="number">0</span>;a.a.<span class="built_in">clear</span>();</span><br><span class="line">    q.push(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        Node now = q.top();q.pop();</span><br><span class="line">        <span class="keyword">if</span>(now.cnt &lt; c[b[i]]) &#123;</span><br><span class="line">            <span class="keyword">while</span>(now.cnt &lt; c[b[i]]) &#123;</span><br><span class="line">                now.a.push_back(b[i]);</span><br><span class="line">                now.cnt++;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            q.push(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node tmp;</span><br><span class="line">            tmp.cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp.cnt &lt; c[b[i]]) &#123;</span><br><span class="line">                tmp.cnt++;</span><br><span class="line">                tmp.a.push_back(b[i]);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            q.push(tmp);</span><br><span class="line">            q.push(now);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        Node now = q.top();q.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; now.cnt &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; now.cnt;i++) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; now.a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//同样的贪心放入<br>上一个思路极端情况需要每次把已使用并且还能使用的背包拿去放物品，也就是把已开始使用的背包循环了一遍，所以我们可以直接在二重循环上优化，优化方法就是如果c[m[i]] &gt; c[m[i + 1]]才重新从第一个背包开始装，不然从上次的背包开始继续装（很好理解，如果相等，那么前面的背包已经装满了，没必要从第一个背包开始去试）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> fi first</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> se second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll base, ll n)</span></span>&#123;ll ans = <span class="number">1</span>; <span class="keyword">while</span> (n)&#123;<span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = ans * base % mod; base = base * base % mod; n &gt;&gt;= <span class="number">1</span>;&#125; <span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt;n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line"></span><br><span class="line">sort (m + <span class="number">1</span>, m + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>, num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i ; -- i)&#123;</span><br><span class="line">	<span class="comment">///本质上就是每一组中至少包含一个c[m[i]]=t (t=任意数) 倒序从大到小放入方便贪心 </span></span><br><span class="line">	<span class="comment">///如果该组还能放入即 ans[p].size()&lt;c[m[i]] 那么可以贪心添加c[m[i]]=t的m[i]</span></span><br><span class="line">	<span class="keyword">if</span> (c[m[i]] &gt; c[m[i + <span class="number">1</span>]]) p = <span class="number">1</span>;<span class="comment">//没错，就这一句优化就让T变为171ms，和优先队列一样快</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (c[m[i]] == (<span class="keyword">int</span>)ans[p].<span class="built_in">size</span>()) num = <span class="built_in">max</span>(num, ++ p);</span><br><span class="line"></span><br><span class="line">	ans[p].pb(m[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++ i)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>, (<span class="keyword">int</span>)ans[i].<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> j : ans[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, j);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//二分法</p>
<p>假设t个背包能装下所有的物品,那么  t+1个背包一定也能装下所有的物品,满足二分性质,所以可以通过二分先求出最小的背包数量.<br>怎么check呢?<br>对于每一个  c[i],如果大于等于c[i]的物品要大于  mid*c[i]</p>
<p>那么当前的背包数量肯定是不满足答案的.</p>
<p>放物品非常简单,对物品的重量排序,然后每个背包轮流放一个即可</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,m[MAX],c[MAX],ans,tot[MAX];</span><br><span class="line">ll cnt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; list1[MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mid;++i) list1[i].<span class="built_in">clear</span>();</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">		cnt+=tot[i];</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">1l</span>l*c[i]*mid&lt;cnt) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m[i]),tot[m[i]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c[i]);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">2e5</span>;</span><br><span class="line">	<span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(check(l)) ans=l;</span><br><span class="line">	<span class="keyword">else</span> ans=r;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	sort(m+<span class="number">1</span>,m+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n,j=<span class="number">1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">		list1[j].push_back(m[i]);</span><br><span class="line">		++j;</span><br><span class="line">		<span class="keyword">if</span>(j&gt;ans) j=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;++i)&#123;</span><br><span class="line">		<span class="keyword">int</span> ls = list1[i].<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,ls);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ls;++j) <span class="built_in">printf</span>(<span class="string">"%d "</span>,list1[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	solve();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed85-D</title>
    <url>/2020/07/08/codeforces-Ed85-D/</url>
    <content><![CDATA[<p><a href="http://codeforces.ml/contest/1334/problem/D" target="_blank" rel="noopener">D - Minimum Euler Cycle</a></p>
<p>题意<br>有一个n个点的完全图 编号从1 到n<br>每两个点之间有两条路 所以共 n*(n-1)条边<br>n&lt;1e5<br>要求找到一条字典序最小的欧拉路<br>并输出 在第l到r时刻经过的点</p>
<p>构造 找规律 前缀和 二分<br>结合样例找规律容易发现路径为<br>1 2 1 3 1 4 1 5 … 1 n<br>2 3 2 4 2 5 … 2 n<br>3 4 3 5 3 6 … 3 n<br>…<br>1</p>
<p>这里要用到前缀和+二分了，先前缀和到每个区间末尾有多少个数，然后二分找在哪个区间再结合规律输出即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">"\n"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TurnoffIO std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> ll  maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll n,l,r,pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">judge</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;pre[n<span class="number">-1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> a=lower_bound(pre+<span class="number">1</span>,pre+n,x)-pre;</span><br><span class="line">	<span class="keyword">int</span> b=x-pre[a<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">return</span> (b&amp;<span class="number">1</span>?a:b/<span class="number">2</span>+a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			pre[i]=pre[i<span class="number">-1</span>]+<span class="number">2</span>*(n-i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(ll i=l;i&lt;=r;i++)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;judge(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>欧拉回路</tag>
        <tag>完全图</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed87-D</title>
    <url>/2020/07/08/codeforces-Ed87-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1354/problem/D" target="_blank" rel="noopener">D. Multiset</a></p>
<p>题意<br>要求实现一种multiset<br>可以插入数删除数<br>现在原来的multiset有n个数每个数为ai<br>q次操作<br>每次操作输入一个数x<br>若x&gt;0 则插入x<br>若x&lt;0则删除当前set中第|x|个数<br>问最后set中存在什么数输出其中一个</p>
<p>n q&lt;1e6 ai&lt;1e6</p>
<p>假设我们要找到最后set中第1个数<br>需要一个函数count能统计出在经过所有操作后set中比某数x小的有几个<br>可以用树状数组维护前缀和 (若n大于1e8)<br>二分枚举某数x查询它是否是set中的第k大 若count(x)==k 那么x就是set中第k大的数<br>为什么二分枚举的数x最后一定会落在set中某一个确定数中,因为二分的依据是判断set中比数x小的数有几个(count函数)<br>最后二分结果一定是逐渐逼近于“临界点”即在某个point 当x&lt;point, count=m x&gt;=point, count=m+1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> data[Max],ndata[Max];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_arr</span><span class="params">(<span class="keyword">int</span> bound)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(data[i]&lt;=bound)cnt++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ndata[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ndata[i]&lt;=bound)cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(ndata[i])&lt;=cnt)cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)<span class="built_in">cin</span>&gt;&gt;ndata[i];</span><br><span class="line">    <span class="keyword">if</span>(!count_arr(Max))<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">0</span>,R=Max,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(L+<span class="number">1</span>&lt;R)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(count_arr(mid)&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">                ans=mid;</span><br><span class="line">                R=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> L=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed87-E</title>
    <url>/2020/07/08/codeforces-Ed87-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1354/problem/E" target="_blank" rel="noopener">E. Graph Coloring</a></p>
<p>题意<br>有一个n个点m条边的无自环无向图<br>要求给每个点分别赋值 val=1,2,3;<br>存在以下限制<br>val=1,2,3的点分别不能超过n1,n2,n3 (n1+n2+n3==n)<br>且相邻两点的val差的绝对值=1<br>问是否能给这些点赋值且满足要求<br>n=5000，m=1e5</p>
<p>首先对于一个联通的子图 它可以被黑白染色成两部分<br>一部分赋值为2剩下的则为1和3</p>
<p>其次考虑所有子图构成的图<br>利用背包求解每个子图中是黑色赋值为2还是白色赋值为2<br>bool dp[i][j]表示对于前i个子图 有j个点赋值为2 时是否存在可行方案<br>初始化dp [0][0] =1<br>int  co i j 表示第j个子图中i(1/2)色有多少个点<br>那么前i个子图中有j+co[1/2][i]个点赋值为2时是否可行 dp i j+co[1/2][i] | = dp [i-1][j]以01背包形式转移<br>那么最后若 dp 总子图数  n2 ==1则存在解<br>可以根据 dp 总子图数 n2 逆向路径还原  若dp [i-1][j]-co[1/2][i] 有前继值那么一定可以追溯到 dp [0][0] ,<br>若dp [i-1][j]-co[1/2][i]均有则任选其中一条路径<br>用mk记录对于第i个子图是子图中染成白色赋值为2还是黑色赋值为2<br>最后输出答案</p>
<p>(转自某博客)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Start</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> mp(a,b) make_pair(a,b)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> x(a) a.first</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> y(a) a.second</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> b(a) a.begin()</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> e(a) a.end()</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> sz(a) int((a).size())</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> pb(a) push_back(a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e3</span>,M=<span class="number">1e5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N+<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> f[N+<span class="number">7</span>][N+<span class="number">7</span>],mk[N+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dfs</span></span><br><span class="line"><span class="keyword">int</span> d[N+<span class="number">7</span>],ct[N+<span class="number">7</span>],co[<span class="number">3</span>][N+<span class="number">7</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> cn)</span></span>&#123;</span><br><span class="line">	d[u]=t,ct[u]=cn,co[t][cn]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:e[u])</span><br><span class="line">		<span class="keyword">if</span>(!d[v]) Dfs(v,<span class="number">3</span>-t,cn); <span class="comment">//二分图染色</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d[u]+d[v]!=<span class="number">3</span>) <span class="built_in">puts</span>(<span class="string">"NO"</span>),<span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//不是二分图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">int</span> a,b,c; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">		e[u].pb(v),e[v].pb(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> w=<span class="number">0</span>;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!d[i])&#123;</span><br><span class="line">		Dfs(i,<span class="number">1</span>,++w); </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j+co[<span class="number">1</span>][w]&lt;=n&amp;&amp;f[w<span class="number">-1</span>][j]) f[w][j+co[<span class="number">1</span>][w]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(j+co[<span class="number">2</span>][w]&lt;=n&amp;&amp;f[w<span class="number">-1</span>][j]) f[w][j+co[<span class="number">2</span>][w]]=<span class="number">1</span>; <span class="comment">// 分组背包</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!f[w][b]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=w,j=b;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j-co[<span class="number">1</span>][i]&gt;=<span class="number">0</span>&amp;&amp;f[i<span class="number">-1</span>][j-co[<span class="number">1</span>][i]]) mk[i]=<span class="number">1</span>,j-=co[<span class="number">1</span>][i];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(j-co[<span class="number">2</span>][i]&gt;=<span class="number">0</span>&amp;&amp;f[i<span class="number">-1</span>][j-co[<span class="number">2</span>][i]]) mk[i]=<span class="number">2</span>,j-=co[<span class="number">2</span>][i]; <span class="comment">//回溯</span></span><br><span class="line">		<span class="comment">//if(j-co[1][i]&gt;=0&amp;&amp;f[i-1][j-co[1][i]]) mk[i]=1,j-=co[1][i];</span></span><br><span class="line">		<span class="comment">//if(j-co[2][i]&gt;=0&amp;&amp;f[i-1][j-co[2][i]]) mk[i]=2,j-=co[2][i]; </span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		原来是这么写的，没想到前面j-=co[1][i]会影响这里！！！</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(mk[ct[i]]==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(d[i]==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"2"</span>);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(a) <span class="built_in">printf</span>(<span class="string">"1"</span>),a--;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"3"</span>);				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(d[i]==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"2"</span>);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(a) <span class="built_in">printf</span>(<span class="string">"1"</span>),a--;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"3"</span>);				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>二分图染色</tag>
        <tag>路径还原</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed88-E</title>
    <url>/2020/07/08/codeforces-Ed88-E/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/problemset/problem/1359/E" target="_blank" rel="noopener">E. Modular Stability</a></p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个n<br>要求统计出有多少长度为k的数组 1&lt;=i&lt;=k; 1&lt;=ai&lt;=n<br>使得它的所有排列 对于任何数x都有<br>x mod a1 mod a2 mod a3 mod a4 … mod ak = x mod a[i1] mod a[i2] mod a[i3] … mod a[ik]</p>
<p>i1 , i2 , i3 …. ik 是 1到k的所有排列情况</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>首先需要发现一个事实即<br>当且仅当 所有ai mod min{aj | 1&lt;=j&lt;=k } ==0 或者说所有ai都能被其中最小的数aj整除<br>那么无论数组ai如何排列 对任意数x取模的最终结果是相同的</p>
<p>假设 a为数组中最小的数<br>x mod a mod ka =x mod ka mod a = x mod a</p>
<p>假设数组中存在一个m mod a !=0<br>那么 若x=a<br>则 x mod a=0 之后无论mod何数都为0<br>而 x mod m!=0 最后不一定为0</p>
<p>剩下的就是用逆元取组合数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll fac[Max];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;Max;i++)fac[i]=(fac[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=(ans*x)%mod;</span><br><span class="line">        x=(x*x)%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">combin</span><span class="params">(ll total,ll need)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;(fac[need]*fac[total-need])%mod&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;qpow(fac[need]*fac[total-need]%mod,mod-2)&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> (fac[total]*qpow(fac[need]*fac[total-need]%mod,mod<span class="number">-2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    intn();ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n,k;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n/i&lt;k)<span class="keyword">continue</span>;</span><br><span class="line">        ll have=n/i<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;have&lt;&lt;" "&lt;&lt;k-1&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;combin(have,k-1)&lt;&lt;endl;</span></span><br><span class="line">        ans=(ans+combin(have,k<span class="number">-1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>模运算</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed88-D</title>
    <url>/2020/07/08/codeforces-Ed88-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1359/problem/D" target="_blank" rel="noopener">D. Yet Another Yet Another Task</a></p>
<p>题意</p>
<p>长度为n的数组a 其中-30&lt;=ai&lt;=30</p>
<p>要求找到“区间和-区间最大值”的最大值<br>数组中包含负数<br>因为答案最小为 0<br>所以可以从 1 到 30 枚举可能的区间最大值<br>然后遍历寻找最大子段和<br>如果遍历到位置 i 时，前一段子段和小于 0 ，说明已经不是最优解，此时置nowsum为 0<br>如果遍历到位置 i 时，位置 i 的值 a[i] &gt; 枚举出的区间最大值 mx ，此时不符假设，说明第 i 个位置不可取，nowsum置 0<br>/*<br>或者将原数组中大于mx的数置为负无穷 </p>
<p>假设最大值L,R 在某个大于mx的数的左边<br>那么他会被nowsum 记录<br>假设最大值L,R 跨越某个大于mx的数<br>那么这个nowsum非法 因为假设L,R中的最大值为mx<br>这等效于某段nowsum&lt;0则删去该子段从当前数后一个数重新开始统计一个子段类似<br>由于子段可以为空那么nowsum不会小于0所以若某个数设为ai使得当前的连续子段和小于0<br>那么这个数一定不会被包括在最终取最大sum值的子段中<br>假设某子段[L,j]包括这个ai那么子段和sum[L<del>j]=sum[L</del>i]+sum[i+1<del>j]<br> sum[L</del>i]&lt;0那么显然sum[i+1<del>j]&gt;sum[L</del>j] 所以直接抛弃[L~i]从i+1开始从新统计sum和</p>
<p>其次为什么枚举到的区间中最大值若不存在也不会得到错误答案<br>由ans-mx构成的函数图像是<br>ans<br>|               /<br>|     /  |      / |<br>|   /    |    /   |     / |<br>| /      |  /     |   /   |<br>|         |/      |  /    |<br>|                  |/      |<br>|————————–&gt; mx</p>
<p>(用txt画图╮(╯▽╰)╭)</p>
<p>当mx枚举到区间中确实存在的数时函数会存在一个极值点<br>其他不存在的mx都会被更新掉 最后取max的值实际上都是极值点在比较 </p>
<p>*/</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> data[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num=<span class="number">0</span>;num&lt;=<span class="number">30</span>;num++)&#123;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            now+=data[i];</span><br><span class="line">            <span class="keyword">if</span>(now&lt;<span class="number">0</span>||data[i]&gt;num)now=<span class="number">0</span>;</span><br><span class="line">            sum=<span class="built_in">max</span>(now-num,sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>枚举</tag>
        <tag>最大子串和</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed89-D</title>
    <url>/2020/07/08/codeforces-Ed89-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1366/problem/D" target="_blank" rel="noopener">D.Two Divisors</a></p>
<p>题意<br>给出一个数组a<br>要求对每个ai求出两个它的因数d1 d2<br>使得gcd(d1+d2,ai)=1<br>若不存在则d1 d2=-1</p>
<p>题解<br>先取出ai的一个素因子d1<br>然后取出d2=ai/d1<br>若d2是d1的倍数那么一直除去d1直到d2%d1!=0<br>d2%d1!=0保证了 (d2+d1)也不是d1的倍数 所以就能保证gcd(d2+d1,ai)!=d1<br>同时也能保证最终的d2仍然是ai的因子<br>其次为什么gcd(d2+d1,ai)一定等于1<br>首先取出的d1是ai的最小素因子 已经排除gcd(d2+d1,ai)=d1的可能后<br>依次枚举ai的其他因子x (d1&lt;x&lt;=d2+d1)<br>即证(d2+d1)不是x的倍数 因为d1&lt;x所以 (d2+d1) mod x= d2 mod x +d1 mod x= d1 + (d2 mod x) !=0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> data[Max];</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"><span class="keyword">int</span> prime[Max],num=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;b1,b2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;Max;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])prime[num++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num&amp;&amp;i*prime[j]&lt;Max;j++)&#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    intn();</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;<span class="keyword">int</span> d1,d2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;prime[j]*prime[j]&lt;=data[i];j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i]%prime[j])<span class="keyword">continue</span>;</span><br><span class="line">            d1=prime[j];d2=data[i]/d1;</span><br><span class="line">            <span class="keyword">while</span>(d2%d1==<span class="number">0</span>)d2/=d1;</span><br><span class="line">            <span class="keyword">if</span>(d2!=<span class="number">1</span>)flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)b1.push_back(d1),b2.push_back(d2);</span><br><span class="line">        <span class="keyword">else</span> b1.push_back(<span class="number">-1</span>),b2.push_back(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:b1 )<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:b2)<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>gcd</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed90-D</title>
    <url>/2020/07/08/codeforces-Ed90-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1373/problem/D" target="_blank" rel="noopener">D.Maximum Sum on Even Positions</a></p>
<p>题意<br>给出一个长度为n&lt;2e5的数组ai<br>你可以将数组中的一个子串 倒置<br>使得这个数组中偶数位的sum最大</p>
<p>题解<br>倒置操作只有偶数长度子串会对最后sum产生影响<br>奇数长度的子串倒置后原来在偶数位的数仍然在偶数位</p>
<p>奇数长度倒置后原来奇数位的数变为偶数那么就相当于<br>原来偶数位的sum+(子串中奇数位和-子串中偶数位和)<br>所以考虑相邻两位两两做差作为一个整体放入新数组中<br>然后对新数组求最大子段和sub 与原来sum相加更新答案<br>由于原来数组长度n可能为奇数<br>所以相邻数两两做差有两种情况 都要考虑</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line"><span class="comment"># define endl '\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line">const <span class="keyword">int</span> Max=<span class="number">2</span>e5+<span class="number">5</span>;</span><br><span class="line">const <span class="keyword">int</span> Mod=<span class="number">1</span>e9+<span class="number">7</span>;</span><br><span class="line">ll data[Max],ndata[<span class="number">2</span>][Max];</span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">int main() &#123;</span></span><br><span class="line"><span class="regexp">    Turnoff;</span></span><br><span class="line"><span class="regexp">    int t;cin&gt;&gt;t;</span></span><br><span class="line"><span class="regexp">    while(t--)&#123;</span></span><br><span class="line"><span class="regexp">        int n;cin&gt;&gt;n;</span></span><br><span class="line"><span class="regexp">        ll sum=0,osum=0;int cnt1=0,cnt2=0;</span></span><br><span class="line"><span class="regexp">        for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="regexp">            cin&gt;&gt;data[i];</span></span><br><span class="line"><span class="regexp">            if(i&amp;1)&#123;</span></span><br><span class="line"><span class="regexp">                ndata[0][cnt1++]=data[i]-data[i-1];</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            else &#123;</span></span><br><span class="line"><span class="regexp">                sum+=data[i];</span></span><br><span class="line"><span class="regexp">                if(i)ndata[1][cnt2++]=data[i-1]-data[i];</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        ll minn=0,per=0,sub=0,ans=0;</span></span><br><span class="line"><span class="regexp">        for(int i=0;i&lt;cnt1;i++)&#123;</span></span><br><span class="line"><span class="regexp">            per+=ndata[0][i];</span></span><br><span class="line"><span class="regexp">            minn=min(minn,per);</span></span><br><span class="line"><span class="regexp">            sub=max(sub,per-minn);</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/cout&lt;&lt;sum&lt;&lt;" "&lt;&lt;sub&lt;&lt;endl;</span></span><br><span class="line"><span class="regexp">        ans=sum+sub;</span></span><br><span class="line"><span class="regexp">        per=0;minn=0;</span></span><br><span class="line"><span class="regexp">        for(int i=0;i&lt;cnt2;i++)&#123;</span></span><br><span class="line"><span class="regexp">            per+=ndata[1][i];</span></span><br><span class="line"><span class="regexp">            minn=min(minn,per);</span></span><br><span class="line"><span class="regexp">            sub=max(sub,per-minn);</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        ans=max(ans,sum+sub);</span></span><br><span class="line"><span class="regexp">        cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>最大子串和</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed90-E</title>
    <url>/2020/07/17/codeforces-Ed90-E/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/problemset/problem/1373/E" target="_blank" rel="noopener">E. Sum of Digits</a> </p>
<p>题意 </p>
<p>给定 n 和 k (1≤n≤150,0≤k≤9) ，找到最小的 x ，使得：</p>
<p>f(x)+f(x+1)+⋯+f(x+k)=n</p>
<p>其中f(x) 表示 x 的十进制数字的和</p>
<p>若不存在x则输出-1</p>
<p>题解</p>
<p>贪心的想:用最少位的数来构造出n</p>
<p>那么尽量用更多的9来减少x的位数才能使得答案最小</p>
<p>注意到n最大150 , 150/9 &lt;= 17 那么所有小于150的n能用f(x)+f(x+1)+⋯+f(x+k)来表示的x一定不超过longlong</p>
<p>而使用9来构造x导致了进位问题 不过题面条件限制k&lt;=9</p>
<p>意味着 x,x+1,x+2,….,x+k最多只进位一次</p>
<p>于是把数x拆分成4个部分来暴力枚举</p>
<p>首先考虑个位数。 因为k&lt;=9所以最直接影响到的是个位数上的数字</p>
<p>其次是个位之前有多少个连续的9。  因为个位数的进位会直接影响到十位以及之前的连续的9</p>
<p>枚举x这两部分的值后可以直接计算k+1个数对答案产生的贡献 sum</p>
<p>具体的：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> lastnum=<span class="number">0</span>;lastnum&lt;=<span class="number">9</span>;lastnum++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> suf9=<span class="number">16</span>;suf9&gt;=<span class="number">0</span>;suf9--)&#123;</span><br><span class="line">        ll sum=<span class="number">0</span>,cnt=<span class="number">1</span>;ll temp=lastnum;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;=suf9)&#123;</span><br><span class="line">            temp+=<span class="number">9</span>*qpow(<span class="number">10</span>,cnt);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;1&lt;&lt;" "&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lastnum+i&lt;<span class="number">10</span>)sum+=(<span class="number">9</span>*suf9+lastnum+i);</span><br><span class="line">            <span class="keyword">else</span> sum+=(<span class="number">1</span>+(lastnum+i)%<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*后续操作*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后rest=n-sum</p>
<p>如果rest&lt;=8那么当前枚举的符合要求的x首位就是8 后面接上枚举的连续的9和个位数值</p>
<p>否则 答案x需要在最前面插入一个8(因为suf9讨论的是个位进位会直接影响到的十进制位,8是最大的且不受后面进位影响的数) 然后贪心的填充余下 更高位的数</p>
<p>具体的</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n&lt;sum)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>((n-sum)%(k+<span class="number">1</span>))<span class="keyword">continue</span>;<span class="comment">///剩下的数若不能被(k+1)个数平分则表示当前枚举的x一定不是答案</span></span><br><span class="line">ll rest=(n-sum)/(k+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(rest&gt;<span class="number">8</span>)temp+=<span class="number">8</span>*qpow(<span class="number">10</span>,cnt),cnt++,rest-=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">while</span>(rest&gt;<span class="number">8</span>)&#123;<span class="comment">///贪心的填充用尽量大的数9来填充n-sum余下的值让x的位数更小</span></span><br><span class="line">	temp+=<span class="number">9</span>*qpow(<span class="number">10</span>,cnt);</span><br><span class="line">	cnt++;</span><br><span class="line">	rest-=<span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;2&lt;&lt;" "&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">temp+=rest*qpow(<span class="number">10</span>,cnt);</span><br><span class="line">ans=min(ans,temp);</span><br></pre></td></tr></table></figure>

<p>于是这样贪心构造出最后的x一定符合</p>
<p>首位 9999 8 9999 末位 这种形式</p>
<p>完整代码</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans*=x;</span><br><span class="line">        x*=x;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;ll ans=<span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> lastnum=<span class="number">0</span>;lastnum&lt;=<span class="number">9</span>;lastnum++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> suf9=<span class="number">16</span>;suf9&gt;=<span class="number">0</span>;suf9--)&#123;</span><br><span class="line">                ll sum=<span class="number">0</span>,cnt=<span class="number">1</span>;ll temp=lastnum;</span><br><span class="line">                <span class="keyword">while</span>(cnt&lt;=suf9)&#123;</span><br><span class="line">                    temp+=<span class="number">9</span>*qpow(<span class="number">10</span>,cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;1&lt;&lt;" "&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(lastnum+i&lt;<span class="number">10</span>)sum+=(<span class="number">9</span>*suf9+lastnum+i);</span><br><span class="line">                    <span class="keyword">else</span> sum+=(<span class="number">1</span>+(lastnum+i)%<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(n&lt;sum)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((n-sum)%(k+<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">                ll rest=(n-sum)/(k+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(rest&gt;<span class="number">8</span>)temp+=<span class="number">8</span>*qpow(<span class="number">10</span>,cnt),cnt++,rest-=<span class="number">8</span>;</span><br><span class="line">                <span class="keyword">while</span>(rest&gt;<span class="number">8</span>)&#123;</span><br><span class="line">                    temp+=<span class="number">9</span>*qpow(<span class="number">10</span>,cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                    rest-=<span class="number">9</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;2&lt;&lt;" "&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">                temp+=rest*qpow(<span class="number">10</span>,cnt);</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(ans!=<span class="number">1e18</span>)<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed91-E</title>
    <url>/2020/07/08/codeforces-Ed91-E/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1380/problem/E" target="_blank" rel="noopener">1380E - Merging Towers</a> </p>
<p>题意<br>汉诺塔背景下</p>
<p>n个柱子，m个圆盘，半径为[1,m] ，m&lt;=n&lt;=2e5</p>
<p>m次询问</p>
<p>每次将b柱上的圆盘并入a住上</p>
<p>之后求把所有 盘子移动到一个柱子上需要的最少操作次数 </p>
<p>题解</p>
<p>由于每种半径的盘子只有一个</p>
<p>想要把所有盘子移动道一个柱子上</p>
<p>只用重复一种操作 将半径=i的盘子a和上方半径小于a的盘子一起</p>
<p>放到半径=i+1的盘子b上 </p>
<p>反复操作最后一定能在最少步数内放到一个柱子上</p>
<p>如:[3,2,1],[8,7,6],[5,4] -&gt;[8,7,6],[5,4,3,2,1] -&gt;[8,7,6,5,4,3,2,1]</p>
<p>所以可以从最初状态得到第一个移动步数cnt</p>
<p>每次询问合并两个区间后的cnt都是上一次的cnt-sum</p>
<p>sum= (for r[i] in b柱子: r[i] -1 or r[i] +1 为半径的盘子出现在a柱子中 的个数)</p>
<p>如果直接暴力 每次询问将b柱子的并入a柱子</p>
<p>复杂度On*m 超时</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line">ll x,k,y,cnt;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; group[Max];</span><br><span class="line"><span class="keyword">int</span> belong[Max];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> n,m,cnt=<span class="number">0</span>;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        group[temp].insert(i);</span><br><span class="line">        belong[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(belong[i]!=belong[i+<span class="number">1</span>])cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;m--;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:group[a])<span class="keyword">if</span>(belong[i+<span class="number">1</span>]==b)cnt--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:group[b])&#123;</span><br><span class="line">            <span class="keyword">if</span>(belong[i+<span class="number">1</span>]==a)cnt--;</span><br><span class="line">            belong[i]=a;</span><br><span class="line">            group[a].insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        group[b].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用启发式合并的思想优化合并过程</p>
<p>即将小的集合并入大的集合 复杂度为O(n logn logn )</p>
<blockquote>
<p>均摊的情况：<br>1：每次合并两个集合O(N)<br>2：每次合并后，队列长度一定大于等于原来短的长度的两倍。<br>这样相当于每次合并都会让短的长度扩大一倍以上，<br>最多扩大logN次，所以总复杂度O(NlogN)，每次O(logN)</p>
</blockquote>
<p>两个集合合并时用set维护 .count() 和 .insert() 复杂度×logn </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; P;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; group[Max];</span><br><span class="line"><span class="keyword">int</span> belong[Max],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> siz[Max];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">found</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> belong[x]!=x?belong[x]=found(belong[x]):x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(siz[b]&gt;siz[a])group[b].swap(group[a]);</span><br><span class="line">    siz[a]+=siz[b];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:group[b])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span>&gt;<span class="number">0</span>&amp;&amp;group[a].count(i<span class="number">-1</span>))cnt--;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=n&amp;&amp;group[a].count(i+<span class="number">1</span>))cnt--;</span><br><span class="line">        <span class="comment">//group[a].insert(i);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:group[b])group[a].insert(i);</span><br><span class="line">    group[b].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        group[temp].insert(i);</span><br><span class="line">        belong[i]=temp;</span><br><span class="line">        siz[temp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(belong[i]!=belong[i+<span class="number">1</span>])cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;m--;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        unite(a,b);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方题解用并查集维护两集合合并操作</p>
<p>将一个柱子上的圆盘视作一个集合i</p>
<p>初始化 每个集合的父节点p[i]=i</p>
<p>合并操作: b并入a 则p[find(b)] =p[find(a)]</p>
<p>可以知道 find 的次数不超过 nlogn，且 find 复杂度平均为 O(α(n))，复杂度就不会超过 O(nlognα(n))。实际上，由于并查集的 find 函数有时只要 O(1) 时间，可能跑不满这个上界。 </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forn(i, n) for (int i = 0; i &lt; int(n); i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; val;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; who;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getp</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a == p[a] ? a : p[a] = getp(p[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	p.resize(m);</span><br><span class="line">	val.resize(m);</span><br><span class="line">	who.resize(n);</span><br><span class="line">	<span class="keyword">int</span> ans = n - <span class="number">1</span>;</span><br><span class="line">	forn(i, m)</span><br><span class="line">		p[i] = i;</span><br><span class="line">	forn(i, n)&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">		--x;</span><br><span class="line">		who[i] = x;</span><br><span class="line">		ans -= (i &amp;&amp; who[i] == who[i - <span class="number">1</span>]);</span><br><span class="line">		val[who[i]].push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	forn(i, m - <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> v, u;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;v, &amp;u);</span><br><span class="line">		v = getp(v - <span class="number">1</span>), u = getp(u - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (val[v].<span class="built_in">size</span>() &lt; val[u].<span class="built_in">size</span>())</span><br><span class="line">			swap(v, u);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x : val[u])&#123;</span><br><span class="line">			<span class="keyword">if</span> (x) ans -= who[x - <span class="number">1</span>] == v;</span><br><span class="line">			<span class="keyword">if</span> (x &lt; n - <span class="number">1</span>) ans -= who[x + <span class="number">1</span>] == v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x : val[u])&#123;</span><br><span class="line">			val[v].push_back(x);</span><br><span class="line">			who[x] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		p[u] = v;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed92-B</title>
    <url>/2020/07/30/codeforces-Ed92-B/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1389/problem/B" target="_blank" rel="noopener">B. Array Walk</a> </p>
<p>题意<br>有n&lt;1e5个格子每个位置有一个val&gt;0</p>
<p>从1号位置跳格子每次跳到一个格子i获得格子的val[i]</p>
<p>可以向左或向右跳前提是不超或边界</p>
<p>最初有sum=val[1] </p>
<p>现在限制跳k次,最多不能往左跳z次且不能连续向左跳</p>
<p>问最大得分</p>
<p>题解</p>
<p>一定是在某两个数之间反复横跳 或者直接走到底 最大</p>
<p>不会这里来回跳之后在其他位置再来回跳 </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll data[Max];</span><br><span class="line">ll sum[Max];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k,z;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;z;</span><br><span class="line">        z=<span class="built_in">min</span>(z,k/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">            <span class="comment">//if(i&gt;1)q.push(data[i]+data[i-1]);</span></span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+data[i];</span><br><span class="line">            <span class="comment">//cout&lt;&lt;sum[i]&lt;&lt;" ";</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        ll ans=<span class="number">0</span>,last=k+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;data[last]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=last;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">            ll temp=sum[i];</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">turn</span>=last-i;</span><br><span class="line">            <span class="keyword">int</span> left=(<span class="built_in">turn</span>+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;z)&#123;</span><br><span class="line">                temp+=data[i<span class="number">-1</span>]*z+data[i]*z;</span><br><span class="line">                temp+=sum[k<span class="number">-2</span>*z+<span class="number">1</span>]-sum[i];</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp+=data[i<span class="number">-1</span>]*left+data[i]*(<span class="built_in">turn</span>-left);</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,temp);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;temp&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>实现</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed92-C</title>
    <url>/2020/07/30/codeforces-Ed92-C/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1389/problem/C" target="_blank" rel="noopener">C. Good String</a> </p>
<p>题意<br>定义good string</p>
<p>符合某个字符串t1 t2 t3,,, tn变成两个新串s1,s2后s2=s1</p>
<p>其中s1=tn t1 t2…. tn-1 和s2= t2 t3 … tn t1 </p>
<p>现在给出 一个只含有0-9的字符串</p>
<p>问要删取最少几个字符能让他变成good string</p>
<p>题解</p>
<p>构成good string只有两种构造</p>
<p>变成xxxxxx or xyxyxyxyxy</p>
<p>枚举保留那两个数字xy 更新最少删除的方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll data[Max];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">     	<span class="built_in">string</span> s,ns=<span class="string">""</span>;<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        ns=s[len<span class="number">-1</span>]+s.substr(<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//ns2=s.substr(1,len)+s[0];</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;ns&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)num[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)num[i-<span class="string">'0'</span>]++;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">2e5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)ans=<span class="built_in">min</span>(ans,len-num[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> a=<span class="string">'0'</span>;a&lt;=<span class="string">'9'</span>;a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> b=<span class="string">'0'</span>;b&lt;=<span class="string">'9'</span>;b++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a==b)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ns[i]==a)flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(flag&amp;&amp;ns[i]==b)sum+=<span class="number">2</span>,flag=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;len-sum;</span></span><br><span class="line">                ans=<span class="built_in">min</span>(ans,len-sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed92-D</title>
    <url>/2020/07/30/codeforces-Ed92-D/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/contest/1389/problem/D" target="_blank" rel="noopener">D. Segment Intersections</a> </p>
<p>题意</p>
<p>有两种区间段[al,ar],[bl,br]</p>
<p>每个区间段有n个区间分别为</p>
<p>[al1,ar1],[al2,ar2]…[aln,arn]以及[bl1,br1],[bl2,br2]….[bln,brn]</p>
<p>要求最少扩张(区间向左或向右扩张1个单位)几次</p>
<p>使得$∑ intersection length([ali,ari],[bli,bri]) =k $</p>
<p>注意只考虑下标相同的[ali,ari]和[bli,bri]重叠区间长度 而[alx,arx]与[bly,bry] (x!=y) 不计算重叠长度</p>
<p>题解</p>
<p>分类讨论</p>
<p>若两个区间有交集</p>
<p>那么仅仅扩张一个单位区间a或区间b 就能使重叠区间+n (1换1)</p>
<p> 若a和b的区间被扩张到完全重合仍然不能满足$∑ intersection length([ali,ari],[bli,bri]) =k $</p>
<p>那么两个区间同时扩张 一个单元 使得重叠区间+n (2 换1)</p>
<p>再讨论没有交集的情况</p>
<p>根据样例发现 可以从n对区间中选择一部分x对区间进行扩张 </p>
<p>计算达到k个重叠单位长度所需要的操作次数</p>
<p>然后暴力枚举x 更新最小操作次数</p>
<p>每次枚举到对x对区间操作时 以同样的策略扩张 即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> data[Max];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n,k;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        ll al,ar,bl,br;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;al&gt;&gt;ar&gt;&gt;bl&gt;&gt;br;</span><br><span class="line">        <span class="comment">///让a区间整体小于b区间</span></span><br><span class="line">        <span class="keyword">if</span>(al&gt;bl)&#123;</span><br><span class="line">            swap(al,bl);</span><br><span class="line">            swap(ar,br);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///分情况有交集</span></span><br><span class="line">        <span class="keyword">if</span>(bl&lt;=ar)&#123;</span><br><span class="line">            ll inlen=<span class="built_in">min</span>(ar,br)-bl;</span><br><span class="line">            ll extend=<span class="built_in">max</span>(ar,br)-<span class="built_in">min</span>(al,bl)-inlen;</span><br><span class="line">            k-=inlen*n;<span class="comment">///减去已经重叠的部分</span></span><br><span class="line">            <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(extend*n&gt;=k)<span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">///若扩张到ab区间重合时重叠面积超过k</span></span><br><span class="line">            <span class="comment">///那么显然可以只用k次就达到要求</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;extend*n+(k-extend*n)*<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">///若扩张到等长度仍然不够用那么让两个区间同时扩张</span></span><br><span class="line">            <span class="comment">///只用其中a中(k-extend*n)个区间和b中(k-extend*n)个区间同时扩张</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">///没有交集</span></span><br><span class="line">            ll <span class="built_in">step</span>=<span class="number">1e18</span>;</span><br><span class="line">            <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                ll temp=i*(bl-ar);</span><br><span class="line">                ll extend=br-al;</span><br><span class="line">                <span class="keyword">if</span>(extend*i&gt;=k)<span class="built_in">step</span>=<span class="built_in">min</span>(<span class="built_in">step</span>,temp+k);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">step</span>=<span class="built_in">min</span>(<span class="built_in">step</span>,temp+extend*i+(k-extend*i)*<span class="number">2l</span>l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">step</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed93-C</title>
    <url>/2020/08/15/codeforces-Ed93-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1398/C" target="_blank" rel="noopener">C. Good Subarrays</a> </p>
<p>题意</p>
<p>给出一个数组(字符串形式) 每个位置有一个0~9的值</p>
<p>求出有多少个区间符合$∑_{i=l}^rai=r−l+1 $(区间和=区间长度) </p>
<p>题解</p>
<p>对于区间和问题想到数据结构或前缀和做差求区间和</p>
<p>对于这个问题要找到符合区间和=区间长度的区间有几个</p>
<p>我们可以先将这个条件转化一下 即变为 区间和 - 区间长度=0</p>
<p>我们扩展区间时 长度和区间和都在变化 但是每增加一个单位长度+1是确定的</p>
<p>于是就想到将区间长度信息融入到区间和,将 区间和 - 区间长度作为区间的整体属性 记为sum</p>
<p>对于数ai 将他加入某个区间,ai对区间和的贡献是 +ai 对区间长度的贡献是 +1</p>
<p>那么它对区间的sum属性的贡献是 +ai-1</p>
<p>于是从左到右维护一个前缀值sum</p>
<p>而我们要找的就是 当求得前i个数组成的区间(即前缀)的sum1 以它为右端点R</p>
<p>有多少个已被统计sum=sum1 能被作为左端点L  那么区间[L,R] 他就符合 区间和-区间长度=0</p>
<p>也就是：</p>
<p>区间和[1,R]-区间长度R = 区间和[1,L]-区间长度L</p>
<p>区间和(L,R]=区间长度R-区间长度L</p>
<p>区间和[L+1,R]=区间长度R-区间长度L</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">string</span> s;<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,ll&gt;cnt;cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=s[i]-<span class="string">'0'</span>;</span><br><span class="line">            temp--;sum+=temp;</span><br><span class="line">            ans+=cnt[sum];</span><br><span class="line">            cnt[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed92-E</title>
    <url>/2020/08/10/codeforces-Ed92-E/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/problemset/problem/1389/E" target="_blank" rel="noopener">E. Calendar Ambiguity</a> </p>
<p>题意</p>
<p>给出一种日历进制 一年有m个月 每个月有d天 一个星期有w天</p>
<p>问该日历进制下有多少数对(x,y) x月y日和y月x日在一个星期的同一天</p>
 <img src="/.io//timg.gif" data-original="example.png">

<p>如上图同一列的红圈表示数对(x,y) 符合题意描述</p>
<p>题解:</p>
<p>这个问题用数学语言描述则为</p>
<p>$((x-1)×d+y)mod w =((y-1)×d+x)mod w$</p>
<p>整理式子得到</p>
<p>$(x-y)(d-1)=0 (mod w)$</p>
<p>即求有多少对(x-y)能使(x-y)(d-1)为w的倍数</p>
<p>由于(d-1)与w为定值可以先约分化简</p>
<p>得到$w’=w/gcd(w,d-1)$</p>
<p>那么现在就是求有多少数对(x,y)满足$(x-y)=0 (mod w’)$,或者说$(x-y)=kw’$</p>
<p>x月y日和y月x日必须合法所以: x and y &lt;min(m,d)</p>
<p>然后考虑计数有多少对(x,y),假设k=1,那么有</p>
<p>x={1,2,3,…min(m,d)-w’}</p>
<p>y={1+w’,2+w’,…..min(m,d)}</p>
<p>共$min(m,d)-1×w’$对</p>
<p>同理统计$k=2,3,..,min(d,m)/w’$,k有min(d,m)/w’个值,</p>
<p>令$up=min(d,m)$,$num=up/w’$,那么用等差数列求和得到答案为</p>
<p>$ans=num ×up-num×(1+num)×w’/2$</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll m,d,w;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;d&gt;&gt;w;</span><br><span class="line">        <span class="comment">///(x-y)(d-1)mod w=0</span></span><br><span class="line">        w/=__gcd(d<span class="number">-1</span>,w);</span><br><span class="line">        ll up=<span class="built_in">min</span>(d,m);</span><br><span class="line">        ll num=up/w;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(num*up-num*(<span class="number">1</span>+num)/<span class="number">2</span>*w)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>gcd</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed93-D</title>
    <url>/2020/08/15/codeforces-Ed93-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1398/D" target="_blank" rel="noopener">D. Colored Rectangles</a> </p>
<p>题意</p>
<p>给出R对红木棒G对绿木棒B对蓝木棒 (R,G,B&lt;200)</p>
<p>每对木棒有不同的长度</p>
<p>要求用不同颜色的两对木棒构造出矩形</p>
<p>求所有矩形的总面积最大是多少</p>
<p>题解</p>
<p>首先每次拿两对木棒肯定是所属颜色集合中最长的两队</p>
<p>所以sort降序排列</p>
<p>贪心取三个最大的其中两个优先组成矩形 表面上很合理但是是错误的</p>
<p>比如：</p>
<p>R ：4 ，1</p>
<p>G：3， 3</p>
<p>B：4， 1</p>
<p>最大的值为4×3+4×3+1×1 而不是4×4+3×1+3×1 比较反直觉</p>
<p>正解是 设计一个三维dp(i,j,k)表示取前i对红的j对绿的k对蓝的所得到的最大值</p>
<p>本人太懒了 甚至不想复制 <a href="https://www.cnblogs.com/stelayuri/p/13508132.html" target="_blank" rel="noopener">详解参考</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">200</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll red[Max],green[Max],blue[Max];</span><br><span class="line">ll dp[Max][Max][Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R,G,B;<span class="built_in">cin</span>&gt;&gt;R&gt;&gt;G&gt;&gt;B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=R;i++)<span class="built_in">cin</span>&gt;&gt;red[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G;i++)<span class="built_in">cin</span>&gt;&gt;green[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=B;i++)<span class="built_in">cin</span>&gt;&gt;blue[i];</span><br><span class="line">    sort(red+<span class="number">1</span>,red+R+<span class="number">1</span>,greater&lt;ll&gt;());</span><br><span class="line">    sort(green+<span class="number">1</span>,green+G+<span class="number">1</span>,greater&lt;ll&gt;());</span><br><span class="line">    sort(blue+<span class="number">1</span>,blue+B+<span class="number">1</span>,greater&lt;ll&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=R;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=G;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=B;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;&amp;j&amp;&amp;k)&#123;</span><br><span class="line">                    dp[i][j][k]=<span class="built_in">max</span>(dp[i][j][k],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k]+red[i]*green[j]);</span><br><span class="line">                    dp[i][j][k]=<span class="built_in">max</span>(dp[i][j][k],dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>]+blue[k]*green[j]);</span><br><span class="line">                    dp[i][j][k]=<span class="built_in">max</span>(dp[i][j][k],dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>]+red[i]*blue[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&amp;&amp;j)&#123;</span><br><span class="line">                    dp[i][j][k]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k]+red[i]*green[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&amp;&amp;k)&#123;</span><br><span class="line">                    dp[i][j][k]=dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>]+red[i]*blue[k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j&amp;&amp;k)&#123;</span><br><span class="line">                    dp[i][j][k]=dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>]+blue[k]*green[j];</span><br><span class="line">                &#125;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,dp[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed93-E</title>
    <url>/2020/08/16/codeforces-Ed93-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1398/E" target="_blank" rel="noopener">E. Two Types of Spells</a> </p>
<p>题意</p>
<p>n个法术槽 n&lt;2e5</p>
<p>第i次会向法术槽种添加或删除一个法术(所有法术伤害不同)</p>
<p>tp=1是lighting 使出造成di点伤害并会使下一个法术伤害翻倍</p>
<p>tp=0是fire 使出造成di点伤害</p>
<p>每次 添加或删除一个法术后</p>
<p>求出某种出招顺序使得用当前存在的法术打出最大伤害</p>
<p>题解</p>
<p>首先考虑在某时刻 法术槽有k个lighting 和m个fire</p>
<p>最大伤害= 所有法术的伤害+ 其中最大的k个法术的伤害</p>
<p>因为lighting法术的buff 相当于能在使用k个法术造成伤害</p>
<p>于是从(k+m)个法术中选取k个伤害最大的最优</p>
<p>但是有个细节若k个伤害最大的法术全为lighting </p>
<p>那么其中伤害最小的lighting将无法被二次释放 </p>
<p>具体的以A为ligthing B为fire</p>
<p>若k个最大的全为lighting：</p>
<p>AA….AABBBB 那么最开始的A不能被释放两次</p>
<p>所以A(A…AB)B…BB 括号里的法术被释放两次</p>
<p>若k个最大的有至少一个为fire(B)</p>
<p>那么总有多余的A(不在前k大的法术中)可以使B释放两次 其余的A可以连续释放添加buff</p>
<p>所以无论如何最小的A放在最开始 两种情况都能构造出最大解</p>
<p>于是问题变成了：</p>
<p>1.向集合(Allspell和Light)中添加或删除法术</p>
<p>2.查询集合(Light)中最小伤害的法术</p>
<p>3.查询集合(Allspell)中k个伤害最大的法术</p>
<p>上述要求可以用权值线段树实现</p>
<p>/————————————-/</p>
<p>我们首先将n次向集合中添加或删除法术 离散化 作为建立权值线段树的预处理</p>
<p>然后第i次我们会向权值线段树(Allspell)中插入/删除一个所有操作中伤害第di大的法术</p>
<p>完成插入删除操作后求出最大伤害</p>
<p>对于之前讨论如何使用法术最优</p>
<p>可以先求出Light集合中的最小值minLight,将它从Allspell中删去</p>
<p>再求Allspell中求出k个伤害最大的法术</p>
<p>最后将minLight放回Light</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt;arr;</span><br><span class="line"><span class="keyword">int</span> tp[Max],op[Max];</span><br><span class="line">ll d[Max];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>ll sum,cnt;&#125;;</span><br><span class="line"><span class="comment">///cnt记录该结点下有几数</span></span><br><span class="line"><span class="comment">///sum记录该结点中所有数的和</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    Node tree[Max&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">        tree[now].sum=tree[now&lt;&lt;<span class="number">1</span>].sum+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">        tree[now].cnt=tree[now&lt;&lt;<span class="number">1</span>].cnt+tree[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> val,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            tree[node].cnt+=val;</span><br><span class="line">            tree[node].sum+=val*arr[l];</span><br><span class="line">            <span class="comment">///由于所有法术伤害不同其实这里不用×val</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)updata(pos,val,l,mid,node&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> updata(pos,val,mid+<span class="number">1</span>,r,node&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        push_up(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[node].cnt&lt;=k)<span class="keyword">return</span> tree[node].sum;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> arr[l];</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[node&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt&gt;=k)ans=querySum(k,mid+<span class="number">1</span>,r,node&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k-=tree[node&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;</span><br><span class="line">            <span class="comment">///这里相当于右结点有m个那从左右结点中取第k大就是在左结点找第k-m大的数</span></span><br><span class="line">            ans=tree[node&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+querySum(k,l,mid,node&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///由于我们不知道每次添加/删除后权值线段树的最小值所以每次必须询问最小值</span></span><br><span class="line">    <span class="comment">///此函数返回最小值在离散化数组中的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">queryMin</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[node&lt;&lt;<span class="number">1</span>].cnt)<span class="keyword">return</span> queryMin(l,mid,node&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> queryMin(mid+<span class="number">1</span>,r,node&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Allspell,Light;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;tp[i]&gt;&gt;d[i];</span><br><span class="line">        arr.push_back(<span class="built_in">abs</span>(d[i]));</span><br><span class="line">        op[i]=(d[i]&gt;<span class="number">0</span>);<span class="comment">//第i次操作是删除还是添加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///离散化</span></span><br><span class="line">    sort(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    arr.erase(unique(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>()),arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> len=arr.<span class="built_in">size</span>(),num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)d[i]=lower_bound(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),<span class="built_in">abs</span>(d[i]))-arr.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//将d[i]从原来的伤害重定义为所有伤害中第几大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"ok"&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(op[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(tp[i]==<span class="number">0</span>)Allspell.updata(d[i],<span class="number">1</span>,<span class="number">0</span>,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num++;<span class="comment">//记录有多少个Light法术</span></span><br><span class="line">                Allspell.updata(d[i],<span class="number">1</span>,<span class="number">0</span>,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">                Light.updata(d[i],<span class="number">1</span>,<span class="number">0</span>,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tp[i]==<span class="number">0</span>)Allspell.updata(d[i],<span class="number">-1</span>,<span class="number">0</span>,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num--;</span><br><span class="line">                Allspell.updata(d[i],<span class="number">-1</span>,<span class="number">0</span>,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">                Light.updata(d[i],<span class="number">-1</span>,<span class="number">0</span>,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"ok"&lt;&lt;endl;</span></span><br><span class="line">        ll ans=Allspell.tree[<span class="number">1</span>].sum;</span><br><span class="line">        <span class="keyword">if</span>(num)&#123;</span><br><span class="line">            <span class="keyword">int</span> minLight=Light.queryMin(<span class="number">0</span>,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            Allspell.updata(minLight,<span class="number">-1</span>,<span class="number">0</span>,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;ans&lt;&lt;" "&lt;&lt; Allspell.querySum(num,0,len-1,1)&lt;&lt;endl;</span></span><br><span class="line">            ans+=Allspell.querySum(num,<span class="number">0</span>,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            Allspell.updata(minLight,<span class="number">1</span>,<span class="number">0</span>,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>权值线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed94-B</title>
    <url>/2020/08/26/codeforces-Ed94-B/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1400/B" target="_blank" rel="noopener">B. RPG Protagonist</a> </p>
<p>题意</p>
<p>两个人偷武器 a只能拿最多p重量的物品,b只能拿最多f重量的物品</p>
<p>现在有重s的剑cnts把,重w的斧cntw把,问两个人最多带走几件物品</p>
<p>题解</p>
<p>对于最后的答案 其中一人先拿则尽量拿 ,拿到装不下 </p>
<p>而另一个人则从剩下的东西中优先取出轻的物品,拿完了再拿另外一种物品</p>
<p>按照高中的线性规划知识,a取出ps把剑和pw把斧一定在ps×s+pw×w&lt;=p的线上,由于是离散点</p>
<p>选择枚举取a拿ps把剑后取出尽量多的斧。然后再贪心的让另一个人取更轻的物品，然后更新最终答案</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">3e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll p,f;<span class="built_in">cin</span>&gt;&gt;p&gt;&gt;f;</span><br><span class="line">        ll cnts,cntw;<span class="built_in">cin</span>&gt;&gt;cnts&gt;&gt;cntw;</span><br><span class="line">        ll s,w,ans=<span class="number">0</span>;<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ps=<span class="number">0</span>;ps&lt;=cnts;ps++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ps*s&gt;p)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> pw=<span class="built_in">min</span>(cntw,(p-ps*s)/w),fs,fw;</span><br><span class="line">            <span class="keyword">if</span>(s&lt;w)&#123;</span><br><span class="line">                fs=<span class="built_in">min</span>(cnts-ps,f/s);</span><br><span class="line">                fw=<span class="built_in">min</span>(cntw-pw,(f-fs*s)/w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fw=<span class="built_in">min</span>(cntw-pw,f/w);</span><br><span class="line">                fs=<span class="built_in">min</span>(cnts-ps,(f-fw*w)/s);</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="number">1l</span>l*fw+fs+ps+pw);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed94-E</title>
    <url>/2020/08/28/codeforces-Ed94-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1400/E" target="_blank" rel="noopener">E. Clear the Multiset</a> </p>
<p>题意</p>
<p>给出一个数组a,长度为n&lt;5000</p>
<p>对于一次操作有两种选择：</p>
<p>1.使a[L~R]-1</p>
<p>2.使a[i]-x</p>
<p>问最少几次操作得到全为0的数组</p>
<p>题解</p>
<p>对于一个局面，我们的操作顺序并不影响最终的答案 </p>
<p>对于一个区间[L,R] 将其中的数全变为0,</p>
<p>要么只使用操作2,将L到R内的数逐个归0,共R-L+1次操作</p>
<p>要么找到区间内最小值minn,它在位置mpos</p>
<p>使用操作1将区间[L,R]都减去minn,递归求解[L,mpos-1]和[mpos+1,R]区间的子问题</p>
<p>则对于区间[L,R]的最小操作次数:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">ans=min(<span class="name">minn+divid_conquer</span>(<span class="name">L</span>,mpos-1,minn)+divid_conquer(<span class="name">mpos+1</span>,R,minn)-Min,R-L+1)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>其中Min为上个区间中的最小值,即[L,R]的区间最小值记为Min</p>
<p>[L,mpos-1]的区间最小值为minn，且minn&gt;=Min一定成立</p>
<p>对于递归边界当(L==R)是若data[L]-Min!=0则使用1次操作2 否则返回0 </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">5000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> data[Max];</span><br><span class="line"><span class="function">ll <span class="title">divid_conquer</span><span class="params">(ll L,ll R,ll Min)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;L&lt;&lt;" "&lt;&lt;R&lt;&lt;" "&lt;&lt;Min&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(L==R)<span class="keyword">return</span> (data[L]-Min&gt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;R)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minn=<span class="number">1e9</span>+<span class="number">5</span>,mpos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=L;i&lt;=R;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(minn&gt;data[i])&#123;</span><br><span class="line">            minn=data[i];</span><br><span class="line">            mpos=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="built_in">min</span>(minn+divid_conquer(L,mpos<span class="number">-1</span>,minn)+divid_conquer(mpos+<span class="number">1</span>,R,minn)-Min,R-L+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">    ll ans=divid_conquer(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed94-D</title>
    <url>/2020/08/28/codeforces-Ed94-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1400/D" target="_blank" rel="noopener">D. Zigzags</a> </p>
<p>题意</p>
<p>给出一个数组a ,长度为n &lt;3000</p>
<p>求出有多少对四元组$(i,j,k,l)$</p>
<p>使得$a_i=a_k$ 且$a_j=a_l$</p>
<p>题解</p>
<p>最暴力的方法分别枚举i,j,k,l 时间复杂度$On^4$</p>
<p>由于题目条件约束我们想到 将ai和ak作为一对，将aj和al作为一对</p>
<p>处理前缀以num作为ak有多少个位置i&lt;k满足ai=num</p>
<p>处理后缀以num作为aj有多少个位置l&gt;j满足al=num</p>
<p>然后再枚举数对$(j,k)$ 统计四元组 复杂度为$On^2$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">3000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> data[Max];</span><br><span class="line"><span class="keyword">int</span> K[Max][Max],J[Max][Max],dp[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num=<span class="number">1</span>;num&lt;=n;num++)&#123;</span><br><span class="line">                K[num][i]=K[num][i<span class="number">-1</span>]+(data[i]==num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num=<span class="number">1</span>;num&lt;=n;num++)J[num][n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num=<span class="number">1</span>;num&lt;=n;num++)&#123;</span><br><span class="line">                J[num][i]=J[num][i+<span class="number">1</span>]+(data[i]==num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k;j++)&#123;</span><br><span class="line">                ll L=K[data[k]][j<span class="number">-1</span>];</span><br><span class="line">                ll R=J[data[j]][k+<span class="number">1</span>];</span><br><span class="line">                cnt+=L*R;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed95-D</title>
    <url>/2020/09/15/codeforces-Ed95-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1418/problem/D" target="_blank" rel="noopener">D. Trash Problem</a> </p>
<p>题意</p>
<p>给出n&lt;1e5个不重复的点表示n个物品在x轴上的位置1&lt;=pos&lt;=1e9</p>
<p>要求将物品整理成最多2堆,</p>
<p>每次可以将一堆物品(在pos1)移动到某个位置(pos2) 消耗abs(pos2-pos1)的体力</p>
<p>当某些物品在同一个位置时就成为一堆 将被一起移动 移动消耗的体力仍然按距离算</p>
<p>q(1e5)组询问</p>
<p>每次输入两个数ops和pos</p>
<p>当ops=0时表示在上一次询问状态下 删除掉pos位置上的物品</p>
<p>当ops=1时表示在上一次询问状态下 在pos位置上增加物品</p>
<p>每次询问输出能将物品全部整理好的最少消耗体力</p>
<p>题解</p>
<p>当我们将所有物品汇聚到一堆时消耗的最少体力显然=最右端物品位置-最左端物品位置</p>
<p>显然当物品大于2个的时候分成两堆更省力 </p>
<p>最少消耗体力=最右端物品位置-最左端物品位置-最大相邻物品的间隔</p>
<p>(自己想当然的觉得以最右端和最左端的中间点为分割点 左半边归一堆，右半边归一堆)</p>
<p>剩下问题是如何处理多组询问</p>
<p>set具有优秀的查询能力 所以我们选择维护一个储存位置信息的set 和一个间距信息的multiset</p>
<p>每次询问时 ：</p>
<ul>
<li><p>若加入一个新物品 x 则 需要在set中加入x的位置 </p>
<p>同时在multiset里删除 x下一个物品的位置-x上一个物品的位置；</p>
<p>在multiset里加入x下一个物品的位置 - x的位置</p>
<p>在multiset里加入x的位置 - x上一个物品的位置</p>
</li>
<li><p>若删除一个物品 x 则 需要在set删除x的位置 </p>
<p>同时在multiset里加入 x下一个物品的位置-x上一个物品的位置；</p>
<p>在multiset里删除x下一个物品的位置 - x的位置</p>
<p>在multiset里删除x的位置 - x上一个物品的位置</p>
</li>
<li><p>注意上述操作需要判断插入/删除是否发生在最右端或最左端</p>
</li>
</ul>
<p>这里需要特别提醒set的一些用法误区和一些小技巧</p>
<ul>
<li><p>set的end()返回的是set的size并不是最后一个元素</p>
</li>
<li><p>set的erase()参数可以是值也可以是值对应的指针</p>
</li>
<li><p>multiset中erase()删除某个值(key)代表删除所有等于这个值的元素,</p>
<p>若只想删除其中一个则使用multset.erase(multset.find(key) )</p>
</li>
<li><p>set的find(key)时间复杂度为logn 返回key的指针</p>
</li>
<li><p>插入单个元素会返回一个 pair&lt;iterator，bool&gt; 对象 </p>
</li>
<li><p>注意set的指针对应元素会在插入/删除操作后产生变化</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;piles;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;gap;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;arr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n,q;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        arr.push_back(temp);</span><br><span class="line">        piles.insert(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.<span class="built_in">size</span>();i++)gap.insert(arr[i]-arr[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(piles.<span class="built_in">size</span>()&lt;=<span class="number">2</span>)<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxpos=*(--piles.<span class="built_in">end</span>()),minpos=*(piles.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">int</span> maxgap=*(--gap.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;maxpos-minpos-maxgap&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,pos;<span class="built_in">cin</span>&gt;&gt;op&gt;&gt;pos;</span><br><span class="line">        <span class="keyword">if</span>(op)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it=piles.insert(pos).first;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;it&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(next(it)!=piles.<span class="built_in">end</span>())gap.insert(*next(it)-pos);</span><br><span class="line">            <span class="keyword">if</span>(it!=piles.<span class="built_in">begin</span>())gap.insert(pos-*prev(it));</span><br><span class="line">            <span class="keyword">if</span>(it!=piles.<span class="built_in">begin</span>()&amp;&amp;next(it)!=piles.<span class="built_in">end</span>())gap.erase(gap.<span class="built_in">find</span>(*next(it)-*prev(it)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> it=piles.<span class="built_in">find</span>(pos);</span><br><span class="line">            <span class="keyword">if</span>(next(it)!=piles.<span class="built_in">end</span>())gap.erase(gap.<span class="built_in">find</span>(*next(it)-pos));</span><br><span class="line">            <span class="keyword">if</span>(it!=piles.<span class="built_in">begin</span>())gap.erase(gap.<span class="built_in">find</span>(pos-*prev(it)));</span><br><span class="line">            <span class="keyword">if</span>(it!=piles.<span class="built_in">begin</span>()&amp;&amp;next(it)!=piles.<span class="built_in">end</span>())gap.insert(*next(it)-*prev(it));</span><br><span class="line">            piles.erase(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(piles.<span class="built_in">size</span>()&lt;=<span class="number">2</span>)<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> maxpos=*(--piles.<span class="built_in">end</span>()),minpos=*(piles.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">int</span> maxgap=*(--gap.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;maxpos-minpos-maxgap&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed97-C</title>
    <url>/2020/10/30/codeforces-Ed97-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1437/C" target="_blank" rel="noopener">C. Chef Monocarp</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>有n&lt;200个食物在微波炉里每个食物有个完成时刻 $t_i$</p>
<p>每分钟只能从微波炉里拿一盘菜出来 </p>
<p>对于这盘菜产生的不满意度=|$t_i$-T| 其中T为当前拿出它的时间</p>
<p>问最小的不满意值 </p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>设计一个dp(T,i) 表示前t分钟取出前i盘菜 的最优解(先按照每盘菜的完成时刻排序)</p>
<p><del>一般dp设计思路都是一维表示位置(时间)一维表示状态</del></p>
<p>于是显然对于前T分钟取出前i盘菜的dp(T,i)</p>
<p>有两种方式转移到它 :</p>
<ul>
<li>到这一分钟我不拿菜 ,即 dp(T-1,i) -&gt; dp(T,i)</li>
<li>到这一分钟我拿出一盘菜 ,即dp(T-1,i-1) -&gt;dp(T,i)</li>
</ul>
<p>进一步说就是 dp(T,i)=min(dp(T-1,i),dp(T-1,i-1)+|T-$t_i$| )</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">7 7 7 7 7 7 7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> t[<span class="number">204</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">405</span>][<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> q;<span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;t[i];</span><br><span class="line">        sort(t+<span class="number">1</span>,t+n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="comment">//dp[0][0]=0;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">405</span>;i++)dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">405</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="built_in">abs</span>(i-t[j]));</span><br><span class="line">                <span class="comment">//dp[i][j]=min(dp[i-1][j],dp[i-1][j-1]+abs(i-t[j]));</span></span><br><span class="line">                <span class="comment">///两个一样</span></span><br><span class="line">                <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;dp[i][j]&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">404</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp(T,i)=min(dp(T-1,i),dp(T-1,i-1)+|T-$t_i$| ) 发现dp(T-1,i)/dp(T-1,i-1) 总之dp(T-1,x)只会被使用一次</p>
<p>即T-1 -&gt; T 时间维度的转移 完全可以从后往前遍历 来将这一维度省略掉</p>
<!--(因为省略掉时间维后转移时会导致dp含义变化)-->

<!--(dp(i)被更新后其含义就从上一刻取出前i盘的最优解变为这一刻取出前i盘的最优解)-->

<!--(从前往后会拿被更新为这一刻取出前x盘的结果来更新这一刻取出前i盘的结果)-->

<p>用类似背包dp的方式省略掉时间维度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> t[<span class="number">204</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">405</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> q;<span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;t[i];</span><br><span class="line">        sort(t+<span class="number">1</span>,t+n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//for(int i=1;i&lt;=400;i++)dp[i][0]=0;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">405</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j<span class="number">-1</span>]+<span class="built_in">abs</span>(i-t[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed94-E</title>
    <url>/2020/10/30/codeforces-Ed96-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1430/E" target="_blank" rel="noopener">E. String Reversal</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个长度为2e5的字符串s</p>
<p>要求只能通过交换相邻字母的操作将它变换成它的镜像字符</p>
<p>如aaaza -&gt;azaaa</p>
<p>问最少要几次操作</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>首先从s变换成它的镜像t</p>
<p>例如abac -&gt;caba</p>
<p>对于t串的第一个a 它一定从s串的第一个a移动得到</p>
<p>对于第t串的第二个a它一定从s串的第二个a移动得到</p>
<p>因为加入t串中第一个a用s串中第二个a ，第二个a用s串中第一个a </p>
<p>必定会导致在交换获得第二个a时会与前一个a交换位置 但这并不改变串的形态</p>
<p>所以这一步显然多余 为了避免这种情况发生 t串某个字母第几次出现 它就一定是</p>
<p>s串中第几次(从左到右遍历而言)出现的相同字母移动而来</p>
<p>实际上若不避免相同字母相邻互换操作产生的次数 </p>
<p>任意一种s-&gt;t所需的交换次数是相同的</p>
<p>无论是规定s中第几个a变为t中第几个a，还是先让某个位置的a先移动到达目标位置</p>
<p>找完t中每个字母从s中哪一位字母移动得到后</p>
<p>我们可以得到一个位置下标的映射数组</p>
<p>如abac为[1,2,3,4] -&gt; caba为[4,1,2,3] </p>
<p>那么这个问题就变成了将某个1到n的乱序排列 sort还原成1,2,3,4,5…n的排列</p>
<p>而最小交换相邻元素的次数实际上就是求逆序对个数</p>
<p>求逆序对科技很多 比如用权值线段树 并归排序 甚至字典树处理二进制位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegTree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Leftson now&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Rightson now&lt;&lt;1|1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span><span class="keyword">int</span> L,R;ll sum;&#125;;</span><br><span class="line">    segtree tree[Max&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">        tree[now].sum=tree[Leftson].sum+tree[Rightson].sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        tree[now]=&#123;L,R,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;L&lt;&lt;" "&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(L==R)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//int mid=(L+R)&gt;&gt;1;</span></span><br><span class="line">        build(L,mid,Leftson);</span><br><span class="line">        build(mid+<span class="number">1</span>,R,Rightson);</span><br><span class="line">        push_up(now);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> pos,ll val,<span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[now].L==tree[now].R)&#123;</span><br><span class="line">            tree[now].sum=tree[now].sum+val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=tree[Leftson].R)updata(pos,val,Leftson);</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;=tree[Rightson].L)updata(pos,val,Rightson);</span><br><span class="line">        push_up(now);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> qL,<span class="keyword">int</span> qR,<span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(qL&gt;qR)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[now].R&lt;=qR&amp;&amp;tree[now].L&gt;=qL)<span class="keyword">return</span> tree[now].sum;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[Leftson].R&gt;=qL)sum+=query(qL,qR,Leftson);</span><br><span class="line">        <span class="keyword">if</span>(tree[Rightson].L&lt;=qR)sum+=query(qL,qR,Rightson);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;GetInv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> to[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    ll n,ans=<span class="number">0</span>;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> s,t;<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    GetInv.build(<span class="number">1</span>,n);</span><br><span class="line">    t=s;reverse(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//cout&lt;&lt;t&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> x=<span class="string">'a'</span>;x&lt;=<span class="string">'z'</span>;x++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]!=x)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos&lt;n&amp;&amp;s[pos]!=x)pos++;</span><br><span class="line">            <span class="keyword">if</span>(pos==n)<span class="keyword">continue</span>;</span><br><span class="line">            to[i]=pos+<span class="number">1</span>;pos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;n;i++)cout&lt;&lt;to[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;GetInv.query(to[i]+1,n)&lt;&lt;" ";</span></span><br><span class="line">        ans+=GetInv.query(to[i]+<span class="number">1</span>,n);</span><br><span class="line">        GetInv.updata(to[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-Ed97-D</title>
    <url>/2020/10/30/codeforces-Ed97-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1437/problem/D" target="_blank" rel="noopener">D. Minimal Height Tree</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个BFS程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [] <span class="comment"># the order in which vertices were processed</span></span><br><span class="line">q = Queue()</span><br><span class="line">q.put(<span class="number">1</span>) <span class="comment"># place the root at the end of the queue</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    k = q.pop() <span class="comment"># retrieve the first vertex from the queue</span></span><br><span class="line">    a.append(k) <span class="comment"># append k to the end of the sequence in which vertices were visited</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> g[k]: <span class="comment"># g[k] is the list of all children of vertex k, sorted in ascending order</span></span><br><span class="line">        q.put(y)</span><br></pre></td></tr></table></figure>

<p>已知上图中序列a(BFS的访问顺序)</p>
<p>要求还原出一个以1号点为根的树 它的最小深度是多少</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>观察BFS程序发现对于一个点 访问它子节点的编号顺序是递增的</p>
<p>也就是说a序列中对于一个点i 它之后连续 的一段[i+L,i+R]是升序的</p>
<p>那么[i+L,i+R]都可以被归为点i的子节点 这样贪心构造的树能使深度最小</p>
<p>比如对于1 5 6 4 2 3 </p>
<p>可以划分为{1}{5,6}{4}{2,3} </p>
<p>5,6作为1的子节点 4作为5的子节点 2,3作为6的子节点</p>
<p>深度最小为2，贪心构造的思路比较显然 </p>
<p>具体实现比较巧妙用类似dp的方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> arr[Max];</span><br><span class="line"><span class="keyword">int</span> deep[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;deep[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">///若不符合升序则相邻两个点必然不在同一个点下作为子节点</span></span><br><span class="line">            <span class="comment">///所以cnt++</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;arr[i<span class="number">-1</span>])cnt++;</span><br><span class="line">            deep[i]=deep[cnt]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">///cnt为i的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;deep[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>实现</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-GlobalRound9-D</title>
    <url>/2020/07/08/codeforces-GlobalRound9-D/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1375/problem/D" target="_blank" rel="noopener">D.Replace by MEX</a></p>
<p>题意:</p>
<p>你被给予了一个数组，包含n个[0, n]的整数。每一次操作，你可以选择数组中的一个元素替换成这个数组的MEX。<br>例如，如果数组是[0, 2, 2, 1, 4]，你可以选择第二个元素替换成整个数组元素的MEX，数组会变成[0, 3, 2, 1, 4]。<br>MEX的定义为不包含这个于这个数组的最小的非负整数。</p>
<p>分析:<br>首先，题目给出操作的次数最多为2n次，这是不是暗示我们先把数组通过n次变成一个样子，再通过n次变成另一个样子？我们把ai≠i称之为一个未修复点，我们可以进行如下的操作来修复每一个点。<br>1.如果mex = n，我们就任意地替换一个未修复点。<br>2.如果mex &lt; n，我们就替换下标是mex的点。<br>这两个操作最多2n次，每一次操作可以使得未修复的点减少一次。<br>为什么这么做呢？因为每次如果求出一个mex = n的时候，就可以使得下一次修复的时候，mex &lt; n。我们的目的就是为了修复一个点的时候，让mex &lt; n，这样可以正常的修复。求mex是线性的。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> data[Max],cnt[Max];</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)cnt[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">            cnt[data[i]]++;</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ti=<span class="number">2</span>*n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ops;</span><br><span class="line">        <span class="keyword">bool</span> check=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ti)&#123;<span class="comment">///最多2n次让原数组变成1 2 3 4 5.....</span></span><br><span class="line">            <span class="keyword">int</span> num;<span class="keyword">bool</span> ok=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[i]&gt;<span class="number">1</span>)check=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num=i;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(check)&#123;<span class="comment">///把每个数组中的数都变成只出现一次的数 其实没必要</span></span><br><span class="line">                <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[data[i]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                        cnt[data[i]]--;</span><br><span class="line">                        cnt[num]++;ti--;</span><br><span class="line">                        data[i]=num;flag=<span class="number">0</span>;</span><br><span class="line">                        ops.push_back(i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)check=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">///每求出一个mex==0 替换一个data[num]!=num的数之后mex必然&gt;0 即每个位置最多被操作两次</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(num)&#123;<span class="comment">///如果不是0 将下标为num的改为num 之后这个位置的数不会在变化</span></span><br><span class="line">                    vis[num]=<span class="number">1</span>;</span><br><span class="line">                    cnt[data[num]]--;</span><br><span class="line">                    data[num]=num;</span><br><span class="line">                    cnt[num]++;</span><br><span class="line">                    ops.push_back(num);</span><br><span class="line">                    ti--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">///如果是0则选择一个data[num]!=num的数 替换</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">                        cnt[data[i]]--;</span><br><span class="line">                        data[i]=num;</span><br><span class="line">                        cnt[num]++;ti--;</span><br><span class="line">                        ops.push_back(i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(data[i]&lt;data[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    ok=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ok)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for(int i=1;i&lt;=n;i++)cout&lt;&lt;data[i]&lt;&lt;" ";</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ops.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:ops)<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>MEX</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-GlobalRound9-E</title>
    <url>/2020/07/09/codeforces-GlobalRound9-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1375/problem/E" target="_blank" rel="noopener">E. Inversion SwapSort</a></p>
<p>题意</p>
<p>给出一个长度为n的数组a</p>
<p>要求对它进行排序</p>
<p>排序的要求是只能使用原数组中逆序对下标的位置进行swap</p>
<p>比如原数组第u位和第v位形成逆序对 那么只能对数组的第u位和第v位进行swap</p>
<p>新数组中可能有新的逆序对第x位和第y位 但不能swap(ax,ay)</p>
<p>而且要用到所有逆序对下标 且只能用一次 (感觉怪怪的这不就直接等于逆序对?)</p>
<p>要求给出一种swap顺序使得最终的数组非降序</p>
<p>或者说</p>
<p>求一种将每个<strong>原数组中的逆序对</strong>下标 (u,v) 的排列，使依次交换每个 (au,av) 后，ai 不减</p>
<p><a href="https://www.cnblogs.com/dysyn1314/p/13246526.html" target="_blank" rel="noopener">题解参考</a></p>
<blockquote>
<p>考虑a  是一个排列时怎么做。</p>
<p>我们设pos[v] 表示v  这个数在a  里出现的位置。也就是pos[a[i]]=i  </p>
<p>从边界入手，我们先尝试把nn  放到排列的最后一个位置，然后转化为规模减11  的子问题。具体来说，假设一波操作后，我们得到的排列为bb  ，则bb  需要满足如下条件：</p>
<ul>
<li>b[n]=nb[n]=n  。</li>
<li>∀1≤i,j&lt;n 如果a[i]&lt;a[j] ，则b[i]&lt;b[j]  。</li>
<li>∀1≤i,j&lt;n 如果a[i]&gt;a[j] ，则b[i]&gt;b[j]  。</li>
</ul>
<p>也就是说，要保证前面的数的**<em>相对大小关系不变**</em>，这样才能转化为一个等价的子问题。</p>
<p>我们怎么做呢？可以依次操作：交换(pos[a[n]+1],n)  ,(pos[a[n]+2],n)  ,(pos[a[n]+3],n)   ,……,(pos[n],n)  。 交换操作(indx , indx)</p>
</blockquote>
<p>具体的</p>
<p>比如原数组 ：5 4 2 1 3</p>
<p>第一次交换 pos[a[5]+1]=pos[4]=2 与 数组中第n个数交换</p>
<p>交换结果为 :  5 3 2 1 4</p>
<p>假设原数组中最大的数n不在位置n , 那么a[n]+1一定小于n 且显然a[n]+1&gt;a[n]</p>
<p>那么数a[n]+1与a[n]显然构成逆序对</p>
<blockquote>
<p>容易发现，这样一轮操作完成后，首先，n  被放到了最后。同时，前面所有大于a[n] 的数，相当于集体减1  ，显然前面所有数的相对大小关系不变。并且，我们恰好用掉了所有包含（位置）n  的逆序对。所以剩下的是一个规模减1  的子问题，继续做，直到n=1  即可。</p>
<p>于是我们就解决了排列的情况。相当于我们用构造的方法证明了，a  是一个排列时，一定有解。</p>
<p>再考虑不是排列的时候。对于两个相等的数a[i]=a[j]   (i&lt;j  )，我们强行令a[i]&lt;a[j]  ，也就是以数值为第一关键字，位置为第二关键字，强行转成一个排列。发现转成排列后，序列里的逆序对和原来是一样的，所以直接按排列求解即可。</p>
<p>时间复杂度O(n2)</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>离散化</tag>
        <tag>构造</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-GlobleRound11-C</title>
    <url>/2020/10/12/codeforces-GlobleRound11-C/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1427/C" target="_blank" rel="noopener">C. The Hard Work of Paparazzi </a></p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出一个r×r(r&lt;500)的点阵图 </p>
<p>n(n&lt;1e6)个明星会分别在ti时刻出现在点(xi,yi)</p>
<p>一个人t=0时刻在(1,1)点,他想和这几个明星相遇(相同时刻在同一地点)</p>
<p>(这几个明星出现的时刻 $t_i$ 严格递增)</p>
<p>每一秒钟他能上下左右移动一个单位 在直角坐标范围内</p>
<p>问他最多能与几个人相遇</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>首先想到这个问题可以用$On^2$ 的dp解决 但是n&lt;1e6 需要优化dp的时间复杂度</p>
<p>注意到时间和人数的量级十分大 而图的大小最大是500×500 两点之间最远距离为2r-2</p>
<p>于是猜想优化枚举方法是否与2r相关。</p>
<p>有几个事实需要注意到：</p>
<ul>
<li>对于第i个明星和第j个明星而言 一定有$i-j&lt;=t_i-t_j$ 即两人下标差小于等于</li>
<li>对于第i个明星和第j个明星而言 一定有$dis(i,j)&lt;2r$ 即两人距离小于2r</li>
<li>若这个人在第i个明星的位置他想要与第j个明星相遇 需要满足$dis(i,j)&lt;=t_i-t_j$</li>
</ul>
<p>于是我们可以得到 对于第i个明星和第j个明星若他俩的下标差大于2r </p>
<p>那么这个人一定可以从第i个明星的位置到第j个明星的位置等待第j个明星出现和他相遇</p>
<img src="/.io//timg.gif" data-original="example.png">

<ul>
<li>当$i-j&lt;2r$ 时 对于i可能存在多个j满足$dis(i,j)&lt;=t_i-t_j$，所以 对于i 遍历$j=[i-2r,i)$</li>
</ul>
<p>​    <img src="/.io//timg.gif" data-original="example2.png"></p>
<ul>
<li><p>当$i-j&gt;=2r$ 时 对于i所有属于$[0,i-2r]$区间内的j 都可以转移到i点 </p>
<p>(Because the condition $dis(i,j)&lt;=t_i-t_j$ always hold )</p>
<p>即这个人一定可以从第i个明星的位置到第j个明星的位置等待第j个明星出现和他相遇</p>
</li>
</ul>
<p>综上所述：</p>
<p>对于第i个明星,我们需要遍历$j=[i-2r,i)$ 从j转移到i 也要考虑从$j=[0,i-2r]$ 中 最优的值转移到i</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> dp[Max],t[Max],x[Max],y[Max],maxn[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> r,n;<span class="built_in">cin</span>&gt;&gt;r&gt;&gt;n;</span><br><span class="line">    y[<span class="number">0</span>]=x[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">///注意第0时刻他在(1,1)点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=<span class="number">-1e9</span>;<span class="comment">//赋值为-inf 若某个点无法到达应该为-inf 而不是0,0表示能到达但不会与任何人相遇</span></span><br><span class="line">        <span class="comment">///边界i-2r是否遍历不影响因为i-2r一定能转移到i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="built_in">max</span>(<span class="number">0</span>,i<span class="number">-2</span>*r);L&lt;i;L++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(x[i]-x[L])+<span class="built_in">abs</span>(y[i]-y[L])&lt;=t[i]-t[L])&#123;</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[L]+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;dp[i]&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">2</span>*r)dp[i]=<span class="built_in">max</span>(dp[i],<span class="number">1</span>+maxn[i<span class="number">-2</span>*r]);</span><br><span class="line">        <span class="comment">///这里就是i-j&gt;=2r的情况</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;dp[i]&lt;&lt;endl;</span></span><br><span class="line">        maxn[i]=<span class="built_in">max</span>(maxn[i<span class="number">-1</span>],dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxn[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>规律发现</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-RaifRound1-E</title>
    <url>/2020/09/15/codeforces-RaifRound1-E/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1428/problem/E" target="_blank" rel="noopener">E. Carrots for Rabbits</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>给出n&lt;1e5个萝卜每个萝卜的长度为$a_i$&lt;1e6</p>
<p>现在要分给k个兔子(k&gt;=n&amp;&amp;k&lt;1e5) 你能将萝卜切成长度不同的小份</p>
<p>使得每个兔子能分到一段萝卜 </p>
<p>它们吃萝卜所消耗的时间为其分到萝卜长度的平方即$len^2$ </p>
<p>求它们吃萝卜所消耗的时间和(注意是$∑len_i^2$)最少是多少</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>参考<a href="https://codeforces.ml/blog/entry/83771" target="_blank" rel="noopener">官方题解</a></p>
<p>首先定义一个函数$f(len,pieces)$ </p>
<p>表示将一根长度为len的胡萝卜分成pieces份 后给兔子吃所需的最小总时间</p>
<ul>
<li>对于一根萝卜如何求它的$f(len,pieces)$ ？</li>
</ul>
<p>当pieces=2,我们分成等长的两段(或长度尽量接近)所需的总时间最小</p>
<p>当pieces=3,我们分成等长的三段(或长度尽量接近)所需的总时间最小</p>
<p>因为$f(len,pieces)=∑_i^{pieces} len_i^2$ 最长的那段取平方后总会产生较大的时间消耗</p>
<p>所以直觉上均分能获得最优解(所需总时间最小) </p>
<ul>
<li>这个规律即：对一个sum分成若干份每份取等次幂(推测)求和总是均分更优</li>
</ul>
<p>我们需要切k-n刀才够每个兔子分 每次切能减小总时长最大的那个萝卜</p>
<p>即$f(len,pieces)-f(len,pieces+1)$  最大的那个萝卜</p>
<p>于是用优先队列每次切一刀取出$f(len,pieces)-f(len,pieces+1)$最大的那个萝卜</p>
<p>到这里这题就可以解决了</p>
<p>但是题解中提到$f(l,p−1)−f(l,p)≥f(l,p)−f(l,p+1) $</p>
<p>其含义是 对同一根萝卜多次切 所能减少的总时间是非增的 (逐渐减少)</p>
<p>用数字表示就是8可以分成4 4和2 2 2 2</p>
<p>8 -&gt; 4 4 减少的总时间小于 4 4 -&gt; 2 2 2 2 减少的时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">ll arr[Max],Pi[Max],NeedTime[Max];</span><br><span class="line"><span class="function">ll <span class="title">cut</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">int</span> pieces)</span></span>&#123;</span><br><span class="line">    ll Newlen=len/pieces;</span><br><span class="line">    ll Pieces_NewlenAddone=len%pieces;</span><br><span class="line">    ll Pieces_Newlen=pieces-Pieces_NewlenAddone;</span><br><span class="line">    ll tot=Newlen*Newlen*Pieces_Newlen+(Newlen+<span class="number">1</span>)*(Newlen+<span class="number">1</span>)*Pieces_NewlenAddone;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    ll sum=<span class="number">0</span>;k=k-n;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,less&lt;P&gt; &gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];Pi[i]=<span class="number">1</span>;</span><br><span class="line">        sum+=arr[i]*arr[i];</span><br><span class="line">        q.push(&#123;arr[i]*arr[i]-cut(arr[i],<span class="number">2</span>),i&#125;);</span><br><span class="line">        NeedTime[i]=cut(arr[i],<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        P temp=q.top();q.pop();</span><br><span class="line">        <span class="keyword">int</span> i=temp.second;ll cost=temp.first;</span><br><span class="line">        sum-=cost;Pi[i]++;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;cut(arr[i],Pi[i]+1)&lt;&lt;endl;</span></span><br><span class="line">        q.push(&#123;NeedTime[i]-cut(arr[i],Pi[i]+<span class="number">1</span>),i&#125;);</span><br><span class="line">        NeedTime[i]=cut(arr[i],Pi[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>规律发现</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces-GlobleRound7-D2</title>
    <url>/2020/07/08/codeforces-GlobleRound7-D2/</url>
    <content><![CDATA[<p><a href="https://codeforc.es/problemset/problem/1326/D2" target="_blank" rel="noopener">D2. Prefix-Suffix Palindrome (Hard version)</a></p>
<p>题意<br>要求从s中找到一个t<br>使得 t的长度不超过s<br>t是回文串<br>存在s的前缀a和后缀b a+b=t<br>|s|&lt;1e5</p>
<p>题解<br>先从两边取对称的前后缀，之后再取余下字符串较长的回文前缀或后缀用马拉车实现</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">"\n"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">///字符串预处理,插入#,则实际回文串长度等于插入后半径p[i]-1</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">makestr</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> t=<span class="string">"#"</span>;<span class="comment">///在开头和结尾多插入'$'防止越界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)t+=str[i],t+=<span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">malacher</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> t=makestr(str);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;t&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;p(t.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,id=<span class="number">0</span>,ilenth=<span class="number">0</span>,icenter=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">///mx 表示当前右侧最远的回文子串右端位置 id 表示当前右侧最远的回文子串中间字符位置</span></span><br><span class="line">    <span class="comment">///ilenth表示最长回文子串长度,icenter表示最长回文子串中间位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="comment">///利用mx和id,和回文串对称性质动态更新以任意一个字符为中心的回文串半径</span></span><br><span class="line">        p[i]=i&lt;mx?<span class="built_in">min</span>(p[<span class="number">2</span>*id-i],mx-i):<span class="number">1</span>;<span class="comment">///p [2*id-i]=p[j] (j是i关于id对称点 因为id-j=i-id所以j=id-(i-id)=2*id-i )</span></span><br><span class="line">        <span class="keyword">while</span>(t[i-p[i]]==t[i+p[i]])p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(p[i]+i&gt;mx)&#123;</span><br><span class="line">            mx=p[i]+i;</span><br><span class="line">            id=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[i]&gt;ilenth)&#123;</span><br><span class="line">            ilenth=p[i];</span><br><span class="line">            icenter=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Maxlen=<span class="number">0</span>;<span class="comment">///p[i]==i+1 以第i位为中心的回文串长度=p[i],若它是前缀则长度也=i+1(0也计入)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)<span class="keyword">if</span>(p[i]==i+<span class="number">1</span>)Maxlen=p[i];<span class="comment">///此步适应了本题做的改动</span></span><br><span class="line">    <span class="keyword">return</span> str.substr(<span class="number">0</span>,Maxlen<span class="number">-1</span>);<span class="comment">///插入#,则实际回文串长度等于插入后半径p[i]-1</span></span><br><span class="line">    <span class="comment">///首位置,预处理后的长度-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[l]==s[r]&amp;&amp;l&lt;r)l++,r--;</span><br><span class="line">        <span class="built_in">string</span> s1=s.substr(l,r-l+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> s2=s1;reverse(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//cout&lt;&lt;s1&lt;&lt;" "&lt;&lt;s2&lt;&lt;endl;</span></span><br><span class="line">        s1=malacher(s1);</span><br><span class="line">        s2=malacher(s2);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;s1&lt;&lt;" "&lt;&lt;s2&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s.substr(<span class="number">0</span>,l)&lt;&lt;(s1.<span class="built_in">size</span>()&gt;s2.<span class="built_in">size</span>()?s1:s2)&lt;&lt;s.substr(r+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营2-C</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A52-C/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3003/C" target="_blank" rel="noopener">C.算概率</a></p>
<p>题意<br>有n道题<br>给出每到题做对的概率pi (取模1e9+7的意义下的pi)<br>问n道题答对 0 1 2 3 4…..n道的概率mod 1e9+7<br>如做对的概率为p=1/2 在mod 1e9+7 的意义下为p’=500000004<br>///没有对小数或分数的取模的概念 只有转化为除法取模<br>p=a/b在mod1e9+7的意义下的值为p’  p’ × b mod 1e9+7==a<br>某数x乘概率p 再取mod == x×a/b mod 1e9+7 除法取模等于乘逆元<br>上式== x×a×b的逆 mod 1e9+7 而a×b的逆==p’ 即p在mod1e9+7意义下的值<br>1-p 在mod 1e9+7意义下 =1-p’+mod</p>
<p>题解</p>
<p>​fi,j 表示前 i道题做对 j道的概率 转移时考虑第 j 道题是否做对，<br>转移方程为f{i,j}=f{i−1,j}×(1−pi)+f{i−1,j−1}×pi</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"># include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line"># define endl <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line">ll data[<span class="number">2005</span>];</span><br><span class="line">const ll mod=(ll)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    for(int i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;data[i];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;//dp[<span class="number">1</span>][<span class="number">0</span>]=(mod+<span class="number">1</span>-data[<span class="number">1</span>]);dp[<span class="number">1</span>][<span class="number">1</span>]=data[<span class="number">1</span>];</span><br><span class="line">    for(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            if(j!=<span class="number">0</span>)dp[i][j]=((dp[i<span class="number">-1</span>][j<span class="number">-1</span>]*data[i])<span class="comment">%mod+(dp[i-1][j]*(mod+1-data[i]))%mod)%mod;</span></span><br><span class="line">            else dp[i][j]=dp[i<span class="number">-1</span>][j]*(mod+<span class="number">1</span>-data[i])<span class="comment">%mod;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=<span class="number">0</span>;i&lt;=n;i++)cout&lt;&lt;dp[n][i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>模运算</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>始</title>
    <url>/2020/07/08/%E5%A7%8B/</url>
    <content><![CDATA[<p>缓慢更新ing。。。</p>
<h5 id="7-8日更新"><a href="#7-8日更新" class="headerlink" title="7.8日更新"></a>7.8日更新</h5><p>search 站内搜索</p>
<p>tags 标签</p>
<p>categories 分类</p>
<h5 id="7-9日更新"><a href="#7-9日更新" class="headerlink" title="7.9日更新"></a>7.9日更新</h5><p>同步部署到gitee/github/coding的仓库中</p>
<p>gitee ：<a href="https://peigizhu.gitee.io/">https://peigizhu.gitee.io</a> (不能自动部署)</p>
<p>github: <a href="https://peigizhu.github.io/" target="_blank" rel="noopener">https://peigizhu.github.io</a> (访问加载缓慢)</p>
<p>coding: <a href="http://551qze.coding-pages.com/" target="_blank" rel="noopener">http://551qze.coding-pages.com</a> (地址难记)</p>
<p>加入图片lazy_load </p>
<p>Typora可视化编辑</p>
<p>加入文章置顶功能</p>
<h5 id="7-10日更新"><a href="#7-10日更新" class="headerlink" title="7.10日更新"></a>7.10日更新</h5><p>添加了Gitalk 评论 但是只能在peigizhu.github.io 中使用</p>
<p>扩充了图库 封面随机抽取</p>
<p>替换原版主题音乐 (进入某个页面后点击上方播放按钮即可)</p>
<p>替换了lazy_load 加载图片</p>
<p>加入百度自动推送</p>
<h5 id="7-12日更新"><a href="#7-12日更新" class="headerlink" title="7.12日更新"></a>7.12日更新</h5><p>加入百度统计</p>
<p>加入valine评论插件替换原来的gitalk 欢迎评论</p>
<p>修复代码高亮</p>
<p>#####7.22日更新</p>
<p>可在文章内插入图片(无法显示尝试刷新)</p>
<p>修复mathjax 文章内使用公式</p>
]]></content>
      <categories>
        <category>Notice</category>
      </categories>
      <tags>
        <tag>Updata</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营2-E</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A52-E/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3003/E?&headNav=acm" target="_blank" rel="noopener">E.做计数</a></p>
<p>题意<br>求有多少个不同的正整数三元组 i j k<br>满足 sqrt(i)+sqrt(j)=sqrt(k) —— 等式1 且 i×j&lt;=n;<br>三元组满足 i1!=i2 or j1!=j2 or k1!=k2视为不同</p>
<p>将等式1两边平方 发现 i+j+sqrt(i×j)=k<br>sqrt(i×j)&lt;=sqrt(n);<br>枚举 i×j 再枚举i</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ij=<span class="number">1</span>;ij*ij&lt;=n;ij++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ji=ij*ij;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=ji;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ji%i)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(ji/i!=i)cnt+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营2-F</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A52-F/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3003/F" target="_blank" rel="noopener">F.拿物品</a></p>
<p>题意<br>有n个数每个数 ai bi两个属性<br>两人轮流拿 A先<br>A最后获得的分数为 他拿到的所有物品中ai的和<br>B最后获得的分数为 他拿到的所有物品中bi的和<br>两人都想比对方分高问两者怎么拿输出他们拿到的物品</p>
<p>题解</p>
<p>​假设物品已经被选完，此时 牛牛选择的物品 A 属性的价值和是 N ， 牛可乐选择的物品 B 属性价值和是 M 。 如果 牛牛的 (a1,b1)物品与 牛可乐的 (a2,b2)( 交换，则 N′=N−a1+a2,M′=M+b1−b2 ，对于 牛牛（目标是最大化 N−M ）来说会变得更优仅当 a1+b1&lt;a2+b2 （ N′−M′&gt;N−M化简就能得到），对于 牛可乐也一样。所以两人都会优先选择 ai+bi 最大的物品。 将物品按照两个属性的和从大到小排序，依次分给两人即可。 除排序时间复杂度 O(n) 。</p>
<p>突破口从最后两者取到的价值交换后取得最优解的情况</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125;data[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Data x,Data y)</span></span>&#123;<span class="keyword">return</span> x.a+x.b&gt;y.a+y.b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;data[i].a,data[i].pos=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;data[i].b;</span><br><span class="line">    sort(data,data+n,cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans1,ans2;</span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">turn</span>=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">turn</span>)ans1.push_back(data[i].pos);</span><br><span class="line">        <span class="keyword">else</span> ans2.push_back(data[i].pos);</span><br><span class="line">        <span class="built_in">turn</span>=!<span class="built_in">turn</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1=ans1.<span class="built_in">size</span>(),len2=ans2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)<span class="built_in">cout</span>&lt;&lt;ans1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++)<span class="built_in">cout</span>&lt;&lt;ans2[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营2-H</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A52-H/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3003/H" target="_blank" rel="noopener">H.释魔法</a></p>
<p>题意<br>牛可乐有 n 个元素( 编号 1..n )，第 i 个元素的能量值为 ai。 牛可乐可以选择至少 k 个元素来施放一次魔法，魔法消耗的魔力是这些元素能量值的极差。形式化地，若所用元素编号集合为 S，则消耗的魔力为 max ⁡i∈S{ai}−min ⁡i∈S{ai}</p>
<p>牛可乐要求每个元素必须被使用恰好一次。 牛可乐想知道他最少需要多少魔力才能用完所有元素。</p>
<p>题解</p>
<p>首先将元素按能量值排序<br>dp i表示用掉前i个元素的最小代价<br>dp i=min (1&lt;=j&lt;=i-k+1) {dp [j-1]+ ai - aj} =min (..) {dp [j-1] -aj} +ai;<br>维护 dp[j-1] -aj的最小前缀 O1转移</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll dp[(<span class="keyword">int</span>)<span class="number">3e5</span>+<span class="number">5</span>];</span><br><span class="line">ll data[(<span class="keyword">int</span>)<span class="number">3e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> ll maxn=(ll)<span class="number">1e9</span>+<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">    sort(data+<span class="number">1</span>,data+n+<span class="number">1</span>);</span><br><span class="line">    ll per=-data[<span class="number">1</span>];<span class="comment">///初始化最开始2k个都是由它来更新</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)dp[i]=maxn;<span class="comment">///前k-1个不满足至少k个元素的要求</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=per+data[i];<span class="comment">///大于k个作为一组需消耗data[i]-data[1]</span></span><br><span class="line">        per=<span class="built_in">min</span>(per,dp[i-k+<span class="number">1</span>]-data[i-k+<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">///为下个dp i+1更新 计算per, 那么对于右端点i+1他的左端点就最大就是i-k+2,上一个区间的右端点就是i-k+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>优化技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营2-G</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A52-G/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3003/G" target="_blank" rel="noopener">G.拿物品</a></p>
<p>题意<br>t组样例 -1e9&lt;=a b c g&lt;=1e9<br>0&lt;=d,e,f&lt;=1e9;<br>判定  a ^ d+b ^ e+c ^ f==g<br>由于直接快速幂会爆ll</p>
<p>题解</p>
<p>原式取模的意义下，有概率成立，我们可以多取几个模提高真确率</p>
<p>取mod后有概率形成不冲突映射对</p>
<p>类hash的思路 觉得很玄学</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=(ll)<span class="number">1e9</span>+<span class="number">8</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=(ans*x)%mod;</span><br><span class="line">        x=(x*x)%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll a,b,c,g;</span><br><span class="line">        ll d,e,f;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f&gt;&gt;g;</span><br><span class="line">        <span class="keyword">if</span>((qpow(a,d)+qpow(b,e)+qpow(c,f))%mod==g)<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>hash</tag>
        <tag>模运算</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营3-E</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A53-E/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3004/E" target="_blank" rel="noopener">E.牛牛的随机数</a></p>
<p>题意</p>
<p>现在牛牛从自然数区间[l1,r1]中随机给出一个数字a，牛可乐从自然数区间[l2,r2]中随机给出一个数字b。l,r&lt;1e18问你a ⊕ b的数学期望。其中⊕为位运算符，表示按位取异或。</p>
<p>题解</p>
<p>将每一个数拆分成二进制和=1+2+4+8…<br>那么 a 异或 b的数学期望= (异或得到1 2 4 8 ..等二进制数产生的贡献)/总数</p>
<p>把所有的数字从0开始枚举，然后转化成二进制输出，我们发现二进制下最低位位的规律是010101…循环，倒数第二位是001100110011…循环，而倒数第三位是0000111100001111…循环。<br>接下来的话就跟上面差不多。<br>假设x∈[l1,R1]中二进制的最低位产生0的数目为cntx0二进制的最低位位产生1的数目为cntx1  y∈[l2,R2]中二进制的最低位位产生0的数目为cnty0二进制的最低位位产生1的数目为cnty1那么就产生了cnty0×cntx1+cntx0×cnty1的贡献。<br>如果是二进制的倒数第二位呢，那么就是(cnty0×cntx1+cntx0×cnty1)×2。       </p>
<p>那么二进制的倒数第k位的贡献就为(cnty0×cntx1+cntx0×cnty1)×2^k</p>
<p>可以学习计算1到r某位二进制数上1的个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod=(ll)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;x=x*x%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">getcnt1</span><span class="params">(ll pos,<span class="keyword">int</span> bits)</span></span>&#123;</span><br><span class="line">    pos++;<span class="comment">///从0到pos共有pos+1个数</span></span><br><span class="line">    ll ans=(pos/(<span class="number">2l</span>l&lt;&lt;bits)*(<span class="number">1l</span>l&lt;&lt;bits))%mod;<span class="comment">///计算从1到pos有多少个1 对于bits位每隔(2&lt;&lt;bits)就有(1&lt;&lt;bits)个1和0</span></span><br><span class="line">    ans=(ans+(pos/(<span class="number">1l</span>l&lt;&lt;bits)&amp;<span class="number">1</span>)*(pos%(<span class="number">1l</span>l&lt;&lt;bits)))%mod;<span class="comment">///每隔奇数个(1&lt;&lt;bits)就会有连续的1 pos%(1ll&lt;&lt;bits)计算超过这部分的1</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get1</span><span class="params">(ll L,ll R,<span class="keyword">int</span> bits)</span></span>&#123;<span class="keyword">return</span> (mod+getcnt1(R,bits)-getcnt1(L<span class="number">-1</span>,bits))%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get0</span><span class="params">(ll L,ll R,<span class="keyword">int</span> bits)</span></span>&#123;<span class="keyword">return</span> (mod+(R-L+<span class="number">1</span>)%mod-get1(L,R,bits))%mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll l1,r1,l2,r2;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line">        ll invQ=(((r1-l1+<span class="number">1</span>)%mod)*((r2-l2+<span class="number">1</span>)%mod))%mod;</span><br><span class="line">        invQ=qpow(invQ,mod<span class="number">-2</span>);ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">62</span>;i++)&#123;</span><br><span class="line">            ll val=(<span class="number">1l</span>l&lt;&lt;i)%mod;</span><br><span class="line">            ans=(ans+((((get1(l1,r1,i)*get0(l2,r2,i)%mod+get1(l2,r2,i)*get0(l1,r1,i)%mod)*val)%mod)*invQ)%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>规律发现</tag>
        <tag>位运算</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营2-I</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A52-I/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3003/I" target="_blank" rel="noopener">I.建通道</a></p>
<p>题意<br>有n个星球 每个有权值vi<br>两星球vi和vj建边 花费  lowbit(vi xor vj) 如 lowbit(5)=1 lowbit(8)=8<br>如果要让n个星球两两相通问最少花费</p>
<p>题解</p>
<p>​首先将权值去重（权值相等的点连接代价为 0 ），设去重后有 m 个点，接下来找到最小的二进制位 k ，满足存在 vi 的这个二进制位是 0 且存在 vj 的这个二进制位是 1 ，答案就是 2^k×(m−1) （相当于所有这位是 0 的点与 j 点连边，是 1 的点与 i点连边）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll data[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans*=x;</span><br><span class="line">        x*=x;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">    sort(data,data+n);ll k=<span class="number">0</span>;</span><br><span class="line">    n=unique(data,data+n)-data;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">30</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag1=<span class="number">0</span>,flag0=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((data[j]&gt;&gt;i)&amp;<span class="number">1</span>)flag1=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> flag0=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag0&amp;&amp;flag1)&#123;k=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;qpow(<span class="number">2</span>,k)*(n<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营3-G</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A53-G/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3004/G" target="_blank" rel="noopener">牛牛的Link Power II</a></p>
<p>题意<br>牛牛有一颗大小为n的神奇Link-Cut 数组，数组上的每一个节点都有两种状态，一种为link状态，另一种为cut状态。数组上任意一对处于link状态的无序点对（即(u,v)和(v,u)被认为是同一对）会产生dis(u,v)的link能量，dis(u,v)为数组上u到v的距离。 我们定义整个数组的Link能量为所有处于link状态的节点产生的link能量之和。 一开始数组上每个节点的状态将由一个长度大小为n的01串给出，’1’表示Link状态，’0’表示Cut状态。 牛牛想要知道一开始，以及每次操作之后整个数组的Link能量，为了避免这个数字过于庞大，你只用输出答案对1e9+7取余后的结果即可。 </p>
<p>题解<br>就我们发现每个“1”对于它本身位置产生的影响贡献为0，而往后面依次产生了0,1,2,3,4,5…的贡献<br>比如10001 对于第一个1到第二个1共产生 4的贡献<br>那么可以在每个1的位置到最后一个位置全部+1<br>那么对于一个1 我们可以 求和区间 [1到它当前位置] 上的贡献来计算出这个1产生的值</p>
<p>开两颗线段树，一颗叫pre树，一颗叫suf树，然后对于每个位置为pos的”1”，都在pre树的[pos+1,n]这个区间加上1，在suf树中的[1,pos−1]这个区间加上1    然后对于每个1，他跟别人产生的贡献就是pre树的sum(1,pos)+suf树的sum(pos,n)sum</p>
<p>因为加入删除1 的操作 不但会对之后的1产生新的贡献(所以更新pre[pos+1,n])<br>自身也会对之前的1产生贡献(所以更新suf[1,pos-1])<br>比如100001在中间0-&gt;1 那么第1个1对中间的1产生贡献用pre[1,pos]统计 并更新pre[pos+1,n], 最后的1对中间的1产生贡献用suf[pos,n]统计 并更新suf[1,pos-1]</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"># include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line"># define endl '\n'</span><br><span class="line"></span><br><span class="line">const <span class="built_in">int</span> maxn=(<span class="built_in">int</span>)<span class="number">1</span>e5+<span class="number">5</span>;</span><br><span class="line">const ll <span class="built_in">mod</span>=(ll)<span class="number">1</span>e9+<span class="number">7</span>;</span><br><span class="line">struct Tree&#123;</span><br><span class="line">    ll <span class="built_in">sum</span>,lazy;</span><br><span class="line">    <span class="built_in">int</span> L,R;</span><br><span class="line">&#125;;</span><br><span class="line">struct Segment_Tree&#123;</span><br><span class="line">    Tree tree[<span class="number">4</span>*maxn];</span><br><span class="line">    void push_up(<span class="built_in">int</span> root)&#123;tree[root].<span class="built_in">sum</span>=(<span class="built_in">mod</span>+tree[root&lt;&lt;<span class="number">1</span>].<span class="built_in">sum</span>+tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].<span class="built_in">sum</span>)%<span class="built_in">mod</span>;&#125;</span><br><span class="line">    void push_down(<span class="built_in">int</span> root)&#123;</span><br><span class="line">        <span class="built_in">if</span>(tree[root].lazy)&#123;</span><br><span class="line">            tree[root&lt;&lt;<span class="number">1</span>].lazy=(<span class="built_in">mod</span>+tree[root&lt;&lt;<span class="number">1</span>].lazy+tree[root].lazy)%<span class="built_in">mod</span>;</span><br><span class="line">            tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy=(<span class="built_in">mod</span>+tree[root].lazy+tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy)%<span class="built_in">mod</span>;</span><br><span class="line">            tree[root&lt;&lt;<span class="number">1</span>].<span class="built_in">sum</span>=(<span class="built_in">mod</span>+tree[root&lt;&lt;<span class="number">1</span>].<span class="built_in">sum</span>+tree[root].lazy*(tree[root&lt;&lt;<span class="number">1</span>].R-tree[root&lt;&lt;<span class="number">1</span>].L+<span class="number">1</span>)%<span class="built_in">mod</span>)%<span class="built_in">mod</span>;</span><br><span class="line">            tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].<span class="built_in">sum</span>=(<span class="built_in">mod</span>+tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].<span class="built_in">sum</span>+tree[root].lazy*(tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].R-tree[root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].L+<span class="number">1</span>)%<span class="built_in">mod</span>)%<span class="built_in">mod</span>;</span><br><span class="line">            tree[root].lazy=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void build(<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> root=<span class="number">1</span>)&#123;</span><br><span class="line">        tree[root].L=l,tree[root].R=r;</span><br><span class="line">        tree[root].<span class="built_in">sum</span>=<span class="number">0</span>,tree[root].lazy=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">if</span>(l==r)return ;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">mid</span>=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        build(l,<span class="built_in">mid</span>,root&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        build(<span class="built_in">mid</span>+<span class="number">1</span>,r,root&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        push_up(root);</span><br><span class="line">    &#125;</span><br><span class="line">    void updata(<span class="built_in">int</span> qL,<span class="built_in">int</span> qR,ll val,<span class="built_in">int</span> <span class="built_in">now</span>=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">if</span>(tree[<span class="built_in">now</span>].L&gt;=qL&amp;&amp;tree[<span class="built_in">now</span>].R&lt;=qR)&#123;///注意取到的条件</span><br><span class="line">            tree[<span class="built_in">now</span>].<span class="built_in">sum</span>=(<span class="built_in">mod</span>+tree[<span class="built_in">now</span>].<span class="built_in">sum</span>+val*(tree[<span class="built_in">now</span>].R-tree[<span class="built_in">now</span>].L+<span class="number">1</span>)%<span class="built_in">mod</span>)%<span class="built_in">mod</span>;</span><br><span class="line">            tree[<span class="built_in">now</span>].lazy=(<span class="built_in">mod</span>+tree[<span class="built_in">now</span>].lazy+val)%<span class="built_in">mod</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(<span class="built_in">now</span>);</span><br><span class="line">        <span class="built_in">if</span>(qL&lt;=tree[<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>].R)updata(qL,qR,val,<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">if</span>(qR&gt;=tree[<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].L)updata(qL,qR,val,<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        push_up(<span class="built_in">now</span>);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ll query(<span class="built_in">int</span> qL,<span class="built_in">int</span> qR,<span class="built_in">int</span> <span class="built_in">now</span>=<span class="number">1</span>)&#123;///注意<span class="built_in">if</span>的条件</span><br><span class="line">        <span class="built_in">if</span>(tree[<span class="built_in">now</span>].R&lt;=qR&amp;&amp;tree[<span class="built_in">now</span>].L&gt;=qL) return tree[<span class="built_in">now</span>].<span class="built_in">sum</span>;</span><br><span class="line">        push_down(<span class="built_in">now</span>);</span><br><span class="line">        ll <span class="built_in">sum</span>=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">if</span>(tree[<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>].R&gt;=qL)<span class="built_in">sum</span>=(<span class="built_in">mod</span>+<span class="built_in">sum</span>+query(qL,qR,<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>))%<span class="built_in">mod</span>;</span><br><span class="line">        <span class="built_in">if</span>(tree[<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].L&lt;=qR)<span class="built_in">sum</span>=(<span class="built_in">mod</span>+<span class="built_in">sum</span>+query(qL,qR,<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>))%<span class="built_in">mod</span>;</span><br><span class="line">        return <span class="built_in">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;pre,suf;</span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span>;cin&gt;&gt;<span class="built_in">n</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    pre.build(<span class="number">0</span>,<span class="built_in">n</span>-<span class="number">1</span>);</span><br><span class="line">    suf.build(<span class="number">0</span>,<span class="built_in">n</span>-<span class="number">1</span>);</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">n</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">if</span>(s[i]=='<span class="number">1</span>')&#123;</span><br><span class="line">            ans=(ans+pre.query(<span class="number">0</span>,i))%<span class="built_in">mod</span>;</span><br><span class="line">            //cout&lt;&lt;pre.query(<span class="number">0</span>,i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="built_in">if</span>(i!=<span class="built_in">n</span>-<span class="number">1</span>)pre.updata(i+<span class="number">1</span>,<span class="built_in">n</span>-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">if</span>(i!=<span class="number">0</span>)suf.updata(<span class="number">0</span>,i-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">t</span>;cin&gt;&gt;<span class="built_in">t</span>;</span><br><span class="line">    while(<span class="built_in">t</span>--)&#123;</span><br><span class="line">        <span class="built_in">int</span> ops,pos;</span><br><span class="line">        cin&gt;&gt;ops&gt;&gt;pos;pos--;</span><br><span class="line">        ll presum=pre.query(<span class="number">0</span>,pos);///在它之前的<span class="number">1</span>对它产生的贡献</span><br><span class="line">        ll sufsum=suf.query(pos,<span class="built_in">n</span>-<span class="number">1</span>);///它之后的<span class="number">1</span>对它产生的贡献</span><br><span class="line">        <span class="built_in">if</span>(ops==<span class="number">1</span>)&#123;</span><br><span class="line">            ans=(ans+presum+sufsum)%<span class="built_in">mod</span>;</span><br><span class="line">            <span class="built_in">if</span>(pos!=<span class="built_in">n</span>-<span class="number">1</span>)pre.updata(pos+<span class="number">1</span>,<span class="built_in">n</span>-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">if</span>(pos!=<span class="number">0</span>)suf.updata(<span class="number">0</span>,pos-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            ans=(<span class="number">2</span>*<span class="built_in">mod</span>+ans-presum-sufsum)%<span class="built_in">mod</span>;</span><br><span class="line">            <span class="built_in">if</span>(pos!=<span class="built_in">n</span>-<span class="number">1</span>)pre.updata(pos+<span class="number">1</span>,<span class="built_in">n</span>-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">if</span>(pos!=<span class="number">0</span>)suf.updata(<span class="number">0</span>,pos-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营5-B</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A55-B/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3006/B" target="_blank" rel="noopener">牛牛战队的比赛地</a></p>
<p>题意<br>由于牛牛战队经常要外出比赛，因此在全国各地建立了很多训练基地，每一个基地都有一个坐标(x,y)<br>这周末，牛牛队又要出去比赛了，各个比赛的赛点都在x轴上。牛牛战队为了方便比赛，想找一个到达训练基地最大距离最小的地方作为比赛地。</p>
<p>题解</p>
<p>三分法模板题目<br>三分答案位置<br>三分法维护mid=l+(r-l)/2;<br>和midr=mid+(r-mid)/2;<br>对于极小值 凹函数<br>如果mid&gt;midr 那么最小值在 mid 到r之间<br>如果mid&lt;midr 那么最小值在 l 到midr之间</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> esp=(<span class="keyword">double</span>)<span class="number">1e-6</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;<span class="built_in">point</span>[(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> temp=(<span class="built_in">point</span>[i].y*<span class="built_in">point</span>[i].y+(<span class="built_in">point</span>[i].x-x)*(<span class="built_in">point</span>[i].x-x));</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(maxn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;<span class="built_in">point</span>[i].x&gt;&gt;<span class="built_in">point</span>[i].y;</span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">-10000</span>,r=<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fabs</span>(l-r)&gt;esp)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> midr=mid+(r-mid)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)&gt;check(midr))l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=midr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4f\n"</span>,check(l));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营4-D</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A54-D/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3005/D" target="_blank" rel="noopener">子段异或</a></p>
<p>题意<br>输入一个数列a，你需要输出其中异或值为0的不同子段的数量。一个子段 [l,r] (<br>1≤l≤r≤n)的异或值为al⊕al+1⊕al+2⊕…⊕ar，其中⊕符号代表异或运算。</p>
<p>题解</p>
<p>如果[l,r]是合法的子段，说明前缀和中xorsum[r]^xorsum[l-1] = 0, xorsum[l-1] = xorsum[r]。求出异或前缀和，然后使用map计数每一个数字有多少个前缀和等于那个数字即可。 </p>
<p>如果题目改为输出其中异或值为a的不同字段的数量<br>那么xorsum[r]^xorsum[l-1]=a<br>那么对于一个xorsum[r] 要求前面又几个xorsum[l]=a^xorsum[r]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll data[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line">ll xorsum[(<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;ll,<span class="keyword">int</span>&gt;cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;cnt[<span class="number">0</span>]++;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">        xorsum[i]=xorsum[i<span class="number">-1</span>]^data[i];</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(xorsum[i]))&#123;</span><br><span class="line">            ans+=cnt[xorsum[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[xorsum[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营6-A</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A56-A/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3007/A" target="_blank" rel="noopener">配对</a></p>
<p>题意</p>
<p>现在有正整数集合 A 和 B，每个集合里有 N 个数，你要建立他们间的一一映射  将每对配对的数字相加可以得到 N 个和，你要做的就是最大化第 K 大的和</p>
<p>题解</p>
<p>我们要使得第K大的和尽可能大，显然可以贪心：<br>首先，组成这K对数字的显然是A中最大的K个数字和B中最大的K个数字。<br>问题转化为怎样配对使得最小的和最大： </p>
<p>如果k=2<br>那么 将a1+b2，a2+b1作为前k大的数那么 能让k=2最大<br>经过简单的归纳可以得到，倒序配对是最优的，这样就解决了问题<br>即a1+bk ,a2+bk-1….. ak+b1中选第k大最优</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=(ll)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">4</span>],b[(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n-m+<span class="number">1</span>,j=n;i&lt;=n;i++,j--)&#123;</span><br><span class="line">        ans.push_back(a[i]+b[j]);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;a[i]&lt;&lt;" "&lt;&lt;b[j]&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    reverse(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans[m<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营5-H</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A55-H/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3006/H" target="_blank" rel="noopener">Hash</a></p>
<p>题意<br>这里有一个hash函数<br>const int LEN = 6;<br>int mod;<br>int Hash(char str[])<br>{<br>    int res = 0;<br>    for (int i = 0; i &lt; LEN; i++)<br>    {<br>        res = (res * 26 + str[i] - ‘a’) % mod;<br>    }<br>    return res;<br>}<br>现给定一个长度为6的仅由小写字母构成的字符串s和模数<br>mod，请找到字典序最小且大于s的一个长度为6的仅由小写字母构成的字符串s′使得其hash值和s的hash相等。 </p>
<p>题解<br>观察给的哈希函数可以轻松看出，这个哈希函数就仅仅是把一个只由小写字符组成的字符串当成了一个26进制的数，不取模的情况下，任意小写字符串和自然数是一一对应的。因此，只要把给的字符串转换成对应的26进制整数，加上模数后转换回字符串，一定可以得到一个最小字典序大于原串的字符串。只要这个新字符串长度为6即是满足要求的字符串</p>
<p>hash本质<br>用str[1]×num^(k-1) + str[2]×num^(k-2)+…..str[k] %mod 表示字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">Hash</span><span class="params">(<span class="keyword">char</span> s[])</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        res=(res*<span class="number">26</span>+s[i]-<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s %d"</span>,s,&amp;mod)!=EOF)&#123;</span><br><span class="line">        ll res=Hash(s)+mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            s[i]=(res%<span class="number">26</span>+<span class="string">'a'</span>);</span><br><span class="line">            res/=<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;1;</span></span><br><span class="line">        <span class="keyword">if</span>(res!=<span class="number">1</span>)<span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营6-B</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A56-B/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3007/B" target="_blank" rel="noopener">图</a></p>
<p>题意<br>有n个点 每个点只有一个出度 问最长路径长度</p>
<p>基于基环树的结论 从一个入度为0的点开始一定最终通向环</p>
<p>或用tarjan缩点</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> FI first</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SE second</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LDB long double</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SZ(a) (int)a.size()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LDB pai = <span class="built_in">acos</span>(<span class="number">-1.0L</span>);</span><br><span class="line"><span class="keyword">const</span> LDB eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> to[MXN];</span><br><span class="line"><span class="keyword">int</span> du[MXN]; <span class="comment">///入度</span></span><br><span class="line"><span class="keyword">int</span> h[MXN];</span><br><span class="line"><span class="keyword">int</span> dp[MXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[u]) <span class="keyword">return</span> dp[u];</span><br><span class="line">    <span class="keyword">return</span> dp[u]=dfs(to[u])+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;to[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) du[to[i]]++;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(du[i]==<span class="number">0</span>) q.push(i);<span class="comment">///入度为0的作为出发点</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;<span class="comment">///bfs遍历图找到环入口</span></span><br><span class="line">		      <span class="comment">///岔路必然连接多个出发点最后被排除而环的入口不会被排除 即入度不为0的节点</span></span><br><span class="line">        <span class="keyword">int</span> now=q.front();q.pop();</span><br><span class="line">        du[to[now]]--;</span><br><span class="line">        <span class="keyword">if</span>(du[to[now]]==<span class="number">0</span>) q.push(to[now]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(du[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> now=i,s=i;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">            v.push_back(s);du[s]--;</span><br><span class="line">            <span class="keyword">while</span>(to[now]!=s)</span><br><span class="line">                du[to[now]]--,v.push_back(to[now]),now=to[now];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:v) dp[j]=SZ(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dfs(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1000050;</span><br><span class="line"></span><br><span class="line">int to[N], siz[N], n, vis[N], ins[N], sta[N];</span><br><span class="line"></span><br><span class="line">int dfs(int x)&#123;</span><br><span class="line"></span><br><span class="line">	if(siz[x]) return siz[x];</span><br><span class="line"></span><br><span class="line">	return siz[x] = 1 + dfs(to[x]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///ins是找环用的vis 每次要记得清空ins 否则下次还会找到同一个环</span><br><span class="line">///如果是某条直线多个点通向同一个环那么直线的点会多次访问ins避免重复计算相同的环</span><br><span class="line">///sta[0] 记录路径长度 sta[j]表示该路径第几个点在原图中的下标</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i, j, k, h;</span><br><span class="line">	scanf("%d", &amp;n);</span><br><span class="line">	for(i = 1; i &lt;= n; i ++)</span><br><span class="line">  		scanf("%d", &amp;to[i]);</span><br><span class="line">	for(i = 1; i &lt;= n; i ++)&#123;</span><br><span class="line">  		if(vis[i] == 0)&#123;</span><br><span class="line">        	j = i;</span><br><span class="line">       		while(vis[j] == 0)&#123;</span><br><span class="line">       			sta[++ sta[0]] = j;</span><br><span class="line">        		vis[j] = ins[j] = 1;</span><br><span class="line">         		j = to[j];</span><br><span class="line">     		&#125;</span><br><span class="line">      		if(ins[j])&#123;</span><br><span class="line">        		k = j, h = 0;</span><br><span class="line">                do&#123;</span><br><span class="line">        			k = to[k];</span><br><span class="line">            		h ++;</span><br><span class="line">            	&#125;while(k != j);</span><br><span class="line">           		do&#123;</span><br><span class="line">               	   	k = to[k];</span><br><span class="line">                    siz[k] = h;</span><br><span class="line">           		&#125;while(k != j);</span><br><span class="line">        	&#125;</span><br><span class="line">        	while(sta[0])&#123;</span><br><span class="line">            	ins[sta[sta[0]]] = 0;</span><br><span class="line">            	sta[0] --;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i = 1, h = 0; i &lt;= n; i ++)</span><br><span class="line">    	h = max(h, dfs(i));</span><br><span class="line">		printf("%d", h);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dfs &amp; bfs</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营6-C</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A56-C/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3007/C" target="_blank" rel="noopener">汉诺塔</a></p>
<p>题意</p>
<p>现在你有 N 块矩形木板，第 i 块木板的尺寸是 Xi*Yi，你想用这些木板来玩汉诺塔的游戏。<br>我们知道玩汉诺塔游戏需要把若干木板按照上小下大的顺序堆叠在一起，但因为木板是矩形，所以有一个问题：<br>第 i 块木板能放在第 j 块木板上方当且仅当 Xi&lt;Xj 且 Yi&lt;Yj，于是你很可能没法把所有的木板按照一定的次序叠放起来。<br>你想把这些木板分为尽可能少的组，使得每组内的木板都能按照一定的次序叠放。<br>你需要给出任意一种合理的分组方案。<br>提醒：“任意”意味着你的答案不必和标准输出完全一致，只要正确即可。</p>
<p>第一行，一个正整数 N<br>接下来 N 行，每行两个正整数表示 Xi 和 Yi<br>对于所有的数据，1≤N≤100,000，1≤Xi,Yi≤N，Xi 互不相等且 Yi 互不相等</p>
<p>输出文件包含两行，第一行一个正整数，表示最少组数<br>第二行 N 个正整数，依次表示你的方案中每块木板分在了哪一组<br>组的编号必须是从 1 开始的连续整数</p>
<blockquote>
<p>已知<br>Dilworth 定理<br>一个序列最少可以分成n个上升子序列,这个序列最长不上升子序列长度为m,则n=m<br>一个序列最少可以分成n个下降子序列,这个序列最长不下降子序列长度为m,则n=m<br>链的最少划分数=反链的最长长度 </p>
<p>举栗子就是:</p>
<p>上升子序列(&lt;)的反链是原序列的最大不上升子序列(=&gt;),,,</p>
<p>下降子序列(&gt;)的反链就是原序列的最大不下降子序列(&lt;=)</p>
<p>记住不要漏等号</p>
</blockquote>
<p>对于本题<br>将木板按照Xi从小到大排序，将这时的Yi数列记为Zi数列，则问题变成将Zi划分为尽可能少的若干组上升子序列。<br>根据Dilworth定理，最小组数等于Zi的最长不上升子序列长度。<br>用二分栈优化dp Onlogn 找到Zi数列的最长不上升子序列 并更新每组的最长上升子序列</p>
<p>具体的 开一个数组lis已经记录到第i个数时能构成的最长非上升子序列<br>从前到后遍历Zi 在lis中二分寻找第一个小于等于Zi的数 用Zi替换这个数 使得最终lis是最长的非上升子序列<br>而这个 替换的数取代在lb位置上的数 实际上就是在原先的那组板子上叠最长上升子序列<br>二分细节见代码</p>
<blockquote>
<p>详见：<a href="https://www.iteye.com/blog/gaotong1991-2024588" target="_blank" rel="noopener">此处</a><br>举例用二分栈优化最长上升子序列dp</p>
<p>开一个栈，每次取栈顶元素top和读到的元素temp做比较，如果temp &gt; top 则将temp入栈；如果temp &lt; top则二分查找栈中的比temp大的第1个数，并用temp替换它。 最长序列长度即为栈的大小top。</p>
<p>这也是很好理解的，对于x和y，如果x &lt; y且Stack[y] &lt; Stack[x],用Stack[x]替换Stack[y]，此时的最长序列长度没有改变但序列Q的”潜力”增大了。</p>
<p>或者说开辟了一个新分支的同时不影响原来分支和最长子序列<br>详见：<a href="https://blog.csdn.net/qq_36523667/article/details/78631696?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">此处</a></p>
<p>举例：原序列为1，5，8，3，6，7</p>
<p>栈为1，5，8，此时读到3，用3替换5，得到1，3，8； 再读6，用6替换8，得到1，3，6；再读7，得到最终栈为1，3，6，7。最长递增子序列为长度4。</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> indx;</span><br><span class="line">&#125;data[(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> lis[(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> ans[(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Data a,Data b)</span></span>&#123;<span class="keyword">return</span> a.x&lt;b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;data[i].x&gt;&gt;data[i].y,data[i].indx=i;</span><br><span class="line">    sort(data,data+n,cmp);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>,lb,rb;</span><br><span class="line">    lis[len]=data[<span class="number">0</span>].y;</span><br><span class="line">    ans[data[<span class="number">0</span>].indx]=len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        lb=<span class="number">0</span>,rb=len;</span><br><span class="line">        <span class="keyword">while</span>(lb&lt;=rb)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(lb+rb)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(lis[mid]&lt;data[i].y)rb=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> lb=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len=<span class="built_in">max</span>(len,lb);</span><br><span class="line">        lis[lb]=data[i].y;</span><br><span class="line">        ans[data[i].indx]=lb;<span class="comment">///记录对应的每个木板放入哪一组 二分得到的lb实际表示分到哪一组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;len+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cout</span>&lt;&lt;ans[i]+<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Dilworth</tag>
        <tag>优化技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营6-D</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A56-D/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3007/D" target="_blank" rel="noopener">重排列</a></p>
<p>题意<br>一个序列的重排列是指对这个序列中的元素进行若干次（包括0次）交换操作后得到的新序列       在本题中，序列中可能出现重复的数字，他们被视作不同的元素       </p>
<p>例如，序列1 1的重排列有两种       </p>
<p>现在有两个长度为 N 的非负整数序列 A 和 B，</p>
<p>问有多少种 A 的重排列满足对于所有的 1≤i≤N，有Ai≤Bi<br>由于答案可能很大，你只需要输出答案对1e9+7取模的结果 </p>
<p>题解</p>
<p>对于每个位置的bi有多少A数组中的数(xi)小于等于bi<br>那么这个位置可以放的数有xi个<br>从xi最少的位置开始确定假设为x1 那么第二少的能放x2-1个 以此类推<br>最后是x1×(x2-1)×(x3-2)×…</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">5</span>],b[(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> ll mod=(ll)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt;de;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=upper_bound(a,a+n,b[i])-a;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;pos&lt;&lt;" ";</span></span><br><span class="line">        de.push_back(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(de.<span class="built_in">begin</span>(),de.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> len=de.<span class="built_in">size</span>();</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        ans=((ans%mod)*(de[i]-i)%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2020寒假训练营6-E</title>
    <url>/2020/07/15/%E7%89%9B%E5%AE%A22020%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E8%90%A56-E/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3007/E" target="_blank" rel="noopener">立方数</a></p>
<p>题意<br>对于给定的正整数 N，求最大的正整数 A，使得存在正整数 B，满足 A^3×B=N<br>输入包含 T 组数据，1≤T≤10,000；1≤N≤10^18</p>
<p>考虑直接一些的做法    尝试对每个N作质因数分解，经简单的统计可得出答案，复杂度O(TN^(1/2))    我们先做简单一点的优化，容易发现其实只要枚举10^ 6(N^ (1/3)以内)的质数就好，复杂度O(TN^ (1/3)/ln(N ^(1/3) ) )    再作进一步的分析，如果我们仅使用N^(1/4)(记为W)以内的质数去试除，那么最后余下的数X仅具有大于W的因子    此时X要么是一个完全立方数，要么对答案没有任何贡献，只需要使用二分法来验证X是不是一个完全立方数即可 </p>
<p>为什么最后余下的数x一定要么是一个完全立方数要么对答案没有贡献<br>即为什么剩下的不会有 x=p1^3 × p2^2  首先经过用N^(1/4)(记为W)以内的质数去试除 p1^4&gt;x , 如果p1^3 &lt; x </p>
<p>已知 p1&lt;p2那么 p1^3 × p2^m必定&gt;x</p>
<p>所以剩下的x要么是完全立方数要么x=p1^ n1×…pm^ ni; ni一定小于3 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=(<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll prime[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])prime[cnt++]=i;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;cnt&amp;&amp;prime[j]*i&lt;=maxn;j++)&#123;</span><br><span class="line">            vis[prime[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    intn();</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        ll ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;prime[i]*prime[i]*prime[i]*prime[i]&lt;=n;i++)&#123;</span><br><span class="line">            ll tr=prime[i]*prime[i]*prime[i];</span><br><span class="line">            <span class="keyword">while</span>(n%tr==<span class="number">0</span>)&#123;</span><br><span class="line">                n/=tr;</span><br><span class="line">                ans*=prime[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>)n/=prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lb = <span class="number">1</span>, rb = <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">while</span>(lb &lt;= rb)&#123;</span><br><span class="line">            <span class="keyword">int</span> md = lb + rb &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>((ll)md * md * md &lt; n)</span><br><span class="line">                lb = md + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rb = md - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((ll)lb * lb * lb == n)ans *= lb;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>优化技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络实战之MNIST手写体识别</title>
    <url>/2020/08/03/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E6%88%98%E4%B9%8BMINST%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.bilibili.com/video/BV1m4411x7KU" target="_blank" rel="noopener">从零开始神经网络</a></p>
<p><a href="https://peigizhu.gitee.io/2020/07/23/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">卷积神经网络学习笔记</a>(本博客站内搜索)</p>
</blockquote>
<p>再整理了部分吴恩达机器学习课程后 觉得有必要结合实践操作学习</p>
<p>在搜索了一些学习资料后找到了一个相当不错的实操教程</p>
<p>这里展示&amp;分享一下最终的实践成果</p>
<img src="/.io//timg.gif" data-original="img1.png">

<p>经过一轮训练后正确率从7.9%变成了93.5%</p>
<p>用mnist数据集中的图片进行识别测试</p>
<img src="/.io//timg.gif" data-original="img2.png">

<p>输出结果与图片吻合</p>
<p>在尝试自己的手写体</p>
<img src="/.io//timg.gif" data-original="img3.png">

<p>在windows自带的画图软件上写的数字8 经过截取压缩预处理后(网上找到的专门针对生成类mnist图片的小程序) </p>
<p>进行识别显示结果为8结果与预期吻合</p>
<p>调整学习率LearnRate</p>
<img src="/.io//timg.gif" data-original="Figure_1.png">

<p>上图是学习率learn rate = 10^x(横坐标) 与 训练集的误差平方和 (纵坐标)</p>
<p>表明学习率Learn_rate&gt;10^0.5时误差显著增大 设置学习率=1比较合适</p>
<p>主要从这个实践教程中学习了具体如何搭建一个简单神经网络, 验证求导正确性, 如何探究学习率与正确率的关系</p>
<p>算法理论内涵结合吴恩达的课程对于入门的我也能理解</p>
<p>而整个学习过程最难的部分 “反向传播过程”的公式推倒 还得继续研究学习</p>
<p>不过不懂原理并不妨碍使用它，如果不深究具体推导计算 其实实现它的学习成本并不高</p>
<p>最后贴上<a href="https://gitee.com/peigizhu/NeuralNetworks" target="_blank" rel="noopener">开源代码</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Convolutional Neural Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>第45届ICPC亚洲网上区域赛模拟赛-D</title>
    <url>/2020/11/01/%E7%AC%AC45%E5%B1%8AICPC%E4%BA%9A%E6%B4%B2%E7%BD%91%E4%B8%8A%E5%8C%BA%E5%9F%9F%E8%B5%9B%E6%A8%A1%E6%8B%9F%E8%B5%9B-D/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/8688/D" target="_blank" rel="noopener">Pokemon Ultra Sun</a> </p>
<ul>
<li><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2></li>
</ul>
<p>两只pokemon对战 A有hp1血量B有hp2血量</p>
<p>每回合A有p的概率对B造成w的伤害</p>
<p>或者B有1-p的概率对A造成w的伤害</p>
<p>当有一方血量低于或等于0时结束</p>
<p>问对战回合(轮数)的期望值</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>首先需要知道求期望的一般公式 $Exp=∑_{i=0}^{n}i×p_i$</p>
<p>对于此题轮数的期望值= 1轮结束的概率×1+2轮结束的概率×2+….n轮结束的概率×n</p>
<p>例如样例：</p>
<p>hp1=3，hp2=1，w=1</p>
<p>p=0.8</p>
<img src="/.io//timg.gif" data-original="example.png">

<p>第一轮结束的局面有(3,0),对应概率为0.8</p>
<p>第二轮结束的局面有(2,0),对应概率为0.2×0.8</p>
<p>第三轮结束的局面有(1,0),(0,1) 对应概率为0.2×0.2×0.8 和 0.2×0.2×0.2 </p>
<p>所以 $Exp=1×0.8+2×0.2×0.8+3×(0.2×0.2×0.8 和 0.2×0.2×0.2)$</p>
<p>上图对于局面状态(概率)的转移就已经显而易见了 </p>
<p>设计dp(i,j)表示到达A剩余i血 B剩余j血的局面概率</p>
<p>更新完dp后根据期望公式直接求得答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">3 1 1</span></span><br><span class="line"><span class="comment">0.5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">3005</span>][<span class="number">3005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="comment">//int q;cin&gt;&gt;q;</span></span><br><span class="line">    <span class="keyword">int</span> q;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> hp1,hp2,w;</span><br><span class="line">        <span class="keyword">double</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %lf"</span>,&amp;hp1,&amp;hp2,&amp;w,&amp;p);</span><br><span class="line">        <span class="comment">//printf("%f\n",p);</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[hp1][hp2]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> A=<span class="built_in">ceil</span>(<span class="number">1.0</span>*hp1/w),B=<span class="built_in">ceil</span>(<span class="number">1.0</span>*hp2/w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=A;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=B;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&amp;&amp;hp1-i*w&gt;<span class="number">0</span>&amp;&amp;hp2-(j<span class="number">-1</span>)*w&gt;<span class="number">0</span>)dp[<span class="built_in">max</span>(<span class="number">0</span>,hp1-i*w)][<span class="built_in">max</span>(<span class="number">0</span>,hp2-j*w)]+=dp[hp1-i*w][hp2-(j<span class="number">-1</span>)*w]*p;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;&amp;hp1-(i<span class="number">-1</span>)*w&gt;<span class="number">0</span>&amp;&amp;hp2-j*w&gt;<span class="number">0</span>)dp[<span class="built_in">max</span>(<span class="number">0</span>,hp1-i*w)][<span class="built_in">max</span>(<span class="number">0</span>,hp2-j*w)]+=dp[hp1-(i<span class="number">-1</span>)*w][hp2-j*w]*(<span class="number">1</span>-p);</span><br><span class="line">                <span class="comment">//printf("(%d,%d) &lt;-(%d,%d) : %f\n",max(0,hp1-i*w),max(0,hp2-j*w),max(0,hp1-i*w),max(0,hp2-(j-1)*w),dp[max(0,hp1-i*w)][max(0,hp2-(j-1)*w)]*p);</span></span><br><span class="line">                <span class="comment">//printf("(%d,%d) &lt;-(%d,%d) : %f\n",max(0,hp1-i*w),max(0,hp2-j*w),max(0,hp1-(i-1)*w),max(0,hp2-j*w),dp[max(0,hp1-(i-1)*w)][max(0,hp2-j*w)]*(1-p));</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=hp1;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((hp1-i)%w)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> round=(hp1-i)/w+B;</span><br><span class="line">            ans+=dp[i][<span class="number">0</span>]*round;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=hp2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((hp2-j)%w)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> round=(hp2-j)/w+A;</span><br><span class="line">            ans+=dp[<span class="number">0</span>][j]*round;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>第k短路学习笔记</title>
    <url>/2020/10/20/%E7%AC%ACk%E7%9F%AD%E8%B7%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/AK-ls/p/10614203.html" target="_blank" rel="noopener">第k短路(Dijkstra&amp;A*)</a></p>
<p><a href="https://blog.csdn.net/qq_40772692/article/details/82530467" target="_blank" rel="noopener">第k短路和次短路</a></p>
<p><a href="https://blog.csdn.net/sslz_fsy/article/details/82120232" target="_blank" rel="noopener">A*(第k短路)</a></p>
</blockquote>
<p><strong>1.什么是第k短路？第一短路就是最短路，以此类推。求某点s到某点e的第k短路就是k短路问题</strong></p>
<p><strong>2.思路：</strong></p>
<p><strong>（1）我们知道在BFS中，第一次到达终点就是到终点的最短路，那么第k次到达终点，当然就是到终点的第k短路了。但是如果直接BFS搜索下去，时间复杂度会非常高，因此我们需要剪枝，怎么剪枝呢？</strong></p>
<p><strong>（2）我们每次只需要取出每次到达终点最有希望的路径，就避开了一些没有意义的到其他点的路径。因此我们需要一个启发函数。令f = x + h（其中x为到当前点的实际距离，h为从当前点到达终点的估测最短距离），则f就估测为从起点到终点的路径长度，我们每次只要有目的有方向的前进到达终点k次即为k短路</strong></p>
<p><strong>（3）那么怎么求这个h呢？h其实为每个点到达终点的最短路，但是我们只学过某个点到其他点的最短路怎么办？当然是把终点当作起点跑最短路啊（哇笨蛋) ， 但是这里有一个问题：我们需要在跑终点最短路时使用反向边，跑BFS时使用正向边（有向图），为什么呢：</strong></p>
<p><strong>3.求解步骤</strong></p>
<p><strong>（1）Dijkstra求终点到其他点的最短路</strong></p>
<p><strong>（2）正向边跑起点的BFS（以A*启发函数：f = x + h为排序，取出点）</strong></p>
<p>例题：<a href="http://poj.org/problem?id=2449" target="_blank" rel="noopener">POJ-2449</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///poj上提交编译错误 不过板子大概没问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt;mp[Max],invmp[Max];</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> disT[Max],vistime[Max];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)disT[i]=inf;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,less&lt;P&gt; &gt;q;</span><br><span class="line">    disT[start]=<span class="number">0</span>;</span><br><span class="line">    q.push(&#123;<span class="number">0</span>,start&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        P temp=q.top();q.pop();</span><br><span class="line">        <span class="keyword">int</span> now=temp.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[now])<span class="keyword">continue</span>;</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge:invmp[now])&#123;</span><br><span class="line">            <span class="keyword">int</span> cost=edge.second,to=edge.first;</span><br><span class="line">            <span class="keyword">if</span>(disT[now]+cost&lt;disT[to])&#123;</span><br><span class="line">                disT[to]=disT[now]+cost;</span><br><span class="line">                q.push(&#123;disT[to],to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Astar</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> endpoint,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//memset(vis,0,sizeof vis);</span></span><br><span class="line">    <span class="keyword">if</span>(disT[start]==inf)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt;q;</span><br><span class="line">    q.push(&#123;disT[start],start&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        P temp=q.top();q.pop();</span><br><span class="line">        <span class="keyword">int</span> now=temp.second,ExpectCost=temp.first;</span><br><span class="line">        vistime[now]++;</span><br><span class="line">        <span class="keyword">if</span>(vistime[now]==k&amp;&amp;now==endpoint)<span class="keyword">return</span> ExpectCost;</span><br><span class="line">        <span class="keyword">if</span>(vistime[now]&gt;k)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge:mp[now])&#123;</span><br><span class="line">            <span class="keyword">int</span> Cost=edge.second,to=edge.first;</span><br><span class="line">            q.push(&#123;ExpectCost-disT[now]+Cost+disT[to],to&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,val;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;val;</span><br><span class="line">        mp[u].push_back(&#123;v,val&#125;);</span><br><span class="line">        invmp[v].push_back(&#123;u,val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> S,T,K;<span class="built_in">cin</span>&gt;&gt;S&gt;&gt;T&gt;&gt;K;</span><br><span class="line">    Dijkstra(T);</span><br><span class="line">    <span class="keyword">int</span> ans=Astar(S,T,K);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>第六届CCPC长春站热身赛-C</title>
    <url>/2020/11/08/%E7%AC%AC%E5%85%AD%E5%B1%8ACCPC%E9%95%BF%E6%98%A5%E7%AB%99%E7%83%AD%E8%BA%AB%E8%B5%9B-C/</url>
    <content><![CDATA[<p>(热身赛暂时没链接)</p>
<ul>
<li>##题意</li>
</ul>
<p>给出一个n个点m条边的图</p>
<p>每条边表示u -&gt; v 所需的时间 (小时)</p>
<p>某人驾车从s -&gt; t 点 他一天最多能开15小时车</p>
<p>问他最少几天到达终点</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>直接当作最短路会产生问题</p>
<p>比如：</p>
<p>A-&gt;B-&gt;C-&gt;D-&gt; E 每两点间需要7 h 则需要两天</p>
<p>A -&gt; X -&gt; X -&gt; E 每两点需要9h 则需要三天</p>
<p>所以想到用bfs + 最短路</p>
<p>每次从某个点跑最短路Dij将 15个小时内能到达的所有点 压入queue</p>
<p>因为15个小时能跑到的最远点 对于天数而言是等距离的点</p>
<p>在bfs 时 则将队列头 (较早遍历的点) 弹出 以这个点为根 再次跑最短路Dij 更新下一个点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt;mp[Max];</span><br><span class="line">ll dis[Max];</span><br><span class="line"><span class="keyword">int</span> day[Max];</span><br><span class="line"><span class="keyword">bool</span> vis[Max],vis2[Max];</span><br><span class="line">ll version[Max];</span><br><span class="line">ll curver = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(version[now]&lt;curver)&#123;</span><br><span class="line">        vis[now] = <span class="number">0</span>;</span><br><span class="line">        dis[now] = inf;</span><br><span class="line">        version[now] = curver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">1 6</span></span><br><span class="line"><span class="comment">1 2 15</span></span><br><span class="line"><span class="comment">2 5 15</span></span><br><span class="line"><span class="comment">5 6 15</span></span><br><span class="line"><span class="comment">1 6 15</span></span><br><span class="line"><span class="comment">1 3 1</span></span><br><span class="line"><span class="comment">3 4 1</span></span><br><span class="line"><span class="comment">4 6 15</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstar</span><span class="params">(<span class="keyword">int</span> st)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt;q;</span><br><span class="line">    q.push(&#123;<span class="number">0</span>,st&#125;);</span><br><span class="line">    update(st);</span><br><span class="line">    dis[st]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">auto</span> temp=q.top();q.pop();</span><br><span class="line">        <span class="keyword">int</span> now=temp.second;</span><br><span class="line">        update(now);</span><br><span class="line">        <span class="keyword">if</span>(vis[now])<span class="keyword">continue</span>;</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"&gt;&gt;&gt;&gt;&gt;from: "</span>&lt;&lt;now&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[now])&#123;</span><br><span class="line">            <span class="keyword">int</span> to=i.first;</span><br><span class="line">            ll cost=i.second;</span><br><span class="line">            update(to);</span><br><span class="line">            <span class="comment">/// 避免每次使用Dij都要初始化所有点memset 所以记录一个版本号</span></span><br><span class="line">            <span class="comment">/// 若当前点版本早于这次跑Dij的版本那么就初始化表示它是之前Dij使用过 此次未使用过</span></span><br><span class="line">            <span class="comment">/// 否则这个点的版本=这次跑Dij的版本那么就不初始化表示它正在被使用</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;"day:"&lt;&lt;day[to]&lt;&lt;" curday:"&lt;&lt;day[st]&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(day[to]&lt;=day[st])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">///此处剪枝 将超过一天的 点 放到下次bfs 时用Dij更新</span></span><br><span class="line">            <span class="keyword">if</span>(dis[now]+cost&lt;<span class="built_in">min</span>(<span class="number">16l</span>l,dis[to]))&#123;</span><br><span class="line">                dis[to]=dis[now]+cost;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;"to: "&lt;&lt;to&lt;&lt;" "</span></span><br><span class="line"><span class="comment">                    &lt;&lt;dis[now]&lt;&lt;"+"&lt;&lt;cost&lt;&lt;"="&lt;&lt;dis[to]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                q.push(&#123;dis[to],to&#125;);</span><br><span class="line">                qq.push(to);</span><br><span class="line">                day[to]=day[st]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> st)</span></span>&#123;</span><br><span class="line">    qq.push(st);dis[st]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(day,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> day);</span><br><span class="line">    day[st]=<span class="number">0</span>;<span class="keyword">int</span> lastday=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qq.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=qq.front();qq.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis2[now])<span class="keyword">continue</span>;</span><br><span class="line">        vis2[now]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(day[now]&gt;lastday)&#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;"xx"&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">//memset(dis,0x3f,sizeof dis);</span></span><br><span class="line">        &#125;</span><br><span class="line">        curver++;</span><br><span class="line">        Dijkstar(now);</span><br><span class="line">        lastday=day[now];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,s,t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;k;</span><br><span class="line">        mp[u].push_back(&#123;v,k&#125;);</span><br><span class="line">        mp[v].push_back(&#123;u,k&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    bfs(s);</span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=n;i++)cout&lt;&lt;i&lt;&lt;" "&lt;&lt;dis[i]&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;day[t]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>dfs &amp; bfs</tag>
        <tag>优化技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>第六届CCPC长春站正式赛-F</title>
    <url>/2020/11/10/%E7%AC%AC%E5%85%AD%E5%B1%8ACCPC%E9%95%BF%E6%98%A5%E7%AB%99%E6%AD%A3%E5%BC%8F%E8%B5%9B-F/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/102832/problem/F" target="_blank" rel="noopener">F. Strange Memory</a> </p>
<ul>
<li>##题意</li>
</ul>
<p>给出一个n个点n-1条边的一颗树 (n&lt;=1e5)</p>
<p>对于一个点$i$有值$a_i$ (1&lt;=ai&lt;=1e6)</p>
<p>现在要求 $∑<em>{i=1}^n∑</em>{j=i+1}^n [a_i⊕a_j=a_{lca(i,j)}]×(i⊕j).  $</p>
<p>即对于任何满足$[a_i⊕a_j=a_{lca(i,j)}]​$ 的点对(i,j) 的下标异或值求和</p>
<ul>
<li><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<blockquote>
<p><a href="https://frozenguardian.blog.csdn.net/article/details/109583484" target="_blank" rel="noopener">参考题解</a></p>
<p><a href="https://www.cnblogs.com/zwfymqz/p/9683124.html" target="_blank" rel="noopener">dsu on tree</a></p>
</blockquote>
<p>解决这个问题需要解决以下几个问题：</p>
<ul>
<li>如何找到符合$[a_i⊕a_j=a_{lca(i,j)}]$ 的点对</li>
<li>如何统计答案</li>
</ul>
<p>对于第一个问题 我们可以枚举一个点作为Lca 同时枚举一个它(Lca)的子节点作为$i$ </p>
<p>那么只需要寻找以它(Lca)为根的子节点中是否存在一个$a_j=a_{Lca} ⊕ a_{i}$ </p>
<p>对于第二个问题</p>
<p>朴素的想法是 我们用一个容器(比如map&lt;int,vector &gt;,关键字是点值,映射值是该点值的所有点下标值) </p>
<p>存某个点作为Lca的一支子树中 值为$a_j$的点的下标</p>
<p>于是对于这个Lca需要枚举另一支子树中的 $a_i$ </p>
<p>再枚举遍历容器中值为($a_{Lca} ⊕ a_{i}$) 的所有下标值 ans+=i⊕j</p>
<p>然后将$a_i$所在子树插入到容器中传递到上一层</p>
<p>这么做导致 我们不得不遍历子树中的$a_i$ 和$a_j$  来获取下标的异或值</p>
<p>实际上就是在暴力枚举点对(i,j)没有任何优化</p>
<p>###于是要着手如何更快速地统计答案；</p>
<p>首先意识到i⊕j 可以拆分成按位异或</p>
<p>那么当且仅当 符合$[a_i⊕a_j=a_{lca(i,j)}]$ 的点对(i,j) 在同一位二进制下相异 </p>
<p>最终答案才会有这一位二进制的贡献</p>
<p>比如点对(3,6) 二进制下(011,110)  3^6=5 即第0位和第2位相异的二进制位会对最终答案产生贡献</p>
<p>如果我们知道Lca下某个子树集合内 $a_j$的所有下标每位二进制为0/1的个数有几个</p>
<p>那么我们枚举$a_i$ 时可以直接算 对于需要的$a_j=a_i ⊕a_{Lca}$  中所有二进制位 为0/1的下标有多少个</p>
<p>就可以直接求得某位二进制下 i⊕j对答案产生的贡献</p>
<p>于是设计一个三维数组：$BitCnt(val,bit,0/1)$ </p>
<p>表示在某Lca的子树下点值为val的 <em>下标</em>  符合第bit位 为0/1 共有多少个</p>
<p>子树中$a_j$被作为一个集合统计在$BitCnt$中 就不需要逐个枚举$a_j$ 而改为枚举二进制位了</p>
<p>这么做的目的也是为了方便使用树上启发式合并</p>
<ul>
<li><p>什么是dsu on tree？</p>
<p>它是用来解决一类树上询问问题，一般这种问题有两个特征</p>
<p>1、只有对子树的询问</p>
<p>2、没有修改</p>
</li>
</ul>
<p>这个问题中需要更新维护每个点作为Lca时的BitCnt 也就是对子树集合信息的询问</p>
<p>对于dsu on tree的算法流程大概是：</p>
<p>首先需要预处理重链剖分(FInd_BigSon) 得到对于每个父节点 它子节点相对而言的重子树</p>
<img src="/.io//timg.gif" data-original="example.png">

<img src="/.io//timg.gif" data-original="example2.png">

<p>什么叫消除轻儿子产生的影响而保留重儿子？</p>
<p>以本题为例 我们需要维护$BitCnt$  是以某个点作为Lca的子树集合信息</p>
<p>而他作为全局变量 它在递归中被以不同点作为root的子树集合信息更新</p>
<p>而我们在求点对(i,j)时 是同一个点Lca 下的子树集合中 的信息 </p>
<img src="/.io//timg.gif" data-original="example3.png">

<p>如图 (红圈表示以其父节点下所有子节点相较而言的重子树)</p>
<p>对于Lca=5的子树集合 i=6 我只需要从5的其他支子树的BitCnt集合中得到</p>
<p>而递归过程会将所有其他子树集合信息一并更新到BitCnt这个全局变量中 导致对于i=6 </p>
<p>我所找到对应的j 就不仅限于Lca=5的子树中的信息了</p>
<p>对于启发式合并 每次将轻子树集合的信息并入到重子树中 </p>
<p>抹除轻子树的信息 然后将重子树传递到上一层递归 (返回到父节点)</p>
<p>若上一层的父节点不再是重子树 那么抹除它们的信息 将他们视为轻子树集合 </p>
<p>重新并入到同一层中的重子树中</p>
<p>这也体现了启发式合并的核心思想：</p>
<h3 id="将小集合信息并入到大集合信息使得整体复杂度下降到nlogn"><a href="#将小集合信息并入到大集合信息使得整体复杂度下降到nlogn" class="headerlink" title="将小集合信息并入到大集合信息使得整体复杂度下降到nlogn"></a>将小集合信息并入到大集合信息使得整体复杂度下降到nlogn</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="comment">//#define P pair&lt;ll,ll&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __DEBUG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"[%s:%d] "</span> format <span class="string">""</span>,</span><br><span class="line">    __FUNCTION__ , __LINE__, ##__VA_ARGS__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeBug(format,...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">4 2 1 6 6 5</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BitCnt[(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">100</span>][<span class="number">30</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">/// val,bit,1/0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;mp[Max];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;SmallSon;</span><br><span class="line"><span class="keyword">int</span> val[Max];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sz[Max],BigSon[Max];</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_BigSon</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    sz[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> to:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        Find_BigSon(to,now);</span><br><span class="line">        sz[now]+=sz[to];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sz[now]&gt;sz[BigSon[fa]])BigSon[fa]=now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Updata</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line">    DeBug(<span class="string">"id:%d add:%d\n"</span>,id,add);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++)BitCnt[val[id]][i][!((id&gt;&gt;i)&amp;<span class="number">1</span>)]+=add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    Updata(now,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> to:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        Delete(to,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deal</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa,<span class="keyword">int</span> lca)</span></span>&#123;</span><br><span class="line">    <span class="comment">//DeBug("now:%d\n",now);</span></span><br><span class="line">    SmallSon.push(now);</span><br><span class="line">    <span class="keyword">int</span> need=val[now]^val[lca];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//DeBug("need:%d now:%d add:%d\n",need,now,BitCnt[need][i][(now&gt;&gt;i)&amp;1])</span></span><br><span class="line">        ans+=BitCnt[need][i][(now&gt;&gt;i)&amp;<span class="number">1</span>]*(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> to:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        Deal(to,now,lca);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa,<span class="keyword">bool</span> keep)</span></span>&#123;</span><br><span class="line">    <span class="comment">///递归处理轻子树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> to:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(to==fa||to==BigSon[now])<span class="keyword">continue</span>;</span><br><span class="line">        dfs(to,now,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///递归处理重子树</span></span><br><span class="line">    <span class="keyword">if</span>(BigSon[now])dfs(BigSon[now],now,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">///将轻子树并入到重子树中并更新答案</span></span><br><span class="line">    vis[BigSon[now]]=<span class="number">1</span>;</span><br><span class="line">    Updata(now,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> to:mp[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(to==fa||vis[to])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//DeBug("in\n");</span></span><br><span class="line">        Deal(to,now,now);</span><br><span class="line">        <span class="comment">///暴力枚举轻子树的点i</span></span><br><span class="line">        <span class="comment">///此时BitCnt中存的是重子树中所需的j的信息</span></span><br><span class="line">        <span class="keyword">while</span>(!SmallSon.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=SmallSon.front();</span><br><span class="line">            SmallSon.pop();</span><br><span class="line">            Updata(temp,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[BigSon[now]]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">///删除轻子数对全局BitCnt的影响</span></span><br><span class="line">    <span class="keyword">if</span>(!keep)Delete(now,fa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;val[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        mp[u].push_back(v);</span><br><span class="line">        mp[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    Find_BigSon(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=n;i++)DeBug("%d %d\n",i,BigSon[i]);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>第十八届西电程序设计竞赛-D</title>
    <url>/2020/09/06/%E7%AC%AC%E5%8D%81%E5%85%AB%E5%B1%8A%E8%A5%BF%E7%94%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-D/</url>
    <content><![CDATA[<p><a href="http://acm.xidian.edu.cn/campus/2020/problem.pdf" target="_blank" rel="noopener">D.双倍快乐</a></p>
<p>题意</p>
<p>给出一个n个点的树(n-1条边)</p>
<p>每个点有一个权值val[i]</p>
<p>每条边有一个属性0/1</p>
<p>定义一个点的快乐值为它的子节点的快乐值+它自身的权值</p>
<p>当且仅当一个点既有1又有0 的边时它自身的权值会翻倍</p>
<p>于是它的快乐值=它的子节点的快乐值+它自身的权值×2</p>
<p>现在最多改变一个边的属性 0变1 ，1变0</p>
<p>问所有点的快乐值和最大是多少</p>
<p>题解</p>
<p>注意到题目中翻倍的是自身权值 而不是它的快乐值</p>
<p>所以可以将翻倍的贡献独立出来计算</p>
<p>将一个点对总的贡献值看作 </p>
<p>(它的子节点贡献+它自身的权值) 和 (修改某边使节点权值翻倍的贡献)</p>
<p>对于前者可直接通过dfs求得</p>
<p>对于后者则枚举修改那一条边能产生的贡献最大</p>
<p>注意改变一条边的属性可能会使两个点翻倍</p>
<p>观察发现 对于一个点i若改变一条边能使得它自身的权值 翻倍</p>
<p>那么它翻倍部分(即多加了val[i])对总快乐值的贡献为deep[i]×val[i]</p>
<p>(因为它的权值将会作为父节点快乐值的一部分向上传递)</p>
<p>于是枚举修改边 计算翻倍产生贡献最大的 更新答案</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define endl <span class="string">'\n'</span></span><br><span class="line">#define <span class="symbol">Turnoff</span> std::ios::sync_with_stdio(false)</span><br><span class="line">const ll <span class="symbol">Max</span>=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">const double <span class="symbol">Pi</span>=acos(<span class="number">-1</span>);</span><br><span class="line">const ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll val[<span class="symbol">Max</span>],d[<span class="symbol">Max</span>];</span><br><span class="line">bool doub[<span class="symbol">Max</span>],can[<span class="symbol">Max</span>];</span><br><span class="line">int cnt[<span class="number">2</span>][<span class="symbol">Max</span>],deep[<span class="symbol">Max</span>];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;mp[<span class="symbol">Max</span>];</span><br><span class="line"> </span><br><span class="line">void dfs_val(int now,int fa)&#123;</span><br><span class="line">    for(auto i:mp[now])&#123;</span><br><span class="line">        if(fa==i.first)continue;</span><br><span class="line">        //deep[i.first]=deep[now]+<span class="number">1</span>;</span><br><span class="line">        dfs_val(i.first,now);</span><br><span class="line">        val[now]+=val[i.first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs_deep(int now,int fa)&#123;</span><br><span class="line">    for(auto i:mp[now])&#123;</span><br><span class="line">        if(fa==i.first)continue;</span><br><span class="line">        deep[i.first]=deep[now]+<span class="number">1</span>;</span><br><span class="line">        dfs_deep(i.first,now);</span><br><span class="line">        //val[now]+=val[i.first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //<span class="symbol">Turnoff</span>;</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    for(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;d[i];</span><br><span class="line">        val[i]=d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        int u,v,w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        mp[u].push_back(&#123;v,w&#125;);</span><br><span class="line">        mp[v].push_back(&#123;u,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        int cnt1=<span class="number">0</span>,cnt0=<span class="number">0</span>;</span><br><span class="line">        for(auto edge:mp[i])&#123;</span><br><span class="line">            if(edge.second)cnt[<span class="number">1</span>][i]++;</span><br><span class="line">            else cnt[<span class="number">0</span>][i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deep[<span class="number">1</span>]=<span class="number">1</span>;dfs_deep(<span class="number">1</span>,<span class="number">0</span>);ll ans=<span class="number">0</span>,change=<span class="number">0</span>;</span><br><span class="line">    for(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        if(cnt[<span class="number">0</span>][i]&amp;&amp;cnt[<span class="number">1</span>][i])val[i]*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs_val(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    for(int i=<span class="number">1</span>;i&lt;=n;i++)ans+=val[i];</span><br><span class="line">    for(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        for(auto edge:mp[i])&#123;</span><br><span class="line">            ll temp=<span class="number">0</span>;int to=edge.first;</span><br><span class="line">            if(edge.second)&#123;</span><br><span class="line">                temp-=(cnt[<span class="number">1</span>][i]&amp;&amp;cnt[<span class="number">0</span>][i])*d[i]*deep[i];</span><br><span class="line">                temp-=(cnt[<span class="number">1</span>][to]&amp;&amp;cnt[<span class="number">0</span>][to])*d[to]*deep[to];</span><br><span class="line">                cnt[<span class="number">1</span>][i]--;cnt[<span class="number">0</span>][i]++;</span><br><span class="line">                cnt[<span class="number">1</span>][to]--;</span><br><span class="line">                cnt[<span class="number">0</span>][to]++;</span><br><span class="line">                temp+=(cnt[<span class="number">1</span>][i]&amp;&amp;cnt[<span class="number">0</span>][i])*d[i]*deep[i];</span><br><span class="line">                temp+=(cnt[<span class="number">1</span>][to]&amp;&amp;cnt[<span class="number">0</span>][to])*d[to]*deep[to];</span><br><span class="line">                cnt[<span class="number">1</span>][i]++;cnt[<span class="number">0</span>][i]--;</span><br><span class="line">                cnt[<span class="number">1</span>][to]++;</span><br><span class="line">                cnt[<span class="number">0</span>][to]--;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                temp-=(cnt[<span class="number">1</span>][i]&amp;&amp;cnt[<span class="number">0</span>][i])*d[i]*deep[i];</span><br><span class="line">                temp-=(cnt[<span class="number">1</span>][to]&amp;&amp;cnt[<span class="number">0</span>][to])*d[to]*deep[to];</span><br><span class="line">                cnt[<span class="number">0</span>][i]--;cnt[<span class="number">1</span>][i]++;</span><br><span class="line">                cnt[<span class="number">0</span>][to]--;</span><br><span class="line">                cnt[<span class="number">1</span>][to]++;</span><br><span class="line">                temp+=(cnt[<span class="number">1</span>][i]&amp;&amp;cnt[<span class="number">0</span>][i])*d[i]*deep[i];</span><br><span class="line">                temp+=(cnt[<span class="number">1</span>][to]&amp;&amp;cnt[<span class="number">0</span>][to])*d[to]*deep[to];</span><br><span class="line">                cnt[<span class="number">0</span>][i]++;cnt[<span class="number">1</span>][i]--;</span><br><span class="line">                cnt[<span class="number">0</span>][to]++;</span><br><span class="line">                cnt[<span class="number">1</span>][to]--;</span><br><span class="line">            &#125;</span><br><span class="line">            change=max(change,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //cout&lt;&lt;ans&lt;&lt;<span class="string">" "</span>&lt;&lt;change&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ans+change&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dfs &amp; bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>第十八届西电程序设计竞赛-F</title>
    <url>/2020/09/06/%E7%AC%AC%E5%8D%81%E5%85%AB%E5%B1%8A%E8%A5%BF%E7%94%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-F/</url>
    <content><![CDATA[<p><a href="http://acm.xidian.edu.cn/campus/2020/problem.pdf" target="_blank" rel="noopener">F.老奶奶参加宴会</a></p>
<p>题意</p>
<p>给出一个n个点m条边的图</p>
<p>每条边有体力值</p>
<p>并定义每个点有能量值</p>
<p>可以走边消耗对应体力</p>
<p>或者任意两点瞬移消耗体力为两点能量值差的绝对值</p>
<p>问从s到t最少消耗多少体力</p>
<p>题解</p>
<p>暴力建边不可取</p>
<p>将每个点的能量值排序</p>
<p>只有相邻两点之间才有必要用瞬移</p>
<p>比如排序后的点对应能量值为 a1,a2,a3,a4…</p>
<p>|a3-a1|&gt;=|a2-a1|+|a3-a2| 只有a2的值在 a1和a3之间才取等</p>
<p>所以排序后相邻点建边最优</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;ll,<span class="keyword">int</span>&gt; &gt;mp[Max],Magic;</span><br><span class="line"><span class="keyword">bool</span> vis[Max],visS[Max],visT[Max];</span><br><span class="line">ll dis[Max];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=<span class="number">1e18</span>;</span><br><span class="line">    dis[S]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;ll,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;pair&lt;ll,<span class="keyword">int</span>&gt; &gt;,greater&lt;pair&lt;ll,<span class="keyword">int</span>&gt; &gt; &gt;q;</span><br><span class="line">    q.push(&#123;<span class="number">0</span>,S&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=q.top().second;q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[now])<span class="keyword">continue</span>;</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp[now])&#123;</span><br><span class="line">            <span class="keyword">int</span> to=i.second;ll cost=i.first;</span><br><span class="line">            <span class="keyword">if</span>(dis[to]&gt;dis[now]+cost)&#123;</span><br><span class="line">                dis[to]=dis[now]+cost;</span><br><span class="line">                q.push(&#123;dis[to],to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ll temp;<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        Magic.push_back(&#123;temp,i+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Magic.<span class="built_in">begin</span>(),Magic.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//for(auto i:Magic)cout&lt;&lt;i.first&lt;&lt;" "&lt;&lt;i.second&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ll u,v,w;<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        mp[u].push_back(&#123;w,v&#125;);</span><br><span class="line">        mp[v].push_back(&#123;w,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> S,T;<span class="built_in">cin</span>&gt;&gt;S&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;Magic.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=Magic[i<span class="number">-1</span>].second,v=Magic[i].second;</span><br><span class="line">        ll w=Magic[i].first-Magic[i<span class="number">-1</span>].first;</span><br><span class="line">        mp[u].push_back(&#123;w,v&#125;);</span><br><span class="line">        mp[v].push_back(&#123;w,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(S);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dis[T]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>第十八届西电程序设计竞赛-E</title>
    <url>/2020/09/06/%E7%AC%AC%E5%8D%81%E5%85%AB%E5%B1%8A%E8%A5%BF%E7%94%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-E/</url>
    <content><![CDATA[<p><a href="http://acm.xidian.edu.cn/campus/2020/problem.pdf" target="_blank" rel="noopener">E.世界第四</a></p>
<p>题意</p>
<p>给出一个排列p 长度为n&lt;5e5 其中[1,n]的数各出现一次</p>
<p>将区间[L,R]的MEX作为权值 问排列p所有区间的MEX和为多少</p>
<p>(MEX表示最小的不在该区间中出现的正整数 )</p>
<p>题解</p>
<p>注意到所有数只出现一次</p>
<p>考虑求各个MEX对答案的贡献</p>
<p>寻找MEX=1的区间有多少个</p>
<p>记1出现的位置为pos[1]</p>
<p>那么MEX=1的区间有pos[1]×(pos[1]-1)/2+(1+n-pos[1])×(n-pos[1])/2个</p>
<img src="/.io//timg.gif" data-original="example1.png">

<p>MEX=2的区间必须存在1但不能有2出现</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n&gt;=<span class="number">2</span>&amp;&amp;pos[<span class="number">2</span>]&gt;pos[<span class="number">1</span>])ans+=<span class="number">1</span>ll*(pos[<span class="number">2</span>]-pos[<span class="number">1</span>])*(pos[<span class="number">1</span>])*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n&gt;=<span class="number">2</span>&amp;&amp;pos[<span class="number">2</span>]&lt;pos[<span class="number">1</span>])ans+=<span class="number">1</span>ll*(pos[<span class="number">1</span>]-pos[<span class="number">2</span>])*(n-pos[<span class="number">1</span>]+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line"><span class="comment">//最后乘2表示MEX=2对答案的贡献前半部分是MEX=2的区间个数</span></span><br></pre></td></tr></table></figure>

<img src="/.io//timg.gif" data-original="example2.png">

<p>到这里我们可以发现MEX=x&gt;2的区间 必须包含1到x-1的所有数</p>
<p>我们维护一个leftpos和rightpos记录前1到x-1所有数最左端和最右端的位置</p>
<ul>
<li><p>假如x在1到x-1所有数的右侧则，即pos[x]&gt;rightpos</p>
<p>那么 就存在leftpos×(pos[i]-rightpos)个MEX=x的区间</p>
</li>
</ul>
<ul>
<li><p>假如x在1到x-1所有数的左侧则，即pos[x]&lt;leftpos</p>
<p>那么 就存在(n-rightpos+1)×(leftpos-pos[i])个MEX=x的区间</p>
</li>
</ul>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std<span class="comment">;</span></span><br><span class="line">typedef long long ll<span class="comment">;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl '\n'</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line">const ll Max=<span class="number">5</span>e5+<span class="number">5</span><span class="comment">;</span></span><br><span class="line">const <span class="keyword">double</span> Pi=acos(<span class="number">-1</span>)<span class="comment">;</span></span><br><span class="line">const ll mod=<span class="number">1</span>e9+<span class="number">7</span><span class="comment">;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll P[Max],<span class="keyword">pos</span>[Max]<span class="comment">;</span></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="comment">//Turnoff;</span></span><br><span class="line">    ll n<span class="comment">;cin&gt;&gt;n;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span><span class="comment">;i&lt;=n;i++)&#123;</span></span><br><span class="line">        cin&gt;&gt;P[i]<span class="comment">;</span></span><br><span class="line">        <span class="keyword">pos</span>[P[i]]=i<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1</span>ll*<span class="keyword">pos</span>[<span class="number">1</span>]*(<span class="keyword">pos</span>[<span class="number">1</span>]<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">1</span>ll*(<span class="number">1</span>+n-<span class="keyword">pos</span>[<span class="number">1</span>])*(n-<span class="keyword">pos</span>[<span class="number">1</span>])/<span class="number">2</span><span class="comment">;</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;=<span class="number">2</span>&amp;&amp;<span class="keyword">pos</span>[<span class="number">2</span>]&gt;<span class="keyword">pos</span>[<span class="number">1</span>])ans+=<span class="number">1</span>ll*(<span class="keyword">pos</span>[<span class="number">2</span>]-<span class="keyword">pos</span>[<span class="number">1</span>])*(<span class="keyword">pos</span>[<span class="number">1</span>])*<span class="number">2</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;=<span class="number">2</span>&amp;&amp;<span class="keyword">pos</span>[<span class="number">2</span>]&lt;<span class="keyword">pos</span>[<span class="number">1</span>])ans+=<span class="number">1</span>ll*(<span class="keyword">pos</span>[<span class="number">1</span>]-<span class="keyword">pos</span>[<span class="number">2</span>])*(n-<span class="keyword">pos</span>[<span class="number">1</span>]+<span class="number">1</span>)*<span class="number">2</span><span class="comment">;</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">    ll rightpos=max(<span class="keyword">pos</span>[<span class="number">1</span>],<span class="keyword">pos</span>[<span class="number">2</span>]),leftpos=min(<span class="keyword">pos</span>[<span class="number">1</span>],<span class="keyword">pos</span>[<span class="number">2</span>])<span class="comment">;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span><span class="comment">;i&lt;=n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//if(pos[i]&lt;rightpos&amp;&amp;pos[i]&gt;leftpos)continue;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">pos</span>[i]&lt;leftpos)&#123;</span><br><span class="line">            ans+=<span class="number">1</span>ll*(n-rightpos+<span class="number">1</span>)*(leftpos-<span class="keyword">pos</span>[i])*i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">pos</span>[i]&gt;rightpos)&#123;</span><br><span class="line">            ans+=<span class="number">1</span>ll*leftpos*(<span class="keyword">pos</span>[i]-rightpos)*i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        rightpos=max(rightpos,<span class="keyword">pos</span>[i])<span class="comment">;</span></span><br><span class="line">        leftpos=min(leftpos,<span class="keyword">pos</span>[i])<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans+=n+<span class="number">1</span><span class="comment">;</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>实现</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>第十八届西电程序设计竞赛-H</title>
    <url>/2020/09/06/%E7%AC%AC%E5%8D%81%E5%85%AB%E5%B1%8A%E8%A5%BF%E7%94%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-H/</url>
    <content><![CDATA[<p><a href="http://acm.xidian.edu.cn/campus/2020/problem.pdf" target="_blank" rel="noopener">H.美丽的建筑</a></p>
<p>题意</p>
<p>给出n&lt;1e5个建筑材料 </p>
<p>每个建筑材料有3个属性</p>
<p>编号，高度，美丽值</p>
<p>要求从中选出一些建筑材料</p>
<p>将他们按照编号升序排列后</p>
<p>他们的高度必须满足先递增后递减(只递增或只递减也可)</p>
<p>问选出的材料能组成最大的美丽值是多少</p>
<p>题解</p>
<p>乍一看像最长上升子序列的变形题</p>
<p>但实际上 这里并不关心最长的高度递增递减子序列</p>
<p>而是在符合高度递增递减的子序列中寻找权值和最大的值</p>
<p>分别从两端做dp 记前缀pre[i]为1到i的最优解(最大美丽值之和)</p>
<p>记后缀suf[i]为n到i的最优解</p>
<p>以前缀为例，我们每次转移状态时</p>
<p>需要找到以高度x(x从1到当前高度-1之间)为结尾的最长上升子序列中最大的美丽值记为maxn</p>
<p>pre[i]=max(pre[i],maxn+data[i].val);</p>
<p>由于有1e5个零件 所以以高度为线段树的区间左右端点建树,将美丽值之和作为区间最大值</p>
<p>每次转移询问树中(1,data[i].high-1)的区间内最大的美丽值 </p>
<p>更新完pre[i]后，将以当前高度data[i].high为结尾的最优解 pre[i]</p>
<p>单点更新线段树中高度为data[i].high的点 对应的最大值(美丽值)</p>
<p>后缀同理</p>
<p>最后On 取得最终答案 ans=max(pre[i]+suf[i]-data[i].val,ans); //第i个零件被计算两次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Turnoff std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> ll Max=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">998857459</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegTree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Leftson now&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Rightson now&lt;&lt;1|1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span><span class="keyword">int</span> L,R;ll maxn;&#125;;</span><br><span class="line">    segtree tree[Max&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">        tree[now].maxn=<span class="built_in">max</span>(tree[Leftson].maxn,tree[Rightson].maxn);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        tree[now]=&#123;L,R,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;L&lt;&lt;" "&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(L==R)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//int mid=(L+R)&gt;&gt;1;</span></span><br><span class="line">        build(L,mid,Leftson);</span><br><span class="line">        build(mid+<span class="number">1</span>,R,Rightson);</span><br><span class="line">        push_up(now);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> pos,ll val,<span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[now].L==tree[now].R)&#123;</span><br><span class="line">            tree[now].maxn=<span class="built_in">max</span>(tree[now].maxn,val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=tree[Leftson].R)updata(pos,val,Leftson);</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;=tree[Rightson].L)updata(pos,val,Rightson);</span><br><span class="line">        push_up(now);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> qL,<span class="keyword">int</span> qR,<span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(qL&gt;qR)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[now].R&lt;=qR&amp;&amp;tree[now].L&gt;=qL)<span class="keyword">return</span> tree[now].maxn;</span><br><span class="line">        ll maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[Leftson].R&gt;=qL)maxn=<span class="built_in">max</span>(maxn,query(qL,qR,Leftson));</span><br><span class="line">        <span class="keyword">if</span>(tree[Rightson].L&lt;=qR)maxn=<span class="built_in">max</span>(maxn,query(qL,qR,Rightson));</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;preHigh,sufHigh;</span><br><span class="line">ll pre[Max],suf[Max];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span>ll indx,val,high;&#125;data[Max];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Data x,Data y)</span></span>&#123;<span class="keyword">return</span> x.indx&lt;y.indx;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Turnoff;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    preHigh.build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    sufHigh.build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll indx,val,high;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;indx&gt;&gt;val&gt;&gt;high;</span><br><span class="line">        data[i]=&#123;indx,val,high&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(data+<span class="number">1</span>,data+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=<span class="built_in">max</span>(pre[i],preHigh.query(<span class="number">1</span>,data[i].high<span class="number">-1</span>,<span class="number">1</span>)+data[i].val);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"ok"&lt;&lt;endl;</span></span><br><span class="line">        preHigh.updata(data[i].high,pre[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        suf[i]=<span class="built_in">max</span>(suf[i],sufHigh.query(<span class="number">1</span>,data[i].high<span class="number">-1</span>,<span class="number">1</span>)+data[i].val);</span><br><span class="line">        sufHigh.updata(data[i].high,suf[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans=<span class="built_in">max</span>(ans,pre[i]+suf[i]-data[i].val);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数据结构</tag>
        <tag>优化技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络学习笔记</title>
    <url>/2020/07/23/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>参考资料</p>
<p><a href="https://www.bilibili.com/video/BV1Fx41177ws?from=search&seid=12098496866036507280" target="_blank" rel="noopener">卷积神经网络基本概念</a></p>
<p><a href="https://www.bilibili.com/video/BV1FT4y1E74V?from=search&seid=12963457179286848962" target="_blank" rel="noopener">吴恩达深度学习课程</a></p>
<p><a href="https://blog.csdn.net/dadapongi6/article/details/105668394" target="_blank" rel="noopener">吴恩达深度学习相关资料</a></p>
</blockquote>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%BF%87%E7%A8%8B">反向传播过程</a><ul>
<li><a href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92logistic-regression">逻辑回归(Logistic Regression)</a></li>
<li><a href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%9A%84%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0">逻辑回归的代价函数</a></li>
<li><a href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95">梯度下降法</a></li>
<li><a href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D">逻辑回归与梯度下降</a></li>
<li><a href="#%E5%90%91%E9%87%8F%E5%8C%96">向量化</a></li>
<li><a href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E9%87%8A">损失函数的解释</a></li>
<li><a href="#%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0">激活函数</a></li>
<li><a href="#softmax%E5%9B%9E%E5%BD%92">Softmax回归</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%9A%84%E7%90%86%E8%A7%A3">反向传播的理解</a></li>
</ul>
</li>
<li><a href="#%E5%90%91%E5%89%8D%E4%BC%A0%E6%92%AD%E8%BF%87%E7%A8%8B">向前传播过程</a><ul>
<li><a href="#%E5%8D%B7%E7%A7%AF%E5%B1%82">卷积层</a></li>
<li><a href="#%E6%B1%A0%E5%8C%96%E5%B1%82">池化层</a></li>
<li><a href="#%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82">全连接层</a></li>
<li><a href="#%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82%E4%B8%8E%E5%8D%B7%E7%A7%AF%E5%B1%82%E7%9A%84%E5%85%B3%E7%B3%BB">全连接层与卷积层的关系</a></li>
</ul>
</li>
<li><a href="#%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF">优化技术</a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">输入输出</a><ul>
<li><a href="#%E5%AF%B9%E5%8F%82%E6%95%B0%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96">对参数的随机初始化</a></li>
<li><a href="#%E5%BD%92%E4%B8%80%E5%8C%96">归一化</a></li>
</ul>
</li>
<li><a href="#batch-normalizing-%E6%89%B9%E5%BD%92%E4%B8%80%E5%8C%96">Batch Normalizing 批归一化</a><ul>
<li><a href="#batch-normlizing%E7%9A%84%E7%90%86%E8%A7%A3">Batch Normlizing的理解</a></li>
</ul>
</li>
<li><a href="#%E4%BC%98%E5%8C%96%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D">优化梯度下降</a><ul>
<li><a href="#minibatch%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95">MiniBatch梯度下降法</a></li>
<li><a href="#%E5%8A%A8%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95">动量梯度下降法</a></li>
<li><a href="#%E5%9D%87%E6%96%B9%E6%A0%B9%E4%BC%A0%E9%80%92rmsprop">均方根传递(RMSprop)</a></li>
<li><a href="#adam%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D">Adam梯度下降</a></li>
<li><a href="#%E5%AD%A6%E4%B9%A0%E7%8E%87%E8%A1%B0%E5%87%8F">学习率衰减</a></li>
</ul>
</li>
<li><a href="#%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8">梯度消失和梯度爆炸</a><ul>
<li><a href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0">产生原因</a></li>
<li><a href="#%E6%9D%83%E9%87%8D%E5%88%9D%E5%A7%8B%E5%8C%96">权重初始化</a></li>
</ul>
</li>
<li><a href="#%E8%BF%87%E6%8B%9F%E5%90%88%E4%B8%8E%E6%AD%A3%E5%88%99%E5%8C%96">过拟合与正则化</a><ul>
<li><a href="#l1%E6%AD%A3%E5%88%99%E5%8C%96%E4%B8%8El2%E6%AD%A3%E5%88%99%E5%8C%96">L1正则化与L2正则化</a></li>
<li><a href="#inverted-dropout%E6%AD%A3%E5%88%99%E5%8C%96">Inverted Dropout正则化</a></li>
</ul>
</li>
<li><a href="#%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA">迁移学习与数据增强</a><ul>
<li><a href="#%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0">迁移学习</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA">数据增强</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B">经典神经网络模型</a><ul>
<li><a href="#lenet-5">LeNet-5</a></li>
<li><a href="#alexnet">AlexNet</a></li>
<li><a href="#vgg">VGG</a></li>
<li><a href="#resnet">ResNet</a></li>
<li><a href="#inception">Inception</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B8%AD%E7%9A%84%E4%B8%89%E7%B1%BB%E9%97%AE%E9%A2%98">计算机视觉中的三类问题</a><ul>
<li><a href="#%E7%89%B9%E5%BE%81%E7%82%B9%E6%8F%90%E5%8F%96">特征点提取</a></li>
<li><a href="#%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B">目标检测</a></li>
<li><a href="#%E9%A2%84%E6%B5%8B%E6%A1%86%E7%9A%84%E9%80%89%E6%8B%A9">预测框的选择</a></li>
<li><a href="#anchor-boxes%E9%94%9A%E5%AE%9A%E6%A1%86">Anchor Boxes锚定框</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先 ，卷积神经网络CNN能做什么呢？</p>
<p>一个简单的例子 它能将一个二维像素点组成的图形进行识别 判断是”x” or “ o”</p>
<img src="/.io//timg.gif" data-original="CNN_example1.png">



<p>当然被判断的二维像素点图像不是非常规整的 可能是经过旋转，平移，或需要从更复杂的情况下辨别出 到底是 “x” 还是 “o”。</p>
<p>除了CNN卷积神经网络还有其他的深度学习神经网络</p>
<img src="/.io//timg.gif" data-original="CNN_example0.png">



<p>那么CNN是如何将一副原始像素点图转化成可处理对象 并判断它的？</p>
<p>下面的流程图展示了CNN大致的训练流程</p>
<img src="/.io//timg.gif" data-original="CNN_flowchart.png">

<p>根据这张流程图 下面将详细展开每一块的具体操作</p>
<h1 id="反向传播过程"><a href="#反向传播过程" class="headerlink" title="反向传播过程"></a>反向传播过程</h1><blockquote>
<p>反向传播实际上就是通过梯度下降来反馈调节向前传播的参数达到学习目的</p>
<p>逻辑回归:用于拟合离散函数并根据输入预测相应的离散函数值</p>
<p>梯度下降:通过对代价函数的分析运算寻找到更合适的$w,d$ 的反馈学习过程</p>
<p>向前传播是不断迭代逻辑回归的过程，而反向传播是使用梯度下降更新参数$w,b$的过程 </p>
<p><em>key words: 逻辑回归, 激活函数, 损失函数, 代价函数, 梯度下降法</em></p>
</blockquote>
<h2 id="逻辑回归-Logistic-Regression"><a href="#逻辑回归-Logistic-Regression" class="headerlink" title="逻辑回归(Logistic Regression)"></a>逻辑回归(Logistic Regression)</h2><p>线性回归是根据给定关系推测出一个连续函数,如给出一组房价-面积关系推测出一个连续函数拟合数据,</p>
<p>而逻辑回归通常用于拟合离散函数并根据输入预测相应的离散函数值或者说分类问题, 例如判断邮件是否为垃圾邮件。</p>
<img src="/.io//timg.gif" data-original="CNN_example12.png">

<p>$w$是一个$nx$维向量（因为$w$实际上是特征权重，维度与特征向量相同）</p>
<p>比如 上一层特征向量大小为(nx,m)那么$w^T$的大小(r,nx)</p>
<p>$b$是一个实数（表示偏差）</p>
<p>而$x$就是输入的训练数据集/上一层特征向量 </p>
<p>我们想让$yhat$ 通过计算得到的预测值 它表示[0,1]的概率</p>
<p>在二分分类中$yhat=P(y=1|x)$ 表示在给出样本$x$的前提下 通过DNN判断出$y=1$的概率</p>
<p>比如对于正确值(lable)$y=1$的样本$P(y=1|x)$应该取向于1</p>
<p>而对于(lable)$y=0$的样本$P(y=1|x)$应该取向于0</p>
<p>所以需要一个sigmoid函数做映射转换</p>
<h2 id="逻辑回归的代价函数"><a href="#逻辑回归的代价函数" class="headerlink" title="逻辑回归的代价函数"></a>逻辑回归的代价函数</h2><p>为了训练逻辑回归模型的参数参数$w$和参数$b$我们，需要一个代价函数，通过训练代价 函数来得到参数$w$和参数。$b$为了让模型通过学习调整参数，你需要给予一个$m$样本的训练集，这会让你在训练集上 找到参数$w$和参数$b$，来得到你的输出 。</p>
<img src="/.io//timg.gif" data-original="CNN_example13.png">

<p>我们在二分类中用到的损失函数是：$𝐿(𝑦hat, 𝑦) = −𝑦log(𝑦hat) − (1 − 𝑦)log(1 − 𝑦hat)$</p>
<p>(没注明log的底数默认为以e为底) 这个公式实际上叫做交叉熵函数。</p>
<p>当目标值(正确值)𝑦 = 1时损失函数$𝐿 = −log(𝑦hat)$，如果想要损失函数𝐿尽可能得小，</p>
<p>那么𝑦hat就要尽可能大,因为 sigmoid 函数取值[0,1]，所以𝑦hat会无限接近于 1。 </p>
<p>当目标值(正确值)𝑦 = 0时损失函数$𝐿 = −log(1 − 𝑦hat)$，如果想要损失函数𝐿尽可能得小，</p>
<p>那么𝑦hat就要尽可能小，因为 sigmoid 函数取值[0,1]，所以$𝑦hat$会无限接近于 0。 </p>
<p>一般我们用预测值和实际值的平方差或者它们平方差的一半，但是通常在逻辑回归中我们不这么</p>
<p>做，因为当我们在学习逻辑回归参数的时候，会发现我们的优化目标不是凸优化，只能找到多个局</p>
<p>部 最优值，梯度下降法很可能找不到全局最优值，虽然平方差是一个不错的损失函数，但是我 们在</p>
<p>逻辑回归模型中会定义另外一个损失函数。 </p>
<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>梯度下降法可以做什么？ </p>
<p>在测试集上，通过最小化代价函数（成本函数）𝐽(𝑤, 𝑏)来更新参数𝑤和𝑏， </p>
<p>𝐽(𝑤, 𝑏)是一对每组训练数据的损失函数<em>Loss function</em> 的均值</p>
<p>在逻辑回归问题中<em>Loss function使</em>用$𝐿(𝑦hat, 𝑦) = −𝑦log(𝑦hat) − (1 − 𝑦)log(1 − 𝑦hat)$ </p>
<img src="/.io//timg.gif" data-original="CNN_example14.png">

<p>在实践中，𝑤可以是更高的维度，但是为了更好地绘图，我们定义𝑤和𝑏，都是单一实数。</p>
<p>代价函数（成本函数）𝐽(𝑤, 𝑏)是在水平轴𝑤和 𝑏上的曲面，因此曲面的高度就是𝐽(𝑤, 𝑏)在某一点的函数值。</p>
<p>我们所做的就是找到使得代价函数（成本函数）𝐽(𝑤, 𝑏)函数值最小值的参数𝑤和𝑏。 </p>
<p>通过梯度下降逐步找到最低点对应的参数𝑤和𝑏。理想情况下, 无论在哪里初始化, 成本函数将收敛至同一个最低点。</p>
<p>但通常𝐽(𝑤, 𝑏)函数构成的梯度图像存在多个局部最低点，这导致不同的初始化参数设置会使参数𝑤和𝑏最终收敛的位置存在差异。</p>
<img src="/.io//timg.gif" data-original="CNN_example15.png">

<p>简化模型固定d的值讨论𝐽(𝑤) 和𝑤, 梯度下降实际上就是不断迭代𝑤使得它接近最低点。</p>
<p>其中α表示学习率 具体的体现在每次迭代更新的”步长” 之后会介绍如何给定一个合适的学习率。</p>
<p>虽然学习率α通常固定, 但是由于𝐽(𝑤)逐渐靠近最低点, 其偏导数(斜率)也逐渐趋近于0, 使得代价函数逐渐收敛至最低点。</p>
<p>一般习惯上在代码实现中将𝐽(𝑤, 𝑏)对𝑤的偏导(偏导将另一个无关变量视为定值参数)写作dw</p>
<p>同理将𝐽(𝑤, 𝑏)对𝑏的偏导写作db</p>
<h2 id="逻辑回归与梯度下降"><a href="#逻辑回归与梯度下降" class="headerlink" title="逻辑回归与梯度下降"></a>逻辑回归与梯度下降</h2><p>回想一下逻辑回归的公式定义如下： $𝑦hat = 𝑎 = 𝜎(𝑧) $其中$𝑧 = 𝑤^𝑇𝑥 + 𝑏$ ， $𝜎(𝑧) = 1/(1+𝑒^{−𝑧})$ </p>
<ul>
<li>损失函数有许多种可以参考<a href="https://zhuanlan.zhihu.com/p/58883095" target="_blank" rel="noopener">此处</a></li>
</ul>
<p>损失函数： $𝐿(𝑦hat, 𝑦) = −𝑦log(𝑦hat) − (1 − 𝑦)log(1 − 𝑦hat)$</p>
<p>代价函数：$ 𝐽(𝑤, 𝑏) = 1/𝑚 ∑ 𝐿(𝑦hat^𝑖 , 𝑦 ^i )  $</p>
<p>梯度下降法中𝑤和𝑏的修正量可以表达如下 :</p>
<p>$𝑤: = 𝑤 − 𝑎×𝜕𝐽(𝑤,𝑏)/𝜕𝑤 $，$𝑏: = 𝑏 − 𝑎×𝜕𝐽(𝑤,𝑏)/𝜕𝑏 $</p>
<p>假设现在只考虑单个样本的情况，单个样本的代价函数定义如下：</p>
<p>$𝐿(𝑦hat, 𝑦) = −𝑦log(𝑦hat) − (1 − 𝑦)log(1 − 𝑦hat) $ </p>
<p>$yhat=a$ 是逻辑回归的输出(预测值)$y$ 是标签值(正确值)</p>
<img src="/.io//timg.gif" data-original="CNN_example16.png">

<p>这个计算图中假设一组训练数据$x$中是有两个值{x1,x2}的矩阵 同时$w$也是一个有两个元素{w1,w2}的矩阵</p>
<p>现在模拟求解一组样本的梯度下降如何计算 ，已知输入(或初始化)x1,w1,x2,w2,b </p>
<p>目标是求$w1,w2,b$的梯度下降, 即更新$w1=w1-a×dL/dw1$,$w2=w2-a×dL/dw2$,$b=b-a×dL/db$</p>
<p>具体过程:</p>
<p>1.求$d𝐿(𝑎, 𝑦)/d𝑎$，在编写代码时变量名写作$𝑑a$</p>
<p>已知 $𝐿(𝑦hat, 𝑦) = −𝑦log(𝑦hat) − (1 − 𝑦)log(1 − 𝑦hat) $  and $yhat=a$  ($log$表示以e为底即$ln$)</p>
<p>通过微积分得到： $𝑑𝐿(𝑎,𝑦)/𝑑𝑎 = −𝑦/𝑎 + (1 − 𝑦)/(1 − 𝑎)$</p>
<p>​           </p>
<p>2.求$d𝐿(𝑎, 𝑦)/dz$ 写作$dz$ </p>
<p>通过链式法则得到$d𝐿(𝑎, 𝑦)/dz=dL(a,y) / da × da / dz$ </p>
<p>其中  $da/dz$,又有$a=𝜎(z)$ </p>
<p>所以就是求对sigmoid 函数求导, 已知$𝜎(𝑧) = 1/(1+𝑒^{−𝑧})$ ,sigmoid函数简写做$𝜎$</p>
<p>那么$d𝜎/dz=𝜎(z)*(1-𝜎(z))$ , <a href="https://blog.csdn.net/zhangyingjie09/article/details/82180199" target="_blank" rel="noopener">具体求导过程</a></p>
<p>已知 $dL(a,y) / da$ 那么经过化简得$d𝐿(𝑎, 𝑦)/dz=a-y$ </p>
<p>​        </p>
<p>3.求$d𝐿(𝑎, 𝑦)/dw1$(写作dw1),$d𝐿(𝑎, 𝑦)/dw2$(写作dw2),$d𝐿(𝑎, 𝑦)/db$(写作db)</p>
<p>注意w1,w2是矩阵$w$中的两个元素</p>
<p>根据链式法则$dL(a,y)/dw1=dz/dw1× dL(a,y)/dz$</p>
<p> $dz/dw1=x1$ 且通过第2步已经求得$d𝐿(𝑎, 𝑦)/dz$（写作”$dz$”）为$(a-y)$ </p>
<p>那么”$dw1$”=$x1×dL(a,y)/dz$ 同理可求得”$dw2$”,”$db$”</p>
<p>$dwi=xi×(a-y)$ ,$db=(a-y)$  </p>
<p>​    </p>
<p>4.更新$w1=w1-a×dL/dw1$,$w2=w2-a×dL/dw2$,$b=b-a×dL/db$</p>
<p>​    </p>
<p>以上是一个样本时的情况</p>
<p>下面在m个样本时的情况</p>
<p>​     </p>
<p>首先全局代价函数：$ 𝐽(𝑤, 𝑏) = 1/𝑚 ∑ 𝐿(𝑦hat^𝑖 , 𝑦 ^i ) $，实际上时对每个样本损失量求平均</p>
<p>那么一个样本时求$dL(a,y)/dw1$ 在m个样本时就相当于求$dJ(w,b)/dw1$ </p>
<p>对于$w$中的一个元素$w1$ ,全局代价函数对$𝑤1$的微分,也同样是各项损失对$𝑤1$微分的平均。</p>
<p>所以在m个样本中求$dwi$ 以及$db$ 就是求各项样本中的损失对它们微分的平均</p>
<img src="/.io//timg.gif" data-original="CNN_example17.png">

<p>伪代码实现</p>
<img src="/.io//timg.gif" data-original="CNN_example18.png">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">J=<span class="number">0</span>;dw1=<span class="number">0</span>;dw2=<span class="number">0</span>;db=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m <span class="comment">#枚举样本</span></span><br><span class="line"> 	z[i] = wx[i]+b;</span><br><span class="line"> 	a[i] = sigmoid(z[i]);</span><br><span class="line">	J += -(y[i]log(a[i])+(<span class="number">1</span>-y[i]*log(<span class="number">1</span>-a[i]));</span><br><span class="line">	dz[i] = a[i]-y[i];</span><br><span class="line"> 	<span class="keyword">for</span> indx = <span class="number">1</span> to nx <span class="comment">#枚举这个样本中每个特征值</span></span><br><span class="line"> 		dw[indx] += x[indx][i]*dz[i]; <span class="comment">#x[indx][i]表示第i个样本的第indx元素或特征值</span></span><br><span class="line">	db += dz(i);</span><br><span class="line">J/= m;db/= m;</span><br><span class="line"><span class="keyword">for</span> indx = <span class="number">1</span> to nx</span><br><span class="line">    dw[indx]/= m;</span><br></pre></td></tr></table></figure>

<p>然后更新$w1$,$w2$,….$wn$ (矩阵w) 和$b$ </p>
<p>$wi=wi-a×dwi$</p>
<p>$b=b-a×db$ </p>
<h2 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h2><p>在向前传播过程中计算$Z[layer]=W[layer]^TX[layer]+b[layer]$</p>
<p>$X$是由多个大小为(1,nx)的单样本$x$ 组成 下图直观的表示了向量化(矩阵计算)</p>
<p>$W$的维度(r,nx) r可以变化在输出层中r=1(二分类问题)那么$W[layer]^TX[Layer]+b[layer]$ 就等于一个实数</p>
<img src="/.io//timg.gif" data-original="vectorized_eaxmple.png">





<p>如何优化for循环使得逻辑回归中的矩阵运算加速</p>
<p>在python的numpy库 可以直接进行向量运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z=<span class="number">0</span></span><br><span class="line">///<span class="keyword">for</span>循环模拟矩阵运算</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n_x)</span><br><span class="line">   z+=w[i]*x[i] ///假设为(<span class="number">1</span>,nx)的w矩阵和(nx,<span class="number">1</span>)的x矩阵相乘</span><br><span class="line">z+=b</span><br><span class="line"></span><br><span class="line">///多线程并行模拟矩阵运算</span><br><span class="line">z=np.dot(w,x)+b</span><br></pre></td></tr></table></figure>

<p>这个方法加速矩阵运算的原理是让CPU/GPU运行SIMD指令 让它们能够并行运算</p>
<p>或者说同时计算矩阵中对应元素相乘 并得到结果，而非逐个遍历相乘再相加</p>
<img src="/.io//timg.gif" data-original="CNN_example19.png">

<p>上面展示了用numpy.dot()计算逻辑回归</p>
<p>$w$是一个(r,nx),(这里假设r=1)的列向量 $X$是由多个$x^i$ 组成的训练集大小为 (nx,m) </p>
<p>在使用numpy库中的函数Z=numpy.dot(w.T,X) + b , $Z$也是一个(1,m)大小的矩阵</p>
<p>原本b是一个实数当他与向量相加时它被自动转化成对应大小的矩阵</p>
<p>使用向量化计算逻辑回归&amp;梯度下降</p>
<img src="/.io//timg.gif" data-original="CNN_example20.png">

<p>已知矩阵$𝑎 = 𝜎(𝑧)$和真实值构成的矩阵$y$ ,通过求导化简得到的公式$dz=a-y$ 求得(1,m)大小的$dz$矩阵</p>
<p>而之前用for循环累加模拟矩阵运算$dw$ 实际上是 (nx,m)的矩阵$X$ 乘 (m,1) 的矩阵$dz^T$ (T表示转置)</p>
<img src="/.io//timg.gif" data-original="CNN_example21.png">

<p>for循环实现和.dot函数实现对比 </p>
<p>省略掉代价函数$J$的计算 因为原来计算代价函数是为了求导$dw$等其他需要的参数,</p>
<p>后来通过求导化简发现可以忽略掉代价函数(与它无关)的计算直接求得$dw$ 等其他需要的参数所以就省略了</p>
<h2 id="损失函数的解释"><a href="#损失函数的解释" class="headerlink" title="损失函数的解释"></a>损失函数的解释</h2><img src="/.io//timg.gif" data-original="CNN_example22.png">

<p>回顾$yhat=P(y=1|x)$ 所以$P(y|x)$ (这个概率表示给定样本x时正确预测出为y的概率)可以如上表示</p>
<p>如果要省去if表达式则可以用指数函数表示 $P(𝑦|𝑥) = 𝑦hat^𝑦 × (1 − 𝑦hat)^{(1−𝑦)} $</p>
<img src="/.io//timg.gif" data-original="CNN_example23.png">

<p>我们想衡量这个$P(𝑦|𝑥)$ 概率的大小 对它取log</p>
<p>则有$logP(𝑦|𝑥)=ylog(yhat)+(1-y)log(1-yhat)$  </p>
<p>发现这就是损失函数$Loss function$ 取负数</p>
<p>因为这个值$logP(y|x)$的大小表示  预测值与正确值是否贴近 预测值与正确值差的越大 </p>
<p>需要修正的量越大，对$w,b$的调整越大相差越小 需要调整的越小 对$w,b$的调整越小 ，</p>
<p>所以$-logP(y|x)$来表示损失函数 。</p>
<p>对于m个样本的情况时，所有样本预测值都与正确值相同的概率是</p>
<img src="/.io//timg.gif" data-original="CNN_example24.png">

<p>同样的取log后变为</p>
<img src="/.io//timg.gif" data-original="CNN_example25.png">

<p>对这个求和取平均得到的就是代价函数$J$ 。</p>
<p>在pytorch中的交叉熵损失函数nn.CrossEntropyLoss(类) 或 F.cross_entropy(函数) </p>
<p>实际上是log_softmax + nll_loss(negtive log likelihood)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#理解多分类中的nll.loss函数 (nll = negative log likelihood)</span></span><br><span class="line"><span class="comment">#nll_loss实际没有求log，它默认输入已经使用过log_softmax</span></span><br><span class="line">predic = torch.randn(<span class="number">6</span>,<span class="number">3</span>) <span class="comment">#假设最后输出6个样本，每个样本对应三种分类的概率</span></span><br><span class="line">label = tensor([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]) <span class="comment">#假设这6个样本对应的正确的标签为label</span></span><br><span class="line">nll_loss = F.nll_loss(predic,label,reduction=<span class="string">'none'</span>) <span class="comment">#reduction = mean 求平均，sum 求和</span></span><br><span class="line">same_as_nll_loss = -predic[range(<span class="number">6</span>),label]<span class="comment">#注意取负数</span></span><br><span class="line">print(nll_loss)</span><br><span class="line">print(same_as_nll_loss)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># F.log_softmax?</span></span><br><span class="line"><span class="comment">#dim=1对每一行进行softmax，一行表示一个样本对应三个分类的可能性</span></span><br><span class="line">predic_after_log_softmax = F.log_softmax(predic,dim=<span class="number">1</span>) </span><br><span class="line">nll_loss2 = F.nll_loss(predic_after_log_softmax,label,reduction=<span class="string">'none'</span>)</span><br><span class="line">predic_after_log_softmax2 = torch.log(torch.softmax(predic,<span class="number">1</span>))</span><br><span class="line">nll_loss3 = F.nll_loss(predic_after_log_softmax2,label,reduction=<span class="string">'none'</span>)</span><br><span class="line"><span class="comment"># print(predic)</span></span><br><span class="line"><span class="comment"># print(torch.softmax(predic,1))</span></span><br><span class="line">print(nll_loss2)</span><br><span class="line">print(nll_loss3) <span class="comment">#F.log_softmax = torch.log(torch.softmax)</span></span><br><span class="line"><span class="comment"># log_softmax + nll_loss = nn.CrossEntropyLoss(类) = F.cross_entropy(函数)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">import torch.nn as nn</span></span><br><span class="line"><span class="string">import torch.nn.functional as F</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">loss_func = nn.CrossEntropyLoss(reduction=<span class="string">'none'</span>)</span><br><span class="line">print(loss_func(predic, label))</span><br><span class="line">print(F.cross_entropy(predic, label, reduction=<span class="string">'none'</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">''' #输出</span></span><br><span class="line"><span class="string">tensor([-0.5667, -0.8479, -0.4085,  0.3947, -0.1787,  1.1803])</span></span><br><span class="line"><span class="string">tensor([-0.5667, -0.8479, -0.4085,  0.3947, -0.1787,  1.1803])</span></span><br><span class="line"><span class="string">tensor([0.4737, 1.4688, 1.0265, 2.4169, 0.9445, 3.0860])</span></span><br><span class="line"><span class="string">tensor([0.4737, 1.4688, 1.0265, 2.4169, 0.9445, 3.0860])</span></span><br><span class="line"><span class="string">tensor([0.4737, 1.4688, 1.0265, 2.4169, 0.9445, 3.0860])</span></span><br><span class="line"><span class="string">tensor([0.4737, 1.4688, 1.0265, 2.4169, 0.9445, 3.0860])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<img src="/.io//timg.gif" data-original="CrossEntropyLoss.png">

<p>多分类中使用softmax激活函数作为最后的输出值(之后会详细介绍):</p>
<p>具体的如$softmax(a)=e^a/(e^a+e^b+e^c)$</p>
<p>pytorch中的nll_loss(负对数似然值)并没有取对数的操作,设计者默认已经使用了log_softmax。</p>
<p>因为在softmax中同时进行log运算更快。</p>
<p>label mat 标签矩阵可以认为是一个和预测矩阵同维度的0/1矩阵。</p>
<p>具体的如上图中的label mat：[0, 1, … , 2] = [[1, 0, 0], [0, 1, 0], …. [0, 0, 1]]。</p>
<p>那么nll_loss 可以视作:</p>
<p>$predic mat(after log softmax) × label mat$ 此处’×’表示对应位值相乘。</p>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p><em>在下文中对未确定激活函数的神经元使用$g()$ 代替表示</em></p>
<p>sigmoid函数   $𝜎(z)= 1/(1+𝑒^{-z}) $</p>
<p>它的导数 $𝜎‘(z)=𝜎×(1-𝜎) $</p>
<img src="/.io//timg.gif" data-original="sigmoid.png">

<p>tanh函数 $tanh(z)=(𝑒^𝑧 − 𝑒^{−𝑧})/ (𝑒^𝑧+ 𝑒^{-z})$</p>
<p>它的导数 $tanh‘(z)=1-tanh^2(z) $</p>
<img src="/.io//timg.gif" data-original="tanh.png">

<p>实验表明多数情况下果在隐藏层上使用tanh激活函数  效果总是优于 sigmoid 函数 其均值是更接近0的 </p>
<p>但有一个例外：在二分类的问题中，对于输出层，因为𝑦的值是 0 或 1，所以想让𝑦hat的数 值介于 0 和 1 之间，</p>
<p>而不是在-1 和+1 之间。所以需要在输出层使用 sigmoid 激活函数，然后其它的所有单 元都选择 Relu 函数。</p>
<p>Relu函数 $Relu(z)=max(0,z)$</p>
<p>它的导数在z&lt;=0是接近0,大于0时为1</p>
<img src="/.io//timg.gif" data-original="Relu.png">

<p>如果在隐藏层上不确定使用哪个激活函数，那么通常会 使用 Relu 激活函数。</p>
<p>有时，也会使用 tanh 激活函数，但 Relu 的一个优点是：当𝑧是负值的 时候，导数等于 0。  </p>
<p>但从实际上来说，当使用𝑧的导数时，𝑧=0 的导数是没有定义的 </p>
<p>因此引入了Leaky Relu 函数(它整体不是线性的，因为不是一条直线 )</p>
<img src="/.io//timg.gif" data-original="LeakyRelu.png">



<p>为什么要引入非线性激活函数 (如sigmoid tanh)</p>
<blockquote>
<p>因为非线性激活函数实际上是在模仿人的神经元 只有刺激到达一定的剧烈程度才会产生电信号,</p>
<p>而剧烈程度反映在激活函数中就是其导数 而线性函数的导数是定值所以没有意义。</p>
<p>(摘自弹幕)</p>
</blockquote>
<p>假设激活函数为$g(z)=z$  ,那么会导致无论网络有多深，</p>
<p>最终输入与输出值之间的映射相当于一个单纯的线性映射。</p>
<img src="/.io//timg.gif" data-original="UseLinearActiveFunction.png">

<h2 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h2><p>softmax回归对应logistic 回归 用于分类问题 而不仅限于二分分类 成为C类问题</p>
<img src="/.io//timg.gif" data-original="CNN_softmax.png">

<p>比如从多个事物中辨别指定事物就需要用到softmax回归</p>
<p>而softmax回归具体实现就是运用激活函数</p>
<p>$softmax(x)=e^x/ ∑e^x$ 其中x是一个向量(1,nx) 这也是它与其他激活函数不同的地方</p>
<p>对于这个公式的理解就是对向量中所有元素进行归一化变为一个和=1的概率值</p>
<p>其中向量中每个元素代表判断为某具体事物的概率P(cat|x) 等等</p>
<img src="/.io//timg.gif" data-original="CNN_softmax2.png">

<p>softmax和hardmax对应，hardmax就是实际值对于一个确定答案的分类问题</p>
<p>它的label=[0,0,0,0,1] 而softmax所得到的预测label=[0.01,0.01,0.01,0.01,0.95] </p>
<p>是所有概率中取得最大的值作为判断结果</p>
<p>对于softmax输出矩阵(1,n)中第i个元素对输入矩阵中第j个元素的求导 (<a href="https://blog.csdn.net/weixin_44538273/article/details/86671655" target="_blank" rel="noopener">推导过程</a>)</p>
<p>设输入矩阵为$z$,那么有$D_jS_i=∂ softmax(z_i)/∂ z_j$其中 $S_i=softmax(z_i)$</p>
 <img src="/.io//timg.gif" data-original="CNN_softmax1.png">

<p>设输入矩阵z ,$softmax(z)=yhat$, $Loss(yhat,y)=-ylogyhat$</p>
<p>(连接博客中的Loss函数求和表示单个样本向量中所有元素求值相加此处直接表示对矩阵每个元素运算)</p>
<p>现在要求$dL/dz=dL/dyhat × dyhat/dz$ </p>
<img src="/.io//timg.gif" data-original="CNN_softmax4.png">

<p>其中$pi=yhati$ ,$xi=z[i]$</p>
<p>在代码中变量命名为”dz”=$dL/dz=yhat-y$</p>
<p>注意此处得到这样的dz ,前提是使用,$softmax(z)$, $Loss(yhat,y)=-ylogyhat$</p>
<p>发现这个结果与之前在求sigmoid作为激活函数的二分分类问题中dz完全一样</p>
<p>因为当C类问题所要判断的对象只有一个那么它就退化成二分分类问题</p>
<p>对于softmax输出矩阵(1,n)中第i个元素对输入矩阵中第j个元素的求导 就只有i=j的情况了 </p>
<p>与sigmoid函数求导相同</p>
<img src="/.io//timg.gif" data-original="CNN_softmax3.png">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这里总结一下上面提及的激活函数及其导数</span></span><br><span class="line"><span class="string">的python代码实现</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#激活函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Relu</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.where(x&gt;<span class="number">0</span>,x,<span class="number">0.0001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#激活函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tanh</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.tanh(x)</span><br><span class="line"><span class="comment">#激活函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span></span><br><span class="line">    exp=np.exp(x-x.max())</span><br><span class="line">    <span class="keyword">return</span> exp/exp.sum()</span><br><span class="line"></span><br><span class="line"><span class="comment">#激活函数的导数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d_Relu</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.where(x&gt;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.0001</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d_softmax</span><span class="params">(data)</span>:</span></span><br><span class="line">    temp=softmax(data)</span><br><span class="line">    <span class="keyword">return</span> np.diag(temp)-np.outer(temp,temp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d_tanh</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="comment">#return np.diag(1/(np.cosh(data))**2)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(np.cosh(data)**<span class="number">2</span>)</span><br><span class="line">    <span class="comment">#加速运算优化不用对角矩阵</span></span><br><span class="line">    <span class="comment">#对应的若不用对角矩阵反向传播过程中的内积改为矩阵内元素逐个相乘</span></span><br></pre></td></tr></table></figure>

<h2 id="反向传播的理解"><a href="#反向传播的理解" class="headerlink" title="反向传播的理解"></a>反向传播的理解</h2><img src="/.io//timg.gif" data-original="CNN_example30.png">

<p>反向传播实际上是不断按照链式法则求导的过程</p>
<p>下图中某些×1/m是在m个样例的情况下取平均</p>
<p>np.sum()函数中的axis=1表示水平求和 keepdims=true保证输出的矩阵仍然是(n[2],1)的矩阵</p>
<img src="/.io//timg.gif" data-original="CNN_example29.png">

<p>这里只讨论一个样本的情况所以用小写z,a表示一个样本得到的值括号中表示层级[layer]</p>
<p>一个样本的代价函数$J$就是损失函数$L$ </p>
<p>注释：以下$g[layer]’(x)$表示第layer层的激活函数对x求导 </p>
<p>对于”dz[1]”(即dL/dz[1])如何得到 通过链式法则得$dz[1]=dL/dz[2]×dz[2]/da[1]×da[1]/dz[1]$</p>
<p>其中$dL/dz[2]=a[2]-Y$ ,  $dz[2]/da[1]=W[2]$ , $da[1]/ dz[1]=g[1]’(z[1])$</p>
<p>所以推得 $“dz[1]”=dL / dz[1]=W[2]^T(a[2]-Y)×g[1]’(z[1])$</p>
<ul>
<li><h2 id="插入语"><a href="#插入语" class="headerlink" title="插入语"></a>插入语</h2><p>这里×号表示矩阵内元素逐个相乘而不是矩阵乘法 原因如下：</p>
<p>本来推导公式求导得到两个矩阵,按照规则点乘 没有问题</p>
<p>但由于其中某个矩阵是求导计算中产生的对角矩阵 </p>
<p>比如输入z为(1,nx)矩阵 g(z)=a 为(1,nx)矩阵 求da/dz时实际上是a[j]对z[i]求导</p>
<p>当i ! = j 时da[j]/dz[i]=0 否则存在值 因此da/dz实际上是一个对角矩阵</p>
<p>所以干脆把对角矩阵压成(1,nx)大小的矩阵 逐个乘(1,nx)的矩阵</p>
<p>就相当于(nx,nx)的对角矩阵点乘(1,nx)的矩阵</p>
<p>而对于softmax函数求导就比较特殊由于da[j]/dz[i]中i !=j 也有值</p>
<p>所以不能优化为逐个相乘，老老实实遵守规则点乘</p>
<p>另外在 <a href="https://www.bilibili.com/video/BV1m4411x7KU" target="_blank" rel="noopener">大野喵渣的简单神经网络实战</a>中在反向传播过程推导出现了 outer运算</p>
<p>对于(1,n) outer (1,m) 就相当于  (n,1) dot (1,m)  </p>
<p>outer对于高维矩阵(n,m) 会flatten至(1,n*m)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])  <span class="comment">###此时a是一个array对象</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">#array([[1,2],[3,4],[5,6]])</span></span><br><span class="line">print((a.flatten())</span><br><span class="line"><span class="comment">#array([1,2,3,4,5,6])</span></span><br></pre></td></tr></table></figure>

<p>两者含义和计算结果相同 使用outer感觉徒增理解难度</p>
</li>
</ul>
<p>​     </p>
<p>在$“dz[1]”=dL / dz[1]=W[2]^Tdz[2]×g[1]’(z[1])$ 中，</p>
<p>前两项相乘维度为(n[1],n[2])×(n[2],1)=(n[1],1) 后一项为(n[1],1)两者相乘要保证最后输出仍然为(n[1],1);</p>
<p>注意：这里的矩阵：𝑊[2]的维度是：(𝑛[2], 𝑛[1])。𝑧[2] ， 𝑑𝑧[2]的维度都是：(𝑛[2], 1)，</p>
<p>若从上一层输入m个样本时dZ[2]则为(n[2],m)如果是二分类，那维度就是(1,1)。对于任何变量dz和z的维度一样</p>
<p>总结一下 左边是逐个样本计算右边是将m个样本向量化</p>
<img src="/.io//timg.gif" data-original="CNN_example31.png">

<p>反向传播需要计算</p>
<p>$dZ[l]=dA[l]×g[l]’(Z[l])$ 此处×号表示矩阵逐个元素相乘</p>
<p>$dW[l]=1/m× dZ[l]A[l-1]^T$  </p>
<p>$db[l]=1/m × np.sum(dZ[l],axis=1,keepdims=True)$ </p>
<p>$dA[l-1]=W[l]^TdZ[l]$ </p>
<img src="/.io//timg.gif" data-original="CNN_example32.png">

<p>对于向前传播时需要对x初始化，同样反向传播需要对$da[l]$初始化 $da[l]=-y/a+(1-y)/(1-a)$</p>
<p>在二分分类传播中最后a[l]为一个实数A[l]的大小为(1,m)</p>
<p>扩展到更深层的神经网络</p>
<img src="/.io//timg.gif" data-original="CNN_example33.png">

<p>对于向前传播</p>
<p>输入 A[l-1] 计算Z[l], A[l] 输出A[l] 缓存Z[l];</p>
<p>对于反向传播</p>
<p>输入dA[l],Z[l] 计算 dW[l],db[l],dA[l-1] 输出dA[l-1]</p>
<p>缓存Z[l]是因为向前传播计算A[l]=g(Z[l])</p>
<p>以及反向传播时计算$dZ[l]=dA[l]×g[l]’(Z[l])$ 时会用到 (此处的×表示逐个元素相乘)</p>
 <img src="/.io//timg.gif" data-original="CNN_example34.png">



<ul>
<li><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2></li>
</ul>
<p>检查每一层参数维度是否正确的小技巧</p>
<p>$w^{[l]}:(n^{[l]},n^{[l-1]})$ </p>
<p>当训练集中只有一个样本时</p>
<p>$z^{[l]},a^{[l]},b^{[l]}:(n^{[l]},1)$</p>
<img src="/.io//timg.gif" data-original="CNN_CheckDimensionality.png">

<p>当训练集中有m个样本时</p>
<p>$Z^{[l]},A^{[l]},b{[l]}:(n^{[l]},m)$</p>
<img src="/.io//timg.gif" data-original="CNN_CheckDimensionality1.png">

<h1 id="向前传播过程"><a href="#向前传播过程" class="headerlink" title="向前传播过程"></a>向前传播过程</h1><blockquote>
<p>卷积和池化主要是在模拟生物脑 提取事物特征 抽象化具体特征的过程 (压缩图片)</p>
<p>当取得图片的具体特征后经过全连接层×权重并求和判断结果</p>
<p>比如识别一个汉字 取得了它有’横’ ‘竖’ ‘撇’ 等特征 </p>
<p>每个特征对预测结果有权重即是哪个特征对最后判断影响更大某些则比较小(乘权重的含义)</p>
<p>哪几个特征表明是某个字的可能性比较大 (求和的含义)</p>
<ul>
<li>以上均为个人理解</li>
</ul>
<p>在向前传播过程中具体包括: </p>
<p>卷积层 → 池化层 → …(Repeat)… → 全连接层 → …(Repeat)…</p>
<p>convolution → pooling → …(Repeat)… → full connected …</p>
<p>全连接层中逻辑回归和激活函数的内容在上文中已经学习了</p>
<p><em>key words: 卷积, 池化, 全连接</em></p>
</blockquote>
<h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><p>卷积有两组输入：特征图和卷积核，卷积需要依据滑动 步长(stride)、填充长度(padding)、卷积核窗口大(filtersize)、分组数(groups)、扩张系数(dilation rate) 来决定如何计算。 </p>
<p>卷积核(filter) 也叫过滤器  一般的选择的卷积核的大小为n×n 且n为奇数</p>
<img src="/.io//timg.gif" data-original="CNN_example3.png">

<p>每次卷积和都会和特征图中的一块与他大小相同的区域进行<strong>运算：</strong></p>
<p>比如特征图 为RGB三通道 6×6的 三维矩阵</p>
<p>每层对应的Xi×Yi 最后求和(三层中所有点求和) 得到Fi</p>
<p>步长即卷积核每次平移的单位 每次平移后再次进行<strong>运算</strong> 得到新的 Fi</p>
<p>由于处于特征图边缘的值对卷积结果影响较小(参与<strong>运算</strong>次数少) 而靠进中心的则被多次运算 对结果影响大</p>
<p>所以引入了<strong>padding</strong> 即给原特征图周围加上几层值为0(一般)的像素点 使得原图边缘的值的影响因子更大</p>
<p>有两种较为常用的<strong>pading</strong>策略</p>
<p><strong>Same pading</strong>  输出结果的大小与处理前一致 </p>
<p><strong>valid pading</strong>  输出的结果的大小比处理前小</p>
<p>所以整个卷积过程可以表示为</p>
<img src="/.io//timg.gif" data-original="CNN_example2.png">

<p>最后得到一次卷积后的结果为 </p>
<p>Nc(卷积核的个数而非特征图或卷积核的通道数) ×n[i]×n[i] 的矩阵 </p>
<p>其中$n[i]= floor( (n[i-1]+2×padding - filtersize)/stride+1) $</p>
<p>​    </p>
<p>实际上一个卷积核表示某种特征 </p>
<p>比如对于垂直边缘卷积核 是要提取图片中垂直分界区域 也就是垂直特征</p>
<p>水平边缘卷积核 是要提取图片中水平垂直分界区域</p>
<p>也就是 水平特征 卷积核越多 代表所提取的特征因素越多</p>
<p>而经过卷积的图片被逐渐降维则代表抽象化程度更高, 即从具体到抽象的特征提取 </p>
<p>具体表现在卷积后Fi一个数值来表示上一层某块区域的值</p>
<h2 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h2><p>降低数据的维度,缩减模型大小,可以避免过拟合,提高所提取特征的健壮性</p>
<p>避免过度拟合的意思是 比如说训练一个识别面部的神经网络</p>
<p>你希望能辨别出所有人的脸 而不仅仅是你的脸</p>
<img src="/.io//timg.gif" data-original="CNN_example4.png">

<p>池化操作也有对应的超级参数(固定值不受反馈学习影响) 大小(size)以及步长(stride),通常没有pading</p>
<p>具体的以上图为例 pooling 就是提取对应色块的Max value (还有一种取平均值的池化操作)</p>
<p>池化操作后新的特征图size：$n[i]= floor( (n[i-1] - filtersize)/stride+1)$ </p>
<p>对于多通道的池化操作 每层对应的区域取Max value 池化后输出的通道数Nc与原特征图相同</p>
<h2 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h2><blockquote>
<p>全连接层有什么用?</p>
<p>参考博客<a href="https://blog.csdn.net/qq_40957196/article/details/86039082" target="_blank" rel="noopener">深入理解CNN卷积层、池化层、全连接层</a></p>
</blockquote>
<p>这是一个神经元 从上一层神经元输入了三个量x1,x2,x3 通过一个线性函数+激活函数函数$𝜎(w^Tx+b)$</p>
<p>(此处激活函数为sigmoid函数)</p>
<img src="/.io//timg.gif" data-original="CNN_example26.png">

<p>由多个神经元组成多层神经网络</p>
<p>上一层输入特征矩阵$A[0]=X=[x1,x2,x3]$ 进入到下一层的四个神经元中通过上图的线性函数+激活函数</p>
<p>每个神经元计算得到$a$组成矩阵$A[1]$输入到下一层</p>
<p>用向量化表示该过程就是 $A[layer+1]=g^{[layer]}(W[layer]X[layer]+b[layer])$</p>
<p>每层的特征权重 $W$ 偏差值$b$ 和激活函数$g^{[layer]}()$ 都不一样</p>
<p>特别的需要注意矩阵的维度是否正确 (4个神经元输出的a矩阵组成一个A矩阵大小为(4,4)的矩阵)</p>
<p>$W[layer]$大小为(r,nx) 它的r直接决定了下一层矩阵A的行数(神经元个数) 而nx表示这一层的A行数(样本数量)</p>
<p>下图中$x$为一个样本其中包含{x1,x2,x3}三个值的列向量</p>
<img src="/.io//timg.gif" data-original="CNN_example27.png">

<p>下图展示了每个神经元输出的矩阵a如何整合成A 以及向前传播的伪代码</p>
<p>从水平上看，矩阵𝐴代表了各个训练样本。从竖直上看，矩阵𝐴的不同的索引对应于不 同的隐藏单元(神经元)。</p>
<p>在垂直方向，这个垂直索引对应于神经网络中的不同节点。例如，这个节点，该值位于 矩阵的最左上角对应于激</p>
<p>活单元，它是位于第一个训练样本上的第一个隐藏单元。它的下一 个值对应于第一个训练样本上的第二个隐藏单</p>
<p>元的激活值。以及第一个训练示例 中第三个隐藏单元，等等。  </p>
<p>当水平扫描，将从第一个训练示例中从第一个 隐藏的单元到第二个训练样本，第三个训练样本……直到节点对应于</p>
<p>第一个隐藏单元的激活 值，且这个隐藏单元是位于这𝑚个训练样本中的最终训练样本。 </p>
<img src="/.io//timg.gif" data-original="CNN_example28.png">

<h2 id="全连接层与卷积层的关系"><a href="#全连接层与卷积层的关系" class="headerlink" title="全连接层与卷积层的关系"></a>全连接层与卷积层的关系</h2><p>全连接层可以是做一种特殊的卷积，</p>
<p>回忆全连接层间的传递：</p>
<img src="/.io//timg.gif" data-original="FullConnect.png">

<p>前一层所有神经元组成的矩阵$x$通过 $a=g(w^Tx+b)$ 运算变成下一层网络中的一个神经元。</p>
<p>这类似于使用卷积操作转化到下一层。</p>
<img src="/.io//timg.gif" data-original="ConvAndMat.png">

<p>如上图所示, 之前的全连接层使用$a=g(w^Tx+b)$ 可以看作 </p>
<p>对1×1×4 的矩阵分别用m个等维度的矩阵(过滤器)进行对应值相乘再求和的卷积操作，</p>
<p>最终得到一个1×1×m 的全新矩阵。</p>
<p>但实际上卷积和全连接的传递过程还是存在差别，</p>
<blockquote>
<p>考虑下面两种情况：</p>
<ol>
<li>特征图和全连接层相连，AlexNet经过五次池化后得到7×7×512的特征图，下一层全连接连向4096个神经元，这个过程可以看做有4096个7×7×512的卷积核和7×7×512的特征图进行卷积操作，最终得到1×1×4096的特征图，等价与全连接得到4096个神经元。</li>
<li>全连接层和全连接层相连，AlexNet的再下一层依然是4096个神经元，即4096个神经元和4096个神经元全连接，由(1)我们得到了1×1×4096的特征图，本次全连接过程可以看做存在4096个1×1×4096个卷积核，依次和1×1×4096的特征图进行卷积操作，等价与全连接操作。</li>
</ol>
<p>引用自<a href="https://www.cnblogs.com/liuzhan709/p/9356960.html" target="_blank" rel="noopener">理解为什么要将全连接层转化为卷积层</a></p>
</blockquote>
<p>这里涉及到一种利用Conv卷积替代FC全连接层的技巧</p>
<p>这个技巧将被用于Detection中的滑动窗口卷积操作</p>
<img src="/.io//timg.gif" data-original="FCAndConv.png">

<h1 id="优化技术"><a href="#优化技术" class="headerlink" title="优化技术"></a>优化技术</h1><blockquote>
<p>主要涉及如何解决模型的欠拟合/过拟合问题。</p>
<p>以及如何更高效的训练模型。</p>
</blockquote>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><blockquote>
<p>此处以二分分类问题为例子</p>
<p>讨论输入(训练数据集)输出(预测值yhat)</p>
<p>输入中也包括一些参数和超参数</p>
<p>参数是要在不断学习中逐渐被修正趋于最优 比如逻辑回归中的$w,b$</p>
<p>超参数则是最初给定不会改变的量比如在逻辑回归中选择的激活函数,梯度下降中的学习率α</p>
</blockquote>
<img src="/.io//timg.gif" data-original="CNN_example8.png">

<p>对于一个二分类问题 比如判断图片中是否存在猫</p>
<p>输入一个特征向量$x$ 由训练集经过卷积和池化后获得的特征图得到</p>
<p>对于上面这个例子来说 $x$ 是一个 $nx × 1$ 的向量(矩阵) 其中$nx=n×n×nc$ ，而 $y=0,1$  </p>
<p>对于m个图形成的训练集 Mtest ={$(x^1, y^1), (x^2, y^2), (x^3, y^3) … (x^m, y^m)$}</p>
<p>(此处参考资料整理作者 黄海广 在参考栏第三个链接)</p>
<img src="/.io//timg.gif" data-original="CNN_example9.png">

<img src="/.io//timg.gif" data-original="CNN_example10.png">

<p>所有训练数据集的输入值和输出集合以如下方式组成矩阵$X$,$Y$ 一般$X$的每一列是$x^i$ </p>
<img src="/.io//timg.gif" data-original="CNN_example11.png">

<h3 id="对参数的随机初始化"><a href="#对参数的随机初始化" class="headerlink" title="对参数的随机初始化"></a>对参数的随机初始化</h3><p>在输入训练集的之前要给$w,b$预设初始值 让他们能在之后的学习中有效的达到最优解</p>
<p>虽然初始化为0可行但是所有的w赋值为0会使梯度下降法失效 </p>
<p>因为每个神经元上计算得到的结果将会完全一样 之后无论如何梯度下降所有神经元的函数任然相同</p>
<p>通常会随机生成一个矩阵  w=np.random.randn((r,c))*0.01 </p>
<p>这里乘上0.01让$z=w^Tx+b$中w尽量小而不为0 所得到的z处于激活函数导数最大处</p>
<p>能让梯度下降更快提高学习效率</p>
<img src="/.io//timg.gif" data-original="Random_initial.png">

<p>另外对于初始化超参数如学习率$α$，以及后面提到的梯度下降优化算法中的$β$ </p>
<p>它们的变化对神经网络的性能影响往往需要达到数量级的变化才能有效体现。</p>
<p>所以我们通常在指数尺度上对它们进行随机初始化。</p>
<img src="/.io//timg.gif" data-original="RandomInit.png">

<p>假如使用0.0001~0.1的均匀随机分别采样 那么90%的$α$会大于0.1只有10%在0.0001到0.1之间。</p>
<p>而在对数尺度上采样 不同数量级的$α$就能被均匀的采样到了，</p>
<p>这样就能在较大尺度上选取合适的区间中筛选合适的超参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = np.random.rand()*<span class="number">4</span></span><br><span class="line">a = <span class="number">1</span>**r</span><br><span class="line"><span class="comment">#对于beta一般取0.9~0.9999</span></span><br><span class="line">beta = <span class="number">1</span> - <span class="number">1</span>**r</span><br></pre></td></tr></table></figure>



<h3 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h3><blockquote>
<p>为了更快的进行梯度下降找到代价函数的最优解 </p>
<p>通常对输入数据采取归一化处理</p>
<p>归一化或者说标准化实际就是将原来的数据集通过映射</p>
<p>变换到一个新的集合内作为网络的直接输入</p>
</blockquote>
<p>对于训练集中的样本值分布范围比较大的情况，</p>
<p>训练一个网络模型得到代价函数$J$的最优解需要耗费更多的算力</p>
<p>一般会对样本输入值进行归一化处理。 </p>
<img src="/.io//timg.gif" data-original="CNN_normalize.png">

<p>如上图，左侧是没有进行归一化输入的情况,</p>
<p>代价函数$J(w,b)$ 呈现出一个狭长的值域,</p>
<p>而获得最优解的过程将会像图中的蓝线那样寻找梯度下降</p>
<p>最快的方向移动也就是垂直于这个椭圆的切线方向,</p>
<p>同时由于这个狭长的值域我们需要设置一个较小的学习率$α$</p>
<p>以便它有效下降到最优解,但这样会导致训练效率低下</p>
<p>若将样本输入值进行归一化处理 得到的代价函数则如右图所示</p>
<p>它将更趋向于一个圆状,这样就有利于更快的找到相对最优解</p>
<p>归一化对于输入样本值的调整可以视为两步：</p>
<p>设数据集$X$包含m个样本记为$X_{(i)}=(x_1,x_2)$  </p>
<img src="/.io//timg.gif" data-original="CNN_normalizing.png">

<p>第一步零均值化：                            第二步归一化方差：</p>
<p>$u=1/m∑<em>iX</em>{(i)}^2$                            $σ^2=1/m∑<em>iX</em>{(i)}^2$</p>
<p>$X:=X-u$                                $X:=X/σ$</p>
<p>最后样本的输入值将会贴近原点且处在一个较小的区间内</p>
<ul>
<li><h3 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h3><p>作为中间值的$u$ 和$σ^2$ 无论在输入训练集还是测试集都要一致 </p>
<p>实际使用时统一用训练集中获得的$u$和 $σ^2$ 对$X$进行调整</p>
</li>
</ul>
<h2 id="Batch-Normalizing-批归一化"><a href="#Batch-Normalizing-批归一化" class="headerlink" title="Batch Normalizing 批归一化"></a>Batch Normalizing 批归一化</h2><blockquote>
<p>在上文讲到对输入数据进行归一化处理利于网络的梯度下降，</p>
<p>由此可以想到对每一层的输入都进行归一化处理，</p>
<p>直觉上是有益于优化网络学习能力的。</p>
<p>因为对于网络中每一层而言前一层的输入数据都可以视为一个特殊的生数据raw input</p>
<p>它们(输入数据)拥有相同的”地位”，</p>
<p>自然而然就会想到将输入的归一化应用到每一层输入。</p>
</blockquote>
<p>对每一层的输入矩阵进行归一化处理成为Batch Normalizing。</p>
<p>(回忆一下几个相关符号之间的关系$a_{[layer]} = g(Z_{[layer]})$而$Z_{[layer]}=w·a_{[layer-1]}+b$)</p>
<p>后者较为常用，Ng Andrew在课堂中主要讲述后者的具体实现。</p>
<p>类似的,我们需要输出矩阵的均值$μ$和方差$σ^2$。</p>
<p>由于BatchNorm对$z$进行了零均值化，因此原来线性处理中$+bias$ 就失去了意义。</p>
<p>因为无论是否加入偏移量最后经过BatchNorm的$z^{norm}$ 最终都是$μ=0$ </p>
<p>所以索性就在使用BatchNorm时将$Z_{[layer]}=w·a_{[layer-1]}+b$中的$b$省略</p>
<p>假设线性处理后的输出矩阵为$Z=[z_{(1)},z_{(2)},…,z_{(i)} ]$</p>
<p>$μ=1/m∑<em>iz</em>{(i)}$            $σ^2=1/m∑<em>i(z</em>{(i)}-μ)^2$</p>
<p>$z_{(i)}^{norm} =(z_{(i)}-μ)/sqrt(σ^2+ε)$其中$ε$是一个趋近于0的数为了避免产生除0错误</p>
<p>在获得归一化矩阵$Z^{norm}$之后我们还需要再进行一次类似线性处理的操作。</p>
<p>$Z^{hat} = γ·Z^{norm}+β$  。$Z^{hat}$将替代原来的$Z$作为激活函数的真正输入值，</p>
<p>这里的参数$γ,β$ 是为了调整$Z$的均值以及方差而设计的。</p>
<p>同样的它们也会通过后来的梯度下降方法进行更新。</p>
<img src="/.io//timg.gif" data-original="BatchNorm.png">

<p>这幅图直观的说明我们调整$γ,β$能调整$z_{(i)}$的整体分布。</p>
<p>从而能够更好的利用非线性激活函数再神经元中起到的作用。</p>
<p>最后梳理一下如何将BatchNormilzing拟合进神经网络:<br>$$<br>a_{[l-1]}→^{w,b}→Z_{[l]} → ^{μ,σ^2}→Z_{[l]}^{norm}→^{γ,β}→Z{[l]}^{hat}→^{g()}→a_{[l]}<br>$$<br>BatchNorm通常与Mini-Batch一起应用到网络学习中,以达到更好的优化网络的学习能力</p>
<p>之后将要讲述的一系列优化梯度下降法也同样可以和BatchNorm一起使用。</p>
<h3 id="Batch-Normlizing的理解"><a href="#Batch-Normlizing的理解" class="headerlink" title="Batch Normlizing的理解"></a>Batch Normlizing的理解</h3><p>对于神经网络当它学习完特定目标如识别黑猫后再对它进行下一步训练让它能够识别所有猫。</p>
<p>此时对于网络它的输入数据的特征分布矩阵就发生较大的便宜,成为covariate shift。</p>
<p>直观的理解是因为网络已经对原来的数据集 (黑猫)拟合了二分类的函数,</p>
<p>对于新的数据集由于与原来的数据集有较大偏差,网络相当于重新学习一个新任务。</p>
<img src="/.io//timg.gif" data-original="BatchNormExplain.png">

<p>同样的对于隐藏层而言前一层传来的输入值就如同模型的输入层读取的生数据。</p>
<p>对于某一层而言前方发生了什么它一概不知，只看得到前一层的输出。</p>
<p>由于在学习过程中权值和偏移量的微小改变经过深度网络的放大，</p>
<p>到某一个隐藏层时它每次所学习的”数据样本”(即中间层输入,”地位”等同于生输入)会有较大差异。</p>
<p>从而难以让之后的网络在训练之后能让参数达到一个稳定状态。</p>
<p>而将中间层输出进行BatchNorm的好处就是能让”数据样本”相对的稳定。</p>
<p>这样网络在学习时每一层都不会受到前方扰动导致的输入偏差较大而难以收敛，</p>
<p>因为输入值都会被归一化至一个较小且与过去输入值相近的区域内。</p>
<p>这也让网络的每一层(Layer)都不会过于依赖前层(相对独立),</p>
<p>在输入mini-batch时每个独立的batch有各自的”样本数据”均值与方差,</p>
<p>均值与方差的轻微差异对隐藏层起到了类似dropout随机失活的正则化效果</p>
<p>这种操作就像在级联放大电路中加入了电压跟随器(BatchNorm)，</p>
<p>使得前后两个级联放大器(Layer)相对独立。</p>
<h2 id="优化梯度下降"><a href="#优化梯度下降" class="headerlink" title="优化梯度下降"></a>优化梯度下降</h2><h3 id="MiniBatch梯度下降法"><a href="#MiniBatch梯度下降法" class="headerlink" title="MiniBatch梯度下降法"></a>MiniBatch梯度下降法</h3><blockquote>
<p>之前讲到使用向量化方法将多个训练样本整合成一个矩阵作为输入</p>
<p>然而实际训练时不会这么做,而是会将样本分批输入</p>
</blockquote>
<p>Mini-Batch或者平时说的Batch(批)实际就是一次”投喂”给系统的样本量。</p>
<p>假设原来拥有m个样本将他分成5000份Mini-Batch。</p>
<p>然后将这5000份样本依次输入。所有样本被迭代一次成为1个epoch。</p>
<img src="/.io//timg.gif" data-original="MiniBatch.png">

<p>这么做似乎和原来一个矩阵所有样本一次性输入似乎对于每个独立样本而言没有什么差别，</p>
<p>它们都只被使用一次。但是对于网络而言一次性读入所有样本只能进行一次梯度下降。</p>
<p>而Mini-Batch分批投喂却能使用等量的样本进行多次梯度下降。</p>
<p>相比一次性投喂，分批投喂能在较少次数的迭代(epoch)内让网络找到最优解。</p>
<p>代码实现上也是将每个Batch向量化后输入，通常会进行多次迭代(多个epoch)。</p>
<p>那么如何选择合适的Mini-Batch呢？</p>
<p>可以将所有样本视为一整个Batch，也可以将每个独立的样本分别当作一个Batch。</p>
<p>而恰当的Batch大小需要取两者之间。</p>
<img src="/.io//timg.gif" data-original="Choose_MiniBatch.png">

<p>如图所示，假设要通过多次梯度下降达到最优解(中心)。</p>
<p>Batch size = 1的情况下网络很难找到正确下降的方向，(这种情况下的梯度下降称为SGD)</p>
<p>因为一次投喂的样本量太少，特殊性太强而普遍性太弱，网络会提取出只符合这个样本的特征。</p>
<p>Batch size = m的情况下网络虽然能找到正确的方向稳步下降,但每次下降的步幅可能就会小。</p>
<p>因为样本的数量太多，网络需要从中一点点找到普遍特征以符合所有独立个体。</p>
<h3 id="动量梯度下降法"><a href="#动量梯度下降法" class="headerlink" title="动量梯度下降法"></a>动量梯度下降法</h3><blockquote>
<p>为了减小损失函数值在下降时向无益于减小损失值的方向移动，引入了动量梯度下降法</p>
<p>本质上是利用前几次迭代的dw(db)的指数加权平均替代原来的dw(db)来更新w(b)</p>
</blockquote>
<p>假设损失函数的梯度下降过程如下图描述,</p>
<p>可以发现它会波动性的向无益于减小损失值的方向移动</p>
<p>这显然降低了梯度下降的效率, 传统的若想让梯度下降更快,可以使用更大的学习率, </p>
<p>而更大的学习率带来的问题是会导致想错误的方向移动更远，</p>
<p>甚至偏离出可以正确下降到最优解的椭圆形区域(如紫色折线)</p>
<img src="/.io//timg.gif" data-original="Momentum_img.png">

<p>这时候动量梯度下降法可以有效的减少错误方向上的”运动”分量。</p>
<p>在实际操作时就是将原来的w以及b的更新稍作修改。</p>
<p>$V_{dw} = βV_{dw} + (1-β)dw$ </p>
<p>$V_{db} = βV_{db} + (1-β)db$</p>
<p>$w = w - αV_{dw}$ , $b = b - αV_{db}$</p>
<p>这里就涉及到了指数加权平均数的概念</p>
<ul>
<li><p>指数加权平均数</p>
<p>假设要绘制日期与气温的关系图，得到了一系列蓝色的离散坐标点。</p>
<img src="/.io//timg.gif" data-original="ExponentiallyWeighted.png">

<p>当$β=0.9$时，以$V_t = βV_{t-1} + (1-β)T_t$替代原来的温度$T_t$可以得到红色折线。</p>
<p>当$β=0.98$时，以$V_t = βV_{t-1} + (1-β)T_t$替代原来的温度$T_t$可以得到绿色折线。</p>
<p>其中$V_t$就相当于前$1/(1-β)$ 的指数加权平均温度,</p>
<p>(当$β=0.9$时约等于前十天,$β=0.98$时约等于前50天,下文称为时间窗)</p>
<p>当$β=0.9$时对递推式进行展开:$V_t = 0.1T_t+0.1×0.9T_{t-1}+0.1×(0.9)^2T_{t-2}….. $</p>
<p>发现当前时刻的温度对$V_t$的影响最大, 距离当前时刻越远的温度对$V_t$的影响就越小。</p>
<p>这种效果呈现在图中就类似于一个滤波器, 过滤了”高频的毛刺信号”</p>
<p>通常的若展开式某项其$β^n$接近$1/e$时认为它是时间窗的边界,(虽然不知道为什么)</p>
<p>可以利用$lim_{x→0}(1-x)^{1/x}=1/e$  对边界的位置进行估计,其中$x=1-β$</p>
<p>比如$β=0.9$时 代入 求得$0.9^{10}≈1/e$  即$n=10$</p>
<p>另外由于$V_0$初始化为0 递推公式中最初的几个$V_t$值会非常小，</p>
<p>通常会使用$V_t/(1-β^t)$来替代原来的$V_t$ 随着t的增大分母趋向于1对$V_t$影响越小。</p>
<p>但通常在算法实现时不会采用这种策略。</p>
<p>采用指数加权平均进行梯度下降的优势在于:计算某区间的均值时,</p>
<p>不需要将这个区间内的信息全部保留只需要保留上一次更新的$V_{dw}.V_{db}$</p>
</li>
</ul>
<h3 id="均方根传递-RMSprop"><a href="#均方根传递-RMSprop" class="headerlink" title="均方根传递(RMSprop)"></a>均方根传递(RMSprop)</h3><p>类似于动量梯度下降法, RMSprop对参数的更新方式进行了如下修改:</p>
<p>$S_{dw} = βS_{dw} + (1-β)|dw|^2$</p>
<p>$S_{db} = βS_{db} + (1-β)|db|^2$</p>
<p>$w = w - α×dw/sqrt(S_{dw}+ε)$, $b = b - α×db/sqrt(S_{db}+ε)$</p>
<p>其中$ε$ 是个趋近于0的极小值为了避免产生除0的情况。</p>
<p>对于动量梯度下降法取的是前几次下降的梯度(向量)的指数加权平均$V$ 作为替代。</p>
<p>而对于均方根传递取的是前几次下降的梯度模值(标量)的指数加权平均$S$作为替代。</p>
<img src="/.io//timg.gif" data-original="RMSprop.png">

<p>Ng Andrew举了个例子, 为了简化问题假设$J(w,b)$ 是如下图的凸函数:</p>
<p>(将向量w,b都当作一维，实际上$b$和$w$ 都是多维向量)</p>
<img src="/.io//timg.gif" data-original="RMSprop_example.png">

<p>当梯度下降时$J(w,b)$往b轴正方向移动更多时(即$dJ/db$ 比 $dJ/dw$更大时),</p>
<p>$S_{db}$ 也会比$S_{dw}$更大(实际它们是包含前几次梯度下降影响的积累值) </p>
<p>因此这时$b$的变化将会比$w$的变化更小,体现在上图就是$J(w,b)$下次将向$w$移动更多(绿色折线)</p>
<h3 id="Adam梯度下降"><a href="#Adam梯度下降" class="headerlink" title="Adam梯度下降"></a>Adam梯度下降</h3><p>Adam梯度下降汲取了前两者的特点,在实际应用中获得了较好的效果。</p>
<p>$V_{dw} = β<em>1V</em>{dw} + (1-β<em>1)dw$        $S</em>{dw} = β<em>2S</em>{dw} + (1-β_2)|dw|^2$</p>
<p>$V_{db} = β<em>1V</em>{db} + (1-β<em>1)db$        $S</em>{db} = β<em>2S</em>{db} + (1-β_2)|db|^2$</p>
<p>对$V_{dw},V_{db}$进行修正: $V^{correct} = V/(1-β_1^t)$其中t指第t项</p>
<p>对$S_{dw},S_{db}$进行修正: $S^{correct} = S/(1-β_2^t)$其中t指第t项</p>
<p>最后更新参数</p>
<p>$w = w - α×V_{dw}/sqrt(S_{dw}+ε)$</p>
<p>$b = b - α×db/sqrt(S_{db}+ε)$</p>
<h3 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h3><p>固定学习率的梯度下降会存在一个问题。</p>
<p>当$J(w,b)$靠近最优解附近时,由于学习率α(或者说更新步长)过大导致多次迭代后，</p>
<p>损失函数一直在靠近最优解附近的区域上反复横跳而无法收敛。</p>
<p>然而取小学习率会导致初期梯度下降过于缓慢。</p>
<p>一个较好的方法是学习率能随着下降的过程而逐渐减小。</p>
<p>这样既保证初期能进行快速地梯度下降，同时又能在靠近最优解时能进行”微调”。</p>
<p>通常有以下几种方案对学习率进行自适应更新：</p>
<p>$α=α_0/(1+DecayRate×epoch)$ 一个epoch表示完整的迭代所有样本一次</p>
<p>$α=0.95^{epoch}α_0$或者 $α=Kα_0/sqrt(t)$其中t表示第几个mini-batch。</p>
<h2 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h2><blockquote>
<ul>
<li>梯度消失：指梯度下降过程中出现梯数呈指数级减小趋于0 </li>
<li>梯度爆炸：指梯度下降过程中出现梯数呈指数级增大趋于∞</li>
<li>解决方案：使用ReLu激活函数或使用残差网络(下文提及)以及权重初始化方法</li>
</ul>
</blockquote>
<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>以一个简单模型为例子:</p>
<img src="/.io//timg.gif" data-original="CNN_VanishingExploding.png">

<p>假设这个神经网络模型中激活函数$g(z)=z$且$b[l]=0$ </p>
<p>那么预测值$yhat=w^{[l]}×w^{[l-1]}×…w^{[2]}×w^{[1]}×x$</p>
<p>假设特征向量中的元素值&lt;1那么在经过L层网络后w将趋近于0</p>
<p>假设特红向量中的元素值&gt;1那么在经过L层网络后w将变得很大</p>
<p>以前文sigmoid函数作为激活函数时的反向传播为例:</p>
<p>$dJ/dw^{[i]}=x^{[i]}×(a^{[i]}-y)$    </p>
<p>(x是上一层的输出这一层的输入,a是这一层经过激活函数后的输出,y是正确值)</p>
<p>由于神经网络隐藏层的深度不断加深 $w$的累乘效果越加明显</p>
<p>导致 $x^{[i]}→∞/0$  导致梯度爆炸/消失</p>
<p>对于特征向量的更新$w:=w-α×dJ/dw$ 也会失去控制/基本不变</p>
<h3 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h3><p>以单个神经元为例:</p>
<p>我们不希望这一层的$z$过大或过小 而是接近1 </p>
<p>这样即使加大深度也能尽量避免梯度消失或爆炸</p>
<img src="/.io//timg.gif" data-original="CNN_InitWeight.png">

<p>设前一层有$n^{[l-1]}$ 层神经元 那么每个特征向量的值初始化为$sqrt(1/n^{[l-1]})*w$</p>
<p>相当于给原来的特征向量×权重</p>
<p>实际上是对于所有的特征向量$w_i$ 保证他们的方差为$1/n$</p>
<p>假如使用的是ReLu激活函数那么设置$w_i$方差为2/n 更合理, 则$w_i=w_i×sqrt(2/n^{[l-1]})$</p>
<p>对于tanh激活函数则使用:</p>
<img src="/.io//timg.gif" data-original="CNN_TanhInitWeight.png">

<h2 id="过拟合与正则化"><a href="#过拟合与正则化" class="headerlink" title="过拟合与正则化"></a>过拟合与正则化</h2><blockquote>
<p>所谓过拟合 通俗来讲 就是缺乏普遍性只能处理特殊值</p>
<p>过拟合有两种原因：</p>
<p>1.训练集和测试集特征分布不一致(黑白马)</p>
<p>2.模型太复杂而样本不足</p>
<p>为了减少过度拟合引入了正则化的概念</p>
<p>正则化是针对参数的约束，而归一化是对输入的调整。</p>
<p>通常正则化的方法有：L1正则化，L2正则化，Dropout正则 （此处参考<a href="https://www.jianshu.com/p/569efedf6985" target="_blank" rel="noopener">外部博客）</a></p>
</blockquote>
<p>对于二分分类问题 将是A与非A区分开来重要的是划分”决策边界”</p>
<p>简单的线性模型准确率较低，</p>
<p>而将所有的样本A从当前的数据集划分出来会导致新加入的样本不能正确判断。</p>
<p>原因是没有正确提取抽象特征 称之为“过拟合“。</p>
<img src="/.io//timg.gif" data-original="CNN_overfitting.png">

<h3 id="L1正则化与L2正则化"><a href="#L1正则化与L2正则化" class="headerlink" title="L1正则化与L2正则化"></a>L1正则化与L2正则化</h3><ul>
<li>如何正则化</li>
</ul>
<p>L1/L2正则化实际上是在损失函数$J(w,b)$ 后加入一个“惩罚项” </p>
<p>而这个“惩罚项”实际就与Lp 范数 ($L_p norm$)有关</p>
<p>$L_p norm$ 的定义为:$||W||_p=(∑_i|w_i|^p)^{1/p}$ </p>
<p>L1正则化: $J_1(w,d)=1/m × ∑L(yhat,y) + λ/2m × ||W||_1$</p>
<p>其中$||W||_1=∑_i|w_i|$<strong>即所有特征系数绝对值的和</strong> </p>
<p>L1正则化能使得一部分特征向量趋于0 让特征矩阵变得稀疏，</p>
<p>起到特征选择的作用 达到简化模型的目的。</p>
<p>L2正则化: $J_2(w,d)=1/m × ∑L(yhat,y) + λ/2m × ||W||_2^2$ </p>
<p>其中$||W||_2^2=∑_i|w_i|^2=w^Tw$<strong>即所有特征系数的平方和</strong> </p>
<p>L2正则化能使得特征向量有比例的缩放防止过拟合，而不会起到特征选择的作用 </p>
<p>在两种正则化中都存在系数λ/2m。</p>
<p>其中λ是可调超级参数，而m是样本数量, 除2是为了消掉求导时的平方项产生的2 。</p>
<ul>
<li>那么如何处理正则化后的梯度下降(更新特征向量w)?</li>
</ul>
<p>为了方便理解将w1作为一个数，对于L1正则化而言有:</p>
<img src="/.io//timg.gif" data-original="CNN_L1norm.png">

<p>其中$dJ/dw_1=“dw_1”$是对于未加入正则项的代价函数$J(w,d)$的求导,</p>
<p>另外$sign(x)=|x|/dx = -1_{x&lt;=0} or 1_{x&gt;0}$</p>
<p>对于L2正则化而言有:</p>
<img src="/.io//timg.gif" data-original="CNN_L2norm.png">



<p>在L2正则化中对于梯度下降过程中的特征参数更新应该替换为$w:=w-αdw’$</p>
<p>其中$dw’$为加入正则项后的$dJ_2/dw$  即:  $dw’=dw+λ/m×w$</p>
<p>而$dw$是不包含正则项时$dJ/dw$ </p>
<ul>
<li>正则化问什么能防止过拟合</li>
</ul>
<p>调整正则项系数λ可以使得特征向量w趋于0 </p>
<p>而逻辑回归函数$z_{[l]}=w_{[l]}a_{[l-1]}+b_{[l]}$ 的结果$z$  也会相应减小  </p>
<p>那么激活函数$g(z)$ 就会接近线性 </p>
<p>这样就会避免“决策边界”成为一个过于复杂的高阶多元曲线函数 </p>
<p>(虽然不太明白什么原理但是感觉很有道理)</p>
<img src="/.io//timg.gif" data-original="CNN_regularization.png">

<h3 id="Inverted-Dropout正则化"><a href="#Inverted-Dropout正则化" class="headerlink" title="Inverted Dropout正则化"></a>Inverted Dropout正则化</h3><p>Inverted Dropout 也成为随机失活 一般运用在训练网络模型 而不再测试模型时使用</p>
<img src="/.io//timg.gif" data-original="CNN_dropout.png">

<p>原理就是将网络中某些点(特征)省略 从而简化网络模型</p>
<ul>
<li>向前传播过程中如何加入inverted dropout 正则化</li>
</ul>
<p>对于每个点 它是否失活(省略)的概率 被设置为 keep-prob</p>
<p>假设某一层经过激活函数输出后得到 $a_{[l]}=g(z_{[l]})$</p>
<p>在$a_{[l]}$传递到下一层网络成为$x_{[l+1]}$前</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keep_prob=<span class="number">0.8</span></span><br><span class="line">dl=np.random.rand(al.shape[<span class="number">0</span>],al.shape[<span class="number">1</span>])&lt;keep_prob</span><br><span class="line">al=np.multiply(al,bl)  <span class="comment">#al=al*dl  逐个相乘</span></span><br><span class="line">al/=keep_prob</span><br></pre></td></tr></table></figure>

<p>对所有特征量 进行随机失活 有0.8的概率保留原值 否则置为0</p>
<p>但这样操作会导致特征值中20%的值失效 为了不影响$z_{[l+1]}=w_{[l+1]}x_{[l+1]}+b_{[l+1]}$ 的期望值</p>
<p>应此最后需要将al/=keep_prob</p>
<ul>
<li>为什么dropout正则化可以避免过拟合</li>
</ul>
<blockquote>
<h3 id="“"><a href="#“" class="headerlink" title="“"></a>“</h3><p>第二个直观认识是，我们从单个神经元入手，如图，这个单元的工作就是输入并生成一些有意义的输出。通过dropout，该单元的输入几乎被消除，有时这两个单元会被删除，有时会删除其它单元，就是说，紫色圈起来的这个单元，它不能依靠任何特征，因为特征都有可能被随机清除，或者说该单元的输入也都可能被随机清除。我不愿意把所有赌注都放在一个节点上，不愿意给任何一个输入加上太多权重，因为它可能会被删除，因此该单元将通过这种方式积极地传播开，并为单元的四个输入增加一点权重，通过传播所有权重，dropout将产生收缩权重的平方范数的效果，和L2正则化类似，实施dropout的结果是它会压缩权重，并完成一些预防过拟合的外层正则化。</p>
<h3 id="”-引用自Ng-Andrew-字幕"><a href="#”-引用自Ng-Andrew-字幕" class="headerlink" title="”(引用自Ng Andrew 字幕)"></a>”(引用自Ng Andrew 字幕)</h3></blockquote>
<img src="/.io//timg.gif" data-original="CNN_dropoutExplain.png">



<h2 id="迁移学习与数据增强"><a href="#迁移学习与数据增强" class="headerlink" title="迁移学习与数据增强"></a>迁移学习与数据增强</h2><blockquote>
<p>为了提高模型训练效率 可以采用迁移学习的方法</p>
<p>将开源的深度学习模型移植到自己的模型中</p>
<p>为了在有限的训练集中 增加训练集样本提高模型准确率</p>
<p>可以采用一些手段增强数据</p>
</blockquote>
<h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>可以从开源网站中获得搭建好的网络模型 以及训练好的参数 作为初始化值</p>
<p>(不知道原先的分类对象与想要的分类对象不一致是否影响)</p>
<p>仅仅修改softmax部分(或后半部分网络) 以达到较少量的训练集就能达到较高的正确率</p>
<p>一般开源模型中会有一个开关”freeze” 将前几层网络中的参数冻结,</p>
<p>这样在训练过程中就只会修改自己搭建的几层网络中的参数</p>
<img src="/.io//timg.gif" data-original="CNN_TransferLearning.png">

<h3 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h3><p>主要有3种方式</p>
<ul>
<li>镜像对称: 即将原有的样本图片镜像对称得到新的样本</li>
<li>随机截取: 即随机截取原有样本图片的某个部分获得新的样本</li>
<li>色域调整: 即随机调整原有样本图片的RGB值生成新的图片</li>
</ul>
<h1 id="经典神经网络模型"><a href="#经典神经网络模型" class="headerlink" title="经典神经网络模型"></a>经典神经网络模型</h1><blockquote>
<p>介绍几类经典神经网络模型</p>
<p><em>LeNet-5</em> ，<em>AlexNet</em>，<em>VGG</em></p>
<p>残差网络: <em>ResNet</em></p>
<p><em>Inception</em></p>
</blockquote>
<h2 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h2><p>针对灰度图像训练</p>
<p>使用simgiod函数以及逻辑回归</p>
<p>论文来源:[LeCun et al., 1998. Gradient-based learning applied to document recongintion]</p>
<img src="/.io//timg.gif" data-original="CNN_example5.png">

<h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><p>论文来源:[Krizhevsky et al., 2012. ImageNet classification with deep convolutional neural networks]</p>
<p>使用了Relu激活函数 涉及到将图分组放入两个互相关联的gpu进行训练</p>
<p>有一种独有的类型层 “局部响应归一化层” 对局部神经元的活动创建竞争机制，使得其中响应比较大的值变得相对更大，并抑制其他反馈较小的神经元，<strong>增强了模型的泛化能力</strong> (吴恩达老师说 后来被发现用处不大。。)</p>
<p>一般的“归一化” 是指将一个[L,R]区间内浮动的变量集 映射到[l,r]一个更小的区间变量集</p>
<p>具体的归一化有具体的转换公式 </p>
<img src="/.io//timg.gif" data-original="CNN_example6.png">

<h2 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h2><p>论文来源:[Simonyan &amp; Zisserman 2015. Very deep convolutional network for large-scale image recognition]</p>
<p>VGG-16模型图解 (same表示使用same pading)</p>
<img src="/.io//timg.gif" data-original="CNN_example7.png">

<h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><p>论文来源:[He et al. 2015.Deep residual net works for image recognition]</p>
<p>此处涉及到残差网络(Residual block)</p>
<p>普通方法: </p>
<p>$z^{[l+1]} = W^{[l+1]}a^{[l]}+b^{[l+1]}$   ,   $a^{[l+1]}=g(z^{[l+1]})$</p>
<p>$z^{[l+2]} = W^{[l+2]}a^{[l+1]}+b^{[l+2]}$ , $a^{[l+2]}=g(z^{[l+2]})$</p>
<p>残差网络方法:</p>
<p>$z^{[l+1]} = W^{[l+1]}a^{[l]}+b^{[l+1]}$   ,   $a^{[l+1]}=g(z^{[l+1]})$</p>
<p>$z^{[l+2]} = W^{[l+2]}a^{[l+1]}+b^{[l+2]}$ , $a^{[l+2]}=g(z^{[l+2]}+a^{[l]})$</p>
<img src="/.io//timg.gif" data-original="CNN_ResNet.png">

<p>这种设计可以避免梯度消失 ，当模型层数上升普通方法下 模型的精度下降</p>
<p>而采用了残差网络则可以避免这种现象发生。</p>
<p>下图中每两层组成一个残差网络 </p>
<p>在残差网络采用了same pading</p>
<p>L和L+2层拥有相同维度才能保证$z^{[l+2]}+a^{[l]}$能相加</p>
<p>否则可以引入$w_s$ 通过 $w_s × a^{[l]}$ 使得两者维度一至可以相加 </p>
<p>而$w_s$不需要初始化 它的值将会通过后天学习自动更新</p>
<img src="/.io//timg.gif" data-original="CNN_ResNet1.png">



<h2 id="Inception"><a href="#Inception" class="headerlink" title="Inception"></a>Inception</h2><p>论文来源: [Szegedy et al.,2014, Going Deeper with Convolutions]</p>
<p>在这之前先介绍一下 1×1卷积 </p>
<img src="/.io//timg.gif" data-original="CNN_inception.png">

<p>当遇到需要压缩样本的信道，即不改变长度与宽度的前提下减少深度 可以采用1×1卷积</p>
<p>如上图 将深度为192的样本变为32</p>
<p>可以用32个1×1×192的过滤器 进行卷积 </p>
<p>对于其中一个过滤器对应位相乘再求和 后用relu激活得到对应的值</p>
<p>这一步能将深度为192的样本压缩成1维</p>
<p>当存在32个过滤器时将32个1维结果叠加 则生成28×28×32的结果 </p>
<img src="/.io//timg.gif" data-original="CNN_inception1.png">

<p>1×1卷积核在inception的实现中能大大减少卷积池化过程的计算量(通过减少信道数) 但会损失一定信息</p>
<p>在googleNet的模型中采用以信道分组卷积再合并的方式</p>
<p>最后将几组的信道组合成一个整体作为下一层</p>
<img src="/.io//timg.gif" data-original="CNN_inception2.png">

<p>重复这样卷积处理搭建出一个googleNet的模型</p>
<p>其中有三个分支 用softmax预测出结果 以防止过度拟合出错</p>
<img src="/.io//timg.gif" data-original="CNN_googleNet.png">

<h1 id="计算机视觉中的三类问题"><a href="#计算机视觉中的三类问题" class="headerlink" title="计算机视觉中的三类问题"></a>计算机视觉中的三类问题</h1><blockquote>
<p>计算及视觉主要有两类问题</p>
<p>分类问题(classification):判断给出图片中的对象是A还是B</p>
<p>定位问题(localization):找出给出图片中所需要检索物体的位置</p>
<p>而Detection是针对多种不同物体的定位与判断</p>
</blockquote>
<h2 id="特征点提取"><a href="#特征点提取" class="headerlink" title="特征点提取"></a>特征点提取</h2><p>Detection的定位与判断需要依赖被识别物体的特征点坐标集合作为神经网络的输出单元</p>
<p>以人体姿态识别为例 Detection神经网络会输出 {是否存在人体躯干0/1,特征点坐标1(x,y), … , 特征点坐标n(x,y)}</p>
<img src="/.io//timg.gif" data-original="LandMark.png">

<h2 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h2><ul>
<li>滑动窗口检测</li>
</ul>
<p>滑动窗口检测的实现方法很简单，就是以固定的窗口大小与滑动步长,对图片中的区域逐个进行识别。</p>
<p>若当前窗口存在则这个区域的输出结果为1，否则为0。然后逐渐增大窗口再次遍历图片中的所有位置。</p>
<p>这个做法十分朴素，但是显然的缺点是计算量非常大。</p>
<p>若为了减少计算量采用较大的窗口与较大的步长则会导致目标定位不准确</p>
<img src="/.io//timg.gif" data-original="SlideWindow.png">

<ul>
<li>FCN(全卷积神经网络)实现滑动窗口</li>
</ul>
<p>实际操作时我们并不会对所有区域单独进行卷积-池化-全连接的神经网络估计</p>
<p>而是将整个图片作为一个整体输入。这里利用了卷积操作替代全连接操作的技巧</p>
<p>假设存在一个16×16的图片 用一个大小为14×14的窗口滑动，则存在4个区域需要进行单独识别。</p>
<p>利用卷积操作替代全连接操作则简化了这个步骤。</p>
<blockquote>
<p>论文参考:[Sermanet et al.,2014,OverFeat: Intergrated recongnition, localization and detection using convolutional network.]</p>
</blockquote>
<img src="/.io//timg.gif" data-original="SlideWindowImplementation.png">

<p>可以看到利用卷积代替全连接操作后图片信息压缩后各个区域的相对位置不变。</p>
<p>这个性质避免了滑动窗口重复计算的劣势。</p>
<p>此处Ng Andrew 没有详细描述最初的滑动窗口和最终”压缩”处理后得到的输出之间的关系。</p>
<p>28×28的原图经过 5×5卷积(步长1) —— 2×2池化(步长2) —— 5×5卷积(步长1)，</p>
<p>得到一个8×8的矩阵 那么每一个矩阵元素对应原来14×14窗口在原图上每间隔2个像素的一次采样。</p>
<p>这里有两个问题：</p>
<p>1.为了得到14×14窗口每间隔2个像素的一次采样最终结果必须经过 固定size的卷积池化操作吗？</p>
<p>2.最终得到的8×8的矩阵是否可以解释为其他大小的滑动窗口采样得到的结果？</p>
<p>如果利用卷积压缩公式:$n[i]= floor( (n[i-1]+2×padding - filtersize)/stride+1) $</p>
<p>发现原图经过5×5卷积(步长1) —— 2×2池化(步长2) —— 5×5卷积(步长1)，得到的矩阵大小$x$</p>
<p>与原图像大小28×28，滑动窗口大小14×14以2为步长直接卷积得到的最终矩阵大小$y$ 相同。</p>
<p>即$x=y=8$ 。</p>
<p>个人想法: 卷积和池化代替全连接操作图片信息压缩后各个区域的相对位置不变。</p>
<p>先确定好最终要将图片分成多少份区域进行识别,</p>
<p>只要调整卷积和池化的窗口大小和步长就能得到预想的最终矩阵。</p>
<p>比如100×100的原图变为3×3矩阵：</p>
<p>30×30卷积(步长2) 得到36×36矩阵 —— 3×3池化(步长3)得到12×12矩阵</p>
<p> —— 4×4 卷积(步长2) 得到3×3矩阵。</p>
<ul>
<li>Bounding Box预测</li>
</ul>
<p>滑动窗口卷积存在一个明显的问题,由于规定的检测区域是离散的分布在原图中的几个固定位置。</p>
<p>若被检测物体不能独立的存在于任何一个区域中内时，被检测物体的边界就不能被准确定位。</p>
<p>Bounding Box预测则是规定了几个参数来辅助确定被检测物体边界Bounding。</p>
<p>以YOLO算法为例。</p>
<img src="/.io//timg.gif" data-original="BoundingBox.png">

<p>对输出值标签增加$b_x b_y b_h b_w$ 分别表示物体中心坐标(x,y)以及物体的高度宽度。</p>
<p>$P_c$ 表示当前Bounding box中存在被检测物体的概率, $C_x$表示这个物体属于某个类的概率</p>
<p>这样预先将图片分割成3×3的区域然后利用FCN网络得到各个区域的Label输出值。</p>
<h2 id="预测框的选择"><a href="#预测框的选择" class="headerlink" title="预测框的选择"></a>预测框的选择</h2><p>当运行算法时,同一个目标可能被检测多次而产生多个预测框,</p>
<p>这时候就需要从预测狂中选择一个最优的预测框作为最终结果。</p>
<img src="/.io//timg.gif" data-original="NonMaxSuppression.png">

<ul>
<li><p>非极大值抑制 (Non-Max Suppression)</p>
<p>非极大值抑制就是只保留检测到同一个目标物体的概率最大的预测框。</p>
<p>具体的实现过程如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Discard all Boxes <span class="keyword">with</span> p_c &lt;= threshold value.</span><br><span class="line"><span class="keyword">While</span> there <span class="keyword">are</span> <span class="keyword">any</span> remaining boxes unmarked:</span><br><span class="line">	Pick the Box <span class="keyword">with</span> the largest p_c <span class="keyword">as</span> a <span class="keyword">prediction</span> Box_A</span><br><span class="line">	<span class="keyword">If</span> there <span class="keyword">is</span> <span class="keyword">any</span> remaining box <span class="keyword">with</span> IoU &gt;= threshold <span class="keyword">value</span> <span class="keyword">with</span> Box_A</span><br><span class="line">		Discard those box.</span><br><span class="line">	<span class="keyword">Else</span> Box_A <span class="keyword">is</span> the <span class="keyword">only</span> one remaining box <span class="keyword">of</span> this target.</span><br><span class="line">		Mark the Box_A <span class="keyword">to</span> avoid picked <span class="keyword">at</span> <span class="keyword">next</span> loop.</span><br></pre></td></tr></table></figure>

<p>如果存在多个不同分类(Class)的目标需要被检测,则需要对每种分类分别运行非极大值抑制操作。</p>
<p>上述伪代码中出现了参数IoU即交并比(Intersection over union)。</p>
<p>这是评估两个框的重叠程度的指标。</p>
</li>
<li><p>交并比(Intersection over union)</p>
<p>交并比对于两个预测框A与B而言 就是相交面积/合并面积。$IoU=A∩B/A∪B$    </p>
<img src="/.io//timg.gif" data-original="IoU.png">

<p>通过人为设定阈值,判断检测框之间的关系。</p>
<p>IoU &gt;= Threshold 则认为两个检测框捕获了同一个物体。需要根据极大值抑制保留概率大的Box</p>
<p>IoU &lt; Threshold 则认为两个检测框捕获了不同的物体。</p>
<p>实际运用中交并比也可以作为目标跟踪的依据。</p>
<p>通过计算相邻两帧图片中Box的IoU。</p>
<p>若大于某一阈值 则判定为同一个物体移动导致的位移, </p>
<p>则它们的ID或者识别码保持不变。</p>
</li>
</ul>
<h2 id="Anchor-Boxes锚定框"><a href="#Anchor-Boxes锚定框" class="headerlink" title="Anchor Boxes锚定框"></a>Anchor Boxes锚定框</h2><p>在实际使用中不同物体的中心点可能会落在同一个预先划分的Bounding Box中，</p>
<p>然而传统方法中一个格子(BoundingBox)只能检测到最多一个目标物体。</p>
<p>而锚定框可以很好的改善这种情况。</p>
<img src="/.io//timg.gif" data-original="AnchorBox.png">

<p>图中汽车的中心点和人的中心点同时出现在同一个Bounding Box中,</p>
<p>可以采用锚定框策略，预设一个AnchorBox1形状接近于一个站立的人(竖着的矩形)。</p>
<p>同样的，预设另一个AnchorBox2形状接近于车辆的侧面(横着的矩形)。</p>
<img src="/.io//timg.gif" data-original="AnchorBox_1.png">

<p>这时对应的标签y也需要更改，它需要包括两个对应AnchorBox的参数。</p>
<p>假如包裹检测目标的矩形框与预设的某个AnchorBox具有最大的IOU值。</p>
<p>那么这个检测目标将会被归类为对应标签的物体如:人/车。</p>
<ul>
<li>此处疑问：这里吴恩达所说的$p_c$似乎是包含有分类$c$的概念。</li>
</ul>
<img src="/.io//timg.gif" data-original="AnchorBox_2.png">

<p>若$p_c$包含有检测目标是否为对应目标的含义那为什么还需要$c_1,c_2,c_3$来进行分类。</p>
<p>我个人认为$p_c$的定义应该是检测区域内出现目标的概率，具体是什么物体由$c_x$判断。</p>
<p>AnchorBox能较好的解决两个对象中心出现在同一个BoundingBox的情况但是，</p>
<p>但是不能很好地解决3个及以上的物体出现在同一个boundingBox中的情况。</p>
<p>通常地，我们会采用预先分出更多个BoundingBox，</p>
<p>这样两个物体被同一个Box捕获的概率就会小很多。</p>
<p>持续缓慢更新ing。。。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Convolutional Neural Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法之监督学习</title>
    <url>/2022/08/20/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文围绕李航《统计学习方法》第一版无监督学习中的部分章节撰写学习笔记，</p>
<p>并将学习过程中个人遇到的问题与思考以及相应的解答进行记录总结。</p>
<p>阅读《统计学习方法》的初衷是给之后深度学习作为铺垫，</p>
<p>因此本文也将重点关注一些较为相关的基础理论算法内容。</p>
<p>具体包括原书以下章节:</p>
<p><strong>第1章，统计学习及监督学习概论</strong></p>
<p><strong>第2章，感知机</strong></p>
<p><strong>第4章，朴素贝叶斯法</strong></p>
<p><strong>第6章，逻辑斯蒂回归与最大熵模型</strong></p>
<p>未来可能会根据个人学习需求在陆续添加其他章节内容。</p>
<h1 id="统计学习及监督学习概论"><a href="#统计学习及监督学习概论" class="headerlink" title="统计学习及监督学习概论"></a>统计学习及监督学习概论</h1><blockquote>
<p>个人认为的本章重点:</p>
<p>1.统计学习三要素(1.3节)</p>
<p>2.模型评估与模型选择(1.4节)</p>
<p>3.正则化与交叉验证(1.5节)</p>
<p>4.生成模型与判别模型(1.7节)</p>
<p>5.分类问题，标注问题，回归问题(1.8节-1.10节)</p>
</blockquote>
<h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><blockquote>
<p>感知机是经典的线性二分类模型，是神经网络的基础。</p>
<p>输入为实例的特征向量$x\in X$ 输出为$y\in Y={+1,-1}$</p>
</blockquote>
<h1 id="朴素贝叶斯法"><a href="#朴素贝叶斯法" class="headerlink" title="朴素贝叶斯法"></a>朴素贝叶斯法</h1><blockquote>
<p>朴素贝叶斯法是经典的生成模型算法，是基于贝叶斯定理与特征条件独立假设的分类方法。</p>
<p>对于某一问题设计朴素贝叶斯法模型关键是得到朴素贝叶斯法的参数估计。</p>
</blockquote>
<h1 id="逻辑斯谛回归"><a href="#逻辑斯谛回归" class="headerlink" title="逻辑斯谛回归"></a>逻辑斯谛回归</h1><blockquote>
<p>逻辑斯谛回归模型与最大熵模型都属于对数线性模型。</p>
<p>逻辑斯蒂回归虽然有回归二字但其实并非用于线性回归问题。</p>
<p>最典型的逻辑斯蒂回归应用于输出值离散的二分类或多分类问题上。</p>
<p>相关引用: <a href="https://www.cnblogs.com/pinard/p/6029432.html" target="_blank" rel="noopener">刘建平Pinard-逻辑回归原理小结</a></p>
</blockquote>
<h2 id="从线性回归到逻辑回归"><a href="#从线性回归到逻辑回归" class="headerlink" title="从线性回归到逻辑回归"></a>从线性回归到逻辑回归</h2><p>线性回归的模型是求出输出值 $y$ 和输入向量$x$之间的线性关系 $y=wx+b$，或者将偏置$b$并入特征矩阵$w$，记作$\hat{w}=(w^{T},b)^{T}$，</p>
<p>同样也将输入向量加以扩充，加进常数 1，记作$\hat{x}=(x^{T},1)^{T}$，显然有$\hat{w}\hat{x}=wx+b$。</p>
<p>对于线性回归问题，输入输出被映射成一个线性函数的关系，因此对于输出值 $y$ 是连续的。</p>
<p>如果 $y$ 是离散值怎么办？一个想法是对 $y$ 在做一次函数转化，变为$g(y)$。</p>
<p>如果我们令 $g(y)$ 的值在某个实数区间的时候是类别A，在另一个实数区间的时候是类别B，</p>
<p>以此类推就得到了一个分类模型，这也是逻辑斯谛回归要做的。</p>
<h2 id="逻辑斯谛分布到逻辑回归模型"><a href="#逻辑斯谛分布到逻辑回归模型" class="headerlink" title="逻辑斯谛分布到逻辑回归模型"></a>逻辑斯谛分布到逻辑回归模型</h2><p>在引入逻辑斯谛回归之前首先介绍逻辑斯谛分布。</p>
<p>设 $X$ 是连续随机变量，$X$ 服从逻辑斯谛分布是指 $X$ 具有下列分布函数$F(x)$和密度函数$f(x)$:<br>$$<br>F(x)=P(X\leq x)= {1\over 1+e^{-(x-\mu)/\lambda} }\<br>f(x)=F’(X)= {e^{-(x-\mu)/\lambda}\over \lambda(1+e^{-(x-\mu)/\lambda})^2}<br>$$<br>这里顺便回顾一下分布函数与概率密度函数的含义。粗略的说概率密度函数$f(x)$就是$P(X=x)$的概率。</p>
<p>对于离散事件$x$而言， $F(m) = P(X\leq m) = \sum_{x = -\infty}^m P(X=x)$。</p>
<p>对于连续变量$x$而言，$F(m) = P(X\leq m) = \int_{x = -\infty}^m P(X=x)$。</p>
<p>而逻辑斯谛分布的密度函数与分布函数形如下图所示。</p>
<p><img src="/.io//timg.gif" data-original="LogisticDistribution.png"></p>
<p>密度函数图像(左图)反映了逻辑斯谛分布模型中随机事件 $x$ 符合以均值 $\mu $ 为对称轴的，类似正态分布的触发概率。</p>
<p>而分布函数图像(右图)就是经典的sigmoid函数的原型。</p>
<p>假如我们规定随机事件 $x$ 的概率分布以$F(x)&gt;0.5$ 和$F(x)&lt;0.5$分为两类来分别对应二分类中输出$y$ 的值，</p>
<p>那么就能够应对输出值是离散值的情况，并用于求解分类问题。</p>
<p>而这里分布函数$F$ 就是上文 <strong>从线性回归到逻辑回归</strong> 指代的函数 $g$ 的原型。<br>$$<br>g(z) = {1 \over 1+e^z}\<br>z = wx+b = \hat{w}\hat{x}\<br>\hat{w} = (w^{(1)},w^{(2)},\cdots, w^{(n)}, d)\<br>\hat{x} = (x^{(1)},x^{(2)},\cdots, x^{(n)}, 1)\<br>$$<br>(关于函数 $g$ 此处刘建平老师的博客和李航老师书中所记略有不同但本质一样)</p>
<p>函数 $g$ 有个非常好的性质: $g’(z)=g(z)(g(z)-1)$ </p>
<p>这让sigmoid函数在神经网络算法中反向传播更新计算更简便。</p>
<h3 id="二项逻辑斯谛回归模型"><a href="#二项逻辑斯谛回归模型" class="headerlink" title="二项逻辑斯谛回归模型"></a>二项逻辑斯谛回归模型</h3><p>具体的二项逻辑斯谛回归模型是如下的条件概率分布:<br>$$<br>P(Y=1|x)={e^{wx+b} \over 1 + e^{wx+b} }\<br>P(Y=0|x)= 1 - P(Y=1|x) = {1 \over 1 + e^{wx+b} }\<br>$$<br>而逻辑回归模型所需要学习的就是权值向量 $w$ 以及偏置 $b$，</p>
<p>刘建平老师的博客中将权值向量和偏置合并记作线性关系系数 $\theta$ (等同于此处的 $\hat{w}$)。</p>
<p>计算二元逻辑回归模型中事件$x$发生的对数几率: $log{P(Y=1|x) \over P(Y=0|x)} = wx+b$</p>
<p>这就是说，在逻辑斯谛回归模型中，输出 $Y=1$  的对数几率是输入 $x$ 的线性函数。</p>
<p>或者说，输出 $Y=1$ 的对数几率是由输入 $x$ 的线性函数表示的模型，即逻辑斯谛回归模型。</p>
<h3 id="多项逻辑斯谛回归模型"><a href="#多项逻辑斯谛回归模型" class="headerlink" title="多项逻辑斯谛回归模型"></a>多项逻辑斯谛回归模型</h3><p>二项逻辑回归可以推广到多项逻辑回归模型。假设输出离散值$Y = {1,2,\cdots,K }$，那么多项逻辑回归模型是:<br>$$<br>P(Y=k|x)={e^{\hat{w_k}x} \over 1 + \sum_{k=1}^{K-1} e^{\hat{w_k}x} }, \quad k = 1,2,\cdots, K-1\<br>P(Y=0|x)= 1 - P(Y=1|x) = {1 \over 1 + \sum_{k=1}^{K-1} e^{\hat{w_k}x} }\<br>$$<br>需要注意到$\hat{w_k}$ 是不同分类 $y$ 对应的一个向量参数。</p>
<h2 id="模型参数估计"><a href="#模型参数估计" class="headerlink" title="模型参数估计"></a>模型参数估计</h2><blockquote>
<p>相关参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/26614750" target="_blank" rel="noopener">一文搞懂极大似然估计</a></p>
<p><a href="https://blog.csdn.net/u011508640/article/details/72815981" target="_blank" rel="noopener">详解最大似然估计（MLE）最大后验概率估计（MAP）以及贝叶斯公式的理解</a></p>
</blockquote>
<p>现在已经知道了逻辑回归模型，即上述条件概率分布。</p>
<p>然而要使用逻辑回归模型去判断输入 $x$ 所对应的 $y$ 还需要求得模型中的参数$\hat{w}$ 。</p>
<p>为了求得参数$\hat{w}$ 需要用到极大似然估计的思想。</p>
<h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><p>通俗理解来说，<strong>就是利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值，</strong></p>
<p><strong>即：“模型和样本已定，参数未知”</strong>。</p>
<p><strong>极大似然估计中采样需满足一个重要的假设，就是所有的样本都是互相独立且服从同一概率分布规则的</strong>。</p>
<p>一个比较好的例子是硬币的质地是否均匀，即想知道抛这枚硬币，正面出现的概率 $\theta$ 是多少。</p>
<p>假设投掷硬币5次得到的训练数据集，即已知的样本结果信息 $T= {(x_1, 1),(x_2, 1),(x_3, 0),(x_4, 1),(x_5, 0)}$，其中$x_i$表示第i次投掷行为，输出为$y_i\in {0,1}$ ，0为反面，1为正面。</p>
<p>我们想求的正面概率 $\theta$ 是模型参数，而抛硬币模型我们可以假设是二项分布。</p>
<p>那么，出现实验结果 $T$ 的似然函数是 : $P(T|\theta) = \theta^3(1-\theta)^2 $，</p>
<p>当 $P(T|\theta)$ 最大时，此时的 $\theta$ 才是最有可能导致出现样本结果 $T$ 的参数。</p>
<p>找到函数 $P(T|\theta) = \theta^3(1-\theta)^2$  的最大值处的 $\theta$ :</p>
<p>$\theta_{best} = \underset{ {\theta} }{argmax}\ P(T|\theta)$ ，求得对应的 $\theta_{best} = 0.6$ 。</p>
<p>通常我们会对似然函数取对数从而将乘法改为 $log$ 项相加更方便讨论最大值。</p>
<p>如果从经验角度来说，根据这个样本结果$T$ 很容易计算出投掷正面的概率为$\theta = 0.6$，也符合极大似然估计结果。</p>
<h3 id="使用极大似然估计求二项逻辑回归中的参数-hat-w"><a href="#使用极大似然估计求二项逻辑回归中的参数-hat-w" class="headerlink" title="使用极大似然估计求二项逻辑回归中的参数$\hat{w}$"></a>使用极大似然估计求二项逻辑回归中的参数$\hat{w}$</h3><p>在逻辑斯蒂回归中，我们已经知道了概率分布模型是:<br>$$<br>P(Y=1|x)={e^{wx+b} \over 1 + e^{wx+b} }\<br>P(Y=0|x)= 1 - P(Y=1|x) = {1 \over 1 + e^{wx+b} }\<br>$$<br>我们需要求得的参数是$w$ 与 $b$ 或者说 $\hat{w}$，</p>
<p>假设训练数据集，即已知的样本结果信息 $T = {(x_1, y_1), (x_2, y_2),\cdots, (x_N, y_N)}$ 其中$x_i\in R^n, y_i \in {0,1}$</p>
<p>由于二项逻辑回归模型的输出$y\in{1,0}$ 符合二项分布。</p>
<p>那么对应的似然函数为:<br>$$<br>\prod_{i=1}^N[P(Y=1|x_i)]^{y_i}[1-P(Y=1|x_i)]^{1-y_i}<br>$$<br>当样本 $y_i$ 输出为0，那么第 $i$ 个连乘项为 $P(Y=0|x_i)$，</p>
<p>当样本 $y_i$ 输出为1，那么第 $i$ 个连乘项为 $P(Y=1|x_i)$，</p>
<p>对似然函数取对数，并将结果化简得到二项逻辑回归的关于参数 $\hat{w}$ 的损失函数 $L(\hat{w})$:<br>$$<br>L(\hat{w}) = \sum_{i=1}^N[y_i(\hat{w}x_i)-log(1+e^{\hat{w}x_i})]\<br>\hat{w}<em>{best} = \underset{ {\hat{w} } }{argmax}\ L(\hat{w})<br>$$<br>可以使用梯度下降法或者拟牛顿法进行迭代更新计算得到$\hat{w}</em>{best}$。</p>
<h1 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h1><blockquote>
<p>最大熵是概率模型学习的一个准则，最大熵原理认为，学习概率模型时，</p>
<p>在所有可能的概率模型（分布）中，熵最大的模型是最好的模型。</p>
<p>相关参考:</p>
<p><a href="https://www.cnblogs.com/pinard/p/6093948.html" target="_blank" rel="noopener">最大熵模型原理小结 - 刘建平Pinard</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/83765331" target="_blank" rel="noopener">李航《统计学习方法》最大熵模型p(y|x)推导的正确过程</a></p>
</blockquote>
<h2 id="信息熵与条件熵"><a href="#信息熵与条件熵" class="headerlink" title="信息熵与条件熵"></a>信息熵与条件熵</h2><blockquote>
<p>相关参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/26486223" target="_blank" rel="noopener">通俗理解信息熵</a></p>
</blockquote>
<p>在学习最大熵模型之前，先要了解信息学中信息熵的概念。</p>
<p>熵：表示随机变量的不确定性。</p>
<p>假设 $P(X=x_i)$ 代表随机事件 $X$ 为 $x_i$ 的概率，则其熵为:<br>$$<br>H(X) = -\sum_{i=1}^n P(X=x_i)logP(X=x_i)<br>$$<br>在李航的书中此处的 $log$ 以 $e$ 为底数。</p>
<p>公式中的 $log\ P(X=x_i)$ 用来衡量随机事件 $X$ 为 $x_i$ 时的信息量。</p>
<p>那么信息熵公式就可以被理解成随机事件 $X$ 所含信息量的期望，即: 各项概率 × 对应信息量的总和。</p>
<p>根据熵的定义，我们可以推广到两个变量 $X,Y$ 的联合熵:<br>$$<br>H(X,Y) = -\sum_{x_i\in X}\sum_{y_j \in Y} P(X=x_i,Y=y_j)logP(X=x_i,Y=y_j)<br>$$<br>在本节中我们需要使用条件熵来帮助进行推导最大熵模型。</p>
<p>条件熵是指在一个条件下，随机变量的不确定性:<br>$$<br>\begin{aligned}<br>H(Y|X=x_j) &amp;= \sum_{y_i \in Y} P(Y=y_i|X=x_j)logP(Y=y_i|X=x_i)\<br>H(Y|X) &amp;= \sum_{x_j\in X}P(X=x_j)H(Y|X=x_j)\<br>&amp;= -\sum_{x_i\in X}\sum_{y_j \in Y}P(Y=y_i,X=x_j)logP(Y=y_i|X=x_j)<br>\end{aligned}<br>$$</p>
<h2 id="最大熵原理以及最大熵模型"><a href="#最大熵原理以及最大熵模型" class="headerlink" title="最大熵原理以及最大熵模型"></a>最大熵原理以及最大熵模型</h2><p>最大熵原理认为要选择的概率模型首先必须满足已有的事实，即约束条件。</p>
<p>在没有更多信息的情况下，那些不确定的部分都是“等可能的”。最大熵原理通过熵的最大化来表示等可能性。</p>
<p>用一个例子解释一下这段话。</p>
<p>假设随机变量$X$ 有4个取值 ${A,B,C,D}$ ，取各个值的概率为$P(A),\cdots,P(D)$。</p>
<p>这些概率值满足以下约束条件: $P(A)+\cdots+P(D) = 1$</p>
<p>满足这个约束条件的概率分布有无穷多个。如果没有任何其他信息，仍要对概率分布进行估计，</p>
<p>一个办法就是认为这个分布中取各个值的概率是相等的，因为此时$H(X)$最大，符合最大熵准则。</p>
<p>即: 熵最大的模型是最好的模型。</p>
<p>根据最大熵原理得到最大熵模型定义。</p>
<p><strong>下面需要先定义一系列函数</strong></p>
<p>给定一个数据集 $T = {(x_1, y_1), (x_2, y_2),\cdots, (x_N, y_N)}$</p>
<p>定义联合分布$P(X=x,Y=y)$ 的经验分布为 $\tilde{P}(X=x,Y=y)$</p>
<p>定义边缘分布$P(X=x)$ 的经验分布为 $\tilde{P}(X=x)$<br>$$<br>\tilde{P}(X=x,Y=y) = {v(X=x,Y=y)\over N}\<br>\tilde{P}(X=x) = {v(X=x)\over N}\<br>$$<br>其中 $v(X=x,Y=y)$ 表示样本中出现 $(x,y)$ 的频数，$v(X=x)$ 表示训练数据中输入 $x$ 出现的频数。</p>
<p>定义特征函数 $f(x,y)$ 描述输入 $x$ 和输出 $y$ 是否存在联系。</p>
<p>可以认为只要出现在训练集中出现 $(x_i,y_j)$， 其$f(x_i,y_j)=1$， 否则 $f(x_i,y_j)=0$</p>
<p>特征函数$f(x,y)$ 关于经验分布$\tilde{P}(X,Y)$ 的期望，用$E_{\tilde{P} }(f)$ 表示:<br>$$<br>E_{\tilde{P} }(f) = \sum_{x_i\in X}\sum_{y_j\in Y}\tilde{P}(X=x_i,Y=y_j)f(x_i,y_j)<br>$$<br>特征函数$f(x,y)$ 关于<strong>模型$P(Y|X)$ </strong>与经验分布$\tilde{P}(X)$的期望，用$E_{P}(f)$ 表示:<br>$$<br>E_{P}(f) = \sum_{x_i\in X}\sum_{y_j\in Y}\tilde{P}(X=x_i)P(Y=y_j|X=x_i)f(x_i,y_j)<br>$$<br>如果模型能够获取训练数据中的信息，那么就可以假设这两个期望值相等，即$E_{\tilde{P} }(f) = E_{P}(f)$。</p>
<p>这个等式将作为模型学习的约束条件，假设存在n个特征函数$f_i(x,y),i=1,\cdots,n$ 那么就有n个约束条件。</p>
<p><strong>最后根据以上公式给出最大熵模型</strong></p>
<p>假设我们需要获得的最优模型是$P(Y|X)$ 简记为 $P$ ，也就是最终通过学习得到的结果。</p>
<p>定义在条件概率分布$P(Y|X)$ 上的条件熵$H(P)$为<br>$$<br>H(P) =  -\sum_{x_i\in X}\sum_{y_j \in Y}\tilde{P}(X=x_i)P(Y=y_j|X=x_i)logP(Y=y_j|X=x_i)<br>$$<br>假设最大熵模型符合约束条件集合 $C$ ，那么最大熵模型的定义为:<br>$$<br>C={P| E_{\tilde{P} }(f_i) = E_{P}(f_i), i= 1,2,\cdots,n}\<br>P_{best} = \underset{P}{argmax} = H(P)<br>$$</p>
<h2 id="最大熵模型的学习"><a href="#最大熵模型的学习" class="headerlink" title="最大熵模型的学习"></a>最大熵模型的学习</h2><p>最大熵模型的学习过程就是求解符合最大熵模型的$P(Y|X)$的过程，</p>
<p>由于不容易直接根据最大熵模型的定义求解，需要将问题通过拉格朗日函数转化为约束最优问题。</p>
<p>因此在展开讲解最大熵模型的学习之前需要先介绍一下拉格朗日函数以及拉格朗日对偶性。</p>
<h3 id="拉格朗日函数与拉格朗日对偶性"><a href="#拉格朗日函数与拉格朗日对偶性" class="headerlink" title="拉格朗日函数与拉格朗日对偶性"></a>拉格朗日函数与拉格朗日对偶性</h3><blockquote>
<p>相关参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/99945521" target="_blank" rel="noopener">10幅图帮助理解拉格朗日乘数法的原理</a></p>
<p><a href="https://blog.csdn.net/frostime/article/details/90291392" target="_blank" rel="noopener">从0到完全理解拉格朗日函数的对偶函数</a></p>
<p><a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">“拉格朗日对偶问题”如何直观理解？“KKT条件” “Slater条件” “凸优化”打包理解</a></p>
</blockquote>
<p><strong>首先拉格朗日函数能做什么?</strong></p>
<p>拉格朗日函数能够将约束最优化问题变为无约束优化问题并进行求解。</p>
<p><strong>拉格朗日函数如何求解约束最优化问题?</strong></p>
<p>假设$f(x),c_i(x),h_j(x)$ 是定义在$R^n$ 上的连续可微函数，考虑约束最优化问题:<br>$$<br>\begin{aligned}<br>\underset{x\in R^n}{min}\quad &amp; f(x)\<br>s.t \quad &amp; c_i(x) \leq 0, i=1,2,\cdots,k\<br>&amp; h_j(x) = 0, j=1,2,\cdots,l<br>\end{aligned}<br>$$<br>存在 $k$ 个不等式约束条件 $c_i(x)$ ，以及 $l$ 个约束条件$h_j(x)$。</p>
<p>引入拉格朗日函数将上述问题等价表述为:<br>$$<br>L(x,\alpha,\beta) = f(x) + \sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x), \quad \alpha_i\geq 0 \<br>set\quad A(x)= \underset{\alpha,\beta;\alpha_i\geq 0}{max} L(x,\alpha,\beta)\<br>p^{<em>} = \underset{x}{min} A(x)<br>$$<br>其中的乘子 $a$ 与 $\beta$ 是未定参数向量需要被求解。我们将上述两种表示称为原始问题的最优解 $p^{</em>}$。</p>
<p>通常我们会将原始问题转化为对偶问题求解，对偶问题就是<strong>实质相同但从不同角度观察的一对问题</strong>。</p>
<p>设对偶问题为$d^{<em>}$，对偶函数为 $I(\alpha,\beta)$ 那么有:<br>$$<br>set\quad I(\alpha,\beta) =\underset{x}{min} L(x,\alpha,\beta) \quad x\in R^n \<br>d^{</em>} = \underset{\alpha,\beta}{max} I(\alpha,\beta),\ s.t. \ \alpha_i\geq 0<br>$$<br>其中$a_i\geq 0$ 是对偶问题的约束条件，对于对偶问题中在求 $\underset{x}{min} L(x,\alpha,\beta)$ 时，</p>
<p>$x$ 不受约束条件$c_i(x)$ 与 $h_j(x)$ 影响，因此$x \in R^n$。</p>
<p>我们可以证明 $d^{<em>} \leq p^{</em>}$ ，证明如下:<br>$$<br>\begin{aligned}<br>&amp;\underset{\alpha,\beta;\alpha_i\geq 0}{max} L(x,\alpha,\beta) \geq L(x,\alpha,\beta) \geq \underset{x}{min} L(x,\alpha,\beta)\<br>&amp;set\quad A(x)= \underset{\alpha,\beta;\alpha_i\geq 0}{max} L(x,\alpha,\beta), \quad I(\alpha,\beta) =\underset{x}{min} L(x,\alpha,\beta)\<br>&amp;\because \quad A(x) \geq I(\alpha,\beta)\<br>&amp;\therefore \quad  \underset{x}{min} A(x) \geq \underset{\alpha,\beta;\alpha_i\geq 0}{max}I(\alpha,\beta)\<br>&amp;\therefore \quad p^{<em>} \geq d^{</em>}<br>\end{aligned}<br>$$<br>更形象的图解证明可以参考<a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">视频</a> 28分钟左右。</p>
<p>满足 $d^{<em>} \leq p^{</em>}$ 关系的对偶性称为弱对偶性，通过弱对偶性，我们可以给出原始问题 $p^{*}$ 的范围。</p>
<p>当原始问题 $p^{<em>}$ 是<strong>凸优化问题且满足Slater条件</strong>时，有 $d^{</em>} = p^{*}$ ，即原始问题的最优解。 </p>
<p>(但是一般情况是凸优化问题就有$d^{<em>}=p^{</em>}$，上述凸优化问题且满足Slater条件是充分条件)</p>
<p><strong>什么是凸优化问题?</strong></p>
<p>当 $f(x),c_i(x)$ 是凸函数，$h_j(x)$ 是仿射函数时，原问题 $p^{*}$ 是一个凸优化问题。</p>
<p><strong>凸函数定义:</strong> ${f(x_1)+f(x_2) \over2} \geq f({x_1+x_2 \over 2})$ 且 定义域为凸集。$f(x)=x^2$ 就是一个典型的凸函数。</p>
<p>凸集的定义如下，假设集合 $C$ 是一个定义在 $n$ 维的定义域。</p>
<p><img src="/.io//timg.gif" data-original="ConvexSet.png"></p>
<p>那么右侧橙色所表示的集合 $C$ 是凸集，而左侧蓝色所表示的集合不是凸集。</p>
<p>关于求最大熵问题一般都是凸优化问题，下面给出一个简单的例子感受一下。<br>$$<br>p^{<em>}=\underset{P}{max} \ H(P) = -\sum_x P(x)logP(x)\<br>p^{</em>}=\underset{P}{min} \ -H(P) = \sum_x P(x)logP(x)\<br>s.t. \ E_p(f_i) = E_{\tilde{P} }(f_i), \ i=1,\cdots,n\<br>\sum_{x}P(x)=\sum_{x}\tilde{P}(x)=1<br>$$<br>假设随机变量$X={x_1,x_2}$  那么有 $- H(P) = P(x_1)logP(x_1) + (1-P(x_1))log(1-P(x_1))$ 函数图像:</p>
<p><img src="/.io//timg.gif" data-original="HP.png"></p>
<p>从函数图像可以看出关于熵的函数$-H(P)$ 是一个凸函数。</p>
<p>同时关于最大熵模型的约束条件(仅有等式约束)，符合仿射函数条件。</p>
<p>所以求最大熵问题一般情况下符合凸优化问题定义。</p>
<p><strong>什么是仿射函数?</strong></p>
<p>仿射函数指符合 $c = Wx+b$ 且 $ x,w\in R^n$ 关系的函数， 当$x,w$是一维时，它就是典型的线性函数。</p>
<p>而它的解集 $C={x|c=Wx+b}$  是仿射集。</p>
<p><strong>什么是Slater条件?</strong></p>
<p>Slater条件定义如下:</p>
<p>存在一个点$x \in relint \ D$ ($relint \ D$ 表示非边界定义域)，</p>
<p>使得 $c_i(x) &lt; 0, \ i=1,2,\cdots,k$ 且 $Wx = b $ ，即 $x$ 属于$h_j(x)$的解集。</p>
<p><strong>为何选择求解对偶问题 $b^{<em>}$ 而不是直接求解 $p^{</em>}$ ?</strong></p>
<p>原始问题求解比较困难，主要是因为原始问题中 $f(x)$ 或 $A(x)$ 凹凸性不明确。</p>
<p>而对偶问题中 $I(\alpha,\beta)$ ，一定是一个凹函数 (与凸函数相反)，即一定存在最大值。</p>
<p>关于$I(\alpha,\beta)$ 是凹函数的证明可以看<a href="https://blog.csdn.net/frostime/article/details/90291392" target="_blank" rel="noopener">此博客</a></p>
<h3 id="原始问题与对偶问题的求解"><a href="#原始问题与对偶问题的求解" class="headerlink" title="原始问题与对偶问题的求解"></a>原始问题与对偶问题的求解</h3><p>前文简单介绍了使用对偶问题求解拉格朗日函数表示的约束最优化问题。</p>
<p>但是无论是原始问题 $p^{<em>}$ 还是对偶问题 $d^{</em>}$ 它们要求极小极大值或极大极小值，这在理解时非常抽象。</p>
<p><a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">视频</a> 28分钟左右，证明了$p^{<em>}\geq d^{</em>}$ 的同时也展示了如何直接求解原始问题和对偶问题:</p>
<p>设有原始问题$p^{<em>}$:<br>$$<br>\begin{aligned}<br>\underset{x\in R^n}{min}\quad &amp; f(x)\<br>s.t \quad &amp; c_i(x) \leq 0, i=1,2,\cdots,k\<br>&amp; h_j(x) = 0, j=1,2,\cdots,l\\<br>L(x,\alpha,\beta) &amp;= f(x) + \sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)<br>\end{aligned}<br>$$<br>其对偶问题$d^{</em>}$为:<br>$$<br>d^{*} = \underset{\alpha,\beta}{max} \ \underset{x}{min} L(x,\alpha,\beta)\<br>s.t. \alpha_i \geq 0<br>$$<br>由于$h_j(x)=0$ 它对$L(x,\alpha,\beta)$的大小没有贡献，在讨论拉格朗日函数 $L$ 的具体值时可以省略。</p>
<p>但是我们仍然需要在拉格朗日函数中加入 $h_j(x)$ 因为它的导数对求解问题有意义。</p>
<p>同时我们可以令$f(x) = t$，$\sum_{i=1}^k\alpha_ic_i(x) = \lambda^T u$ 。</p>
<p>那么拉格朗日函数的形式被简化成:<br>$$<br>L(x,\alpha,\beta) = L(t,u)= t + \lambda^T u<br>$$<br>其中 $t$ 是标量，$u$是一个向量，其维度大小等于约束条件 $c_i(x)$ 的个数$i$。</p>
<p>为了简化问题我们可以将拉格朗日函数看成关于变量 $t$ 和 $u$ 的函数 $L$ 。</p>
<p>同时简化后的原始问题和对偶问题为:<br>$$<br>p^{<em>} = \underset{x}{min}{t|(t,u)\in G_1, u\leq0 }\<br>d^{</em>} = \underset{\lambda}{max} \ \underset{x}{min} {t + \lambda^T u|(t,u)\in G_2,\lambda \geq 0}\<br>$$<br>其中 $G_1$ 表示原始问题的可行域，$G_2$ 表示对偶问题的可行域，且 $G_1 \in G_2$，</p>
<p>因为对偶问题中 $x$ 不受约束条件影响因此 $G_1$ 是 $G_2$ 的子集。</p>
<p><img src="/.io//timg.gif" data-original="p_d_problem.png"></p>
<p>那么对于原始问题就是在可行域 $G_1$ 处找到一个点$(t,u)$ 使得 $t$ 最小。</p>
<p>而对于对偶问题:</p>
<p>第一步</p>
<p>假定斜率 $\lambda$ 已知，在$G_2$ 内找到一个点 $(t,u)$ ，即调整 $x$ 使得函数 $L(t,u)$  过该点，且它的截距最小。</p>
<p>这里可能不太好理解为什么找截距$c$ ，即 $c = \underset{x}{min} L(t,u)$ 。</p>
<p>假设找到的函数$L(t,u)$ 过点 $(t^{<em>}, u^{</em>})\in G_2$ 且斜率 $\lambda$ 已知，那么截距 $c = t^{<em>}+\lambda^Tu^{</em>}$ 。</p>
<p>因为一旦确定了 $(t^{<em>}, u^{</em>})$ ，那么二元函数$L(t,u)$ 就退化成了一元函数 $c -\lambda^Tu= t$。</p>
<p>而对于一元函数带入直线上任意一点都等于同一个值 $c$ 。</p>
<p>第二步</p>
<p>调整 $\lambda$ ，重复第一步，每个斜率各自对应一条直线，找出这些直线中截距最大的那一条。</p>
<p>那么最终的截距$c$ 就是我们要求的对偶问题的解，即$d^{*} = \underset{\lambda}{max} \ \underset{x}{min} {t + \lambda^T u|(t,u)\in G_2,\lambda \geq 0}$。</p>
<p><strong>KKT条件</strong></p>
<p>由于直接求解对偶问题中的极大极小值问题比较抽象，</p>
<p>我们通常会使用 $KKT$ 条件中梯度为0的条件求解拉格朗日函数中的参数$\alpha,\beta$ 以及变量 $x$ , </p>
<p>可以说只要满足强对偶关系，那么可以使用$KKT$条件求解最优值。</p>
<p>对于凸优化原始问题 $p^{*}$<br>$$<br>\begin{aligned}<br>\underset{x\in R^n}{min}\quad &amp; f(x)\<br>s.t \quad &amp; c_i(x) \leq 0, i=1,2,\cdots,k\<br>&amp; h_j(x) = 0, j=1,2,\cdots,l\<br>L(x,\alpha,\beta) =&amp; f(x) + \sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)<br>\end{aligned}<br>$$<br>其对应的$KKT$ 条件表述如下 :<br>$$<br>c_i(x) \leq 0\<br>h_i(x) = 0\\</p>
<p>\nabla_xL(x,\alpha,\beta) = 0\<br>\nabla_{\alpha}L(x,\alpha,\beta) = 0\<br>\nabla_{\beta}L(x,\alpha,\beta) = 0\<br>a_i \geq 0\\<br>\alpha_ic_i(x) = 0<br>$$<br>$KKT$ 条件的前两条对应原问题中的约束条件。</p>
<p>中间梯度为0以及$a_i\geq 0$ 是对偶问题的约束条件。</p>
<p>统计学习方法附录中有$\nabla_{\alpha}L(x,\alpha,\beta) = 0$ ，$\nabla_{\beta}L(x,\alpha,\beta) = 0$，将这种KKT条件作为强对偶性的充分必要条件。</p>
<p>而其他资料中只有前一条$\nabla_xL(x,\alpha,\beta) = 0$，将这种KKT条件作为强对偶性的必要条件。</p>
<p>最后一个条件被称为互补松弛条件。</p>
<p>在最大熵模型的学习问题中只有等式约束条件，因此不用太关注互补松弛条件。</p>
<p>关于互补松弛条件的含义具体可以查看<a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">视频</a> 40分左右的讲解。</p>
<p>可以参考统计学习方法书中的例6.2来感受一下如何使用对偶性以及$KKT$条件求解最大熵模型:</p>
<p>已知随机事件$X = {A,B,C,D,E}$ 各自发生的概率$P(y_i), \ i = 1,\cdots,5$。</p>
<p>要求解随机事件$X$ 的最大熵模型$P(y_i),\ i=1,\cdots, 5$</p>
<p>对于随机事件$X$ 有约束条件: </p>
<p>$P(y_1) + P(y_2) = \tilde{P}(y_1) + \tilde{P}(y_2)= 3/10$，且 $\sum_i P(y_i) = \sum_i \tilde{P}(y_i) = 1$。</p>
<p>则原始问题 $p^{<em>}$ 表示为:<br>$$<br>\begin{aligned}<br>&amp;min \ -H(P)=\sum_{i=1}^5P(y_i)logP(y_i)\<br>&amp;s.t \  P(y_1) + P(y_2) = \tilde{P}(y_1) + \tilde{P}(y_2)= 3/10\<br>&amp;\quad \quad \sum_i P(y_i) = \sum_i \tilde{P}(y_i) = 1<br>\end{aligned}<br>$$<br>设拉格朗日函数 $L(P,w)$ , 其中 $w$ 是前面介绍拉格朗日函数里等式约束中的参数向量 $\alpha$。<br>$$<br>L(P,w) = -H(P) + w_1(P_(y_1)+P(y_2)-3/10) + w_0(\sum_{i=1}^5P(y_i)-1)\<br>p^{</em>} = \underset{x}{min} \ \underset{w}{max} L(x,w)\<br>d^{*} = \underset{w}{max} \ \underset{x}{min} L(x,w)<br>$$<br>$P$ 则指代最大熵模型中的$P(y_i)$，</p>
<p>将 $w$ 作为参数求解 ${\partial L \over \partial P(y_i)} = 0$， 此时偏导的零点为原函数的最小值点，</p>
<p>得到用参数$w = {w_0,w_1}$ 表示的 $P_w(y_i)$。</p>
<p>再使用 $P_w(y_i)$ 表示 $L(P_w,w)$ 。</p>
<p>最后求解 ${\partial L \over \partial w_i} = 0$， 此时偏导的零点为原函数的最大值点，</p>
<p>得到参数 $w$ 的解，将 $w$ 带入 $P_w(y_i)$ 得到随机事件 $X$ 的最大熵模型。</p>
<p>在这个例题中拉格朗日对偶性告诉我们:</p>
<p>由于原问题$min \ -H(P)$ 是一个凸优化问题，</p>
<p>先将 $w$ 作为参数 $P(y_i)$ 作为变量求解问题($d^{*}$)，</p>
<p>和先将 $P(y_i)$ 作为参数 $w$ 作为变量求解问题( $p^{*}$)。</p>
<p>最终的解是一样的($d^{<em>} = p^{</em>}$)。</p>
<p>上述例题在求解对偶问题时可以看到使用了求偏导找零点求最值的过程，</p>
<p>这其实就是在使用 $KKT$ 条件求解强对偶关系问题中最优值的方法。</p>
<p><strong>KKT条件为什么能求出对偶问题最优解?</strong></p>
<p>KKT条件中的梯度为0的条件其实引出了如何构造出拉格朗日函数的问题。</p>
<p>下面以 <a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">视频</a> 中的例子结合 <a href="https://zhuanlan.zhihu.com/p/99945521" target="_blank" rel="noopener">知乎</a> 的推导进行讲解。</p>
<p>设有原始问题如下，其中$x=(x_1,x_2)$ 是一个二维向量，讨论仅含有一个等式约束 $h(x)$ 的情况。<br>$$<br>\begin{aligned}<br>\underset{x\in R^n}{min}\quad &amp; f(x) = x_1^2+x_2^2\<br>s.t \quad &amp; h(x) = 0\<br>\end{aligned}<br>$$<br>下图中蓝色同心圆为 $f(x)$ 的等高线，其梯度$\nabla_x f(x)$为圆上向外的法线，即蓝色箭头。</p>
<p>黄色曲线为等式约束 $h(x)$，其梯度 $\nabla_x h(x)$  为黄色曲线上的法线，即黄色箭头。</p>
<p><img src="/.io//timg.gif" data-original="explain_kkt.png" height="500" width="600/"></p>
<p>假设已有点$x=(x_1,x_2)$ ，我们想找到符合约束条件 $h(x)$ 的点$x^<em>=(x_1^</em>,x_2^*)$ 使得 $f(x)$ 最小。</p>
<p>设 $x^*-x = \delta x$ 那么 $\delta x$ 要满足: $f(x+\delta x) &lt; f(x)$ 且 $h(x+\delta x) = 0$ 。</p>
<p>我们知道从 $x$ 到 $x^*$ ， $\delta x$ 必须在约束条件 $h(x)$ 上移动，即只能沿着与 $\nabla_x h(x)$ 垂直的方向移动，</p>
<p>所以有等式 $\delta x\nabla_x h(x) = 0$ 。</p>
<p>同时从上图中可以看到在 $\nabla f(x) = \beta \nabla h(x)$ 时能取到符合约束条件的极值点$x^*$。<br>$$<br>\because \nabla_x f(x) = \beta \nabla_x h(x),\ \delta x\nabla_x h(x) = 0\<br>\therefore \delta x \nabla_x f(x) = \delta x \beta \nabla_x h(x) = 0\<br>\therefore \nabla_x L(x,\beta) = \nabla_x f(x) + \beta \nabla_x h(x) = 0\<br>\therefore L(x,\beta) = f(x) + \beta h(x)<br>$$<br>由于在求解最大熵模型中没有涉及到不等式约束，</p>
<p>这里不再展示不等式约束情况下推导拉格朗日函数的具体细节。可以查看<a href="https://www.bilibili.com/video/BV1HP4y1Y79e" target="_blank" rel="noopener">视频</a> 6min30s 左右的讲解。</p>
<h3 id="推导最大熵模型的学习过程"><a href="#推导最大熵模型的学习过程" class="headerlink" title="推导最大熵模型的学习过程"></a>推导最大熵模型的学习过程</h3><blockquote>
<p>相关参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/83765331" target="_blank" rel="noopener">李航《统计学习方法》最大熵模型p(y|x)推导的正确过程</a></p>
</blockquote>
<p>前文已经介绍了最大熵模型的定义，现在结合拉格朗日函数以及对偶性求解最大熵模型。</p>
<p>首先写出原始问题以及其约束条件。</p>
<p>统计学习此处给出的约束条件与其推导过程存在问题，此处推导过程主要参考上方参考链接处的方式。<br>$$<br>\begin{aligned}<br>min  \ -H(P) &amp;=  \sum_{x\in X,y \in Y}\tilde{P}(x)P(y|x)logP(y|x)\<br>s.t. &amp;\quad 1 - \sum_{x\in X,y\in Y}P(y|x)\tilde{P}(x) = 0\<br>&amp;\quad E_p(f_i) - E_{\tilde{P} }(f_i) = 0, \ i=1,\cdots,n\\</p>
<p>E_{\tilde{P} }(f) &amp;= \sum_{x\in X,y\in Y}\tilde{P}(x,y)f(x,y)\<br>E_{P}(f) &amp;= \sum_{x\in X,y\in Y}\tilde{P}(x)P(x|y)f(x,y)<br>\end{aligned}<br>$$<br>此处将$P(X=x_i)$ 简写为 $P(x)$ ，将$P(Y=y_j)$ 简写为 $P(y)$，将 $P(Y=y_j|X=x_i)$ 简写为$P(y|x)$，</p>
<p>将$P(X=x_i, Y=y_j)$ 简写为 $P(x,y)$。</p>
<p>最大熵模型中共有n个特征函数$f_i(x,y)$ ，其中变量$P$ 指代最大熵模型$P(y|x)$。</p>
<p>将上述原始问题用拉格朗日函数改写为等价问题。<br>$$<br>\begin{aligned}<br>L(P,w) =&amp; -H(P) + w_0[1 - \sum_{x\in X,y\in Y}P(y|x)\tilde{P}(x)]+\sum_{i=1}^nw_i(E_p(f_i) - E_{\tilde{P} }(f_i))\</p>
<p>L(P,w) =&amp; \sum_{x\in X,y \in Y}\tilde{P}(x)P(y|x)logP(y|x) + w_0[1 - \sum_{x\in X,y\in Y}P(y|x)\tilde{P}(x)]\<br>&amp; +\sum_{i=1}^nw_i[\sum_{x\in X,y\in Y}\tilde{P}(x,y)f(x,y) - \sum_{x\in X,y\in Y}\tilde{P}(x)P(x|y)f(x,y)]\\<br>p^<em> =&amp; \underset{P\in C}{min} \ \underset{w}{max} L(P,w)\<br>d^</em> =&amp; \underset{w}{max}\ \underset{P\in C}{min} L(P,w)\<br>\end{aligned}<br>$$<br>最大熵模型的学习最终就是要求出给定训练集$T$ 对应的$P(Y=y_i|X=x_i)$ ，即 $L(P,w)$ 中的 $P$。</p>
<p>根据 $KKT$ 条件，我们需要先求出$\nabla_P L(P,w) = 0$ 时 $P$ 关于参数 $w$ 的表达式。</p>
<p>对每个 $x_i$ 和 $y_j$ 的条件概率 $P(Y=y_i|X=x_i)$ 求 $L(P,w)$ 的偏导，(下文为了简洁用$P(y|x)$表示)。<br>$$<br>\begin{aligned}<br>{\partial L(P,w) \over \partial P(y|x)} =&amp; \tilde{P}(x)[logP(y|x)+1] - \tilde{P}(x)w_0 + \tilde{P}(x)\sum_{i=1}^n w_i f_i(x,y)\<br>=&amp;\tilde{P}(x)[logP(y|x) + 1 - w_0 - \sum_{i=1}^n w_i f_i(x,y) ]\<br>\because &amp;\quad \tilde{P}(x) \not= 0 \quad and \quad  {\partial L(P,w) \over \partial P(y|x)}=0\<br>\therefore &amp;\quad logP(y|x) + 1 - w_0 - \sum_{i=1}^n w_i f_i(x,y) = 0\<br>\therefore &amp;\quad P_w(y|x) = {exp(\sum_{i=1}^nw_if_i(x,y))\over exp(1-w_0)}\<br>\because &amp;\quad \sum_{y\in Y}P(y|x) = 1\<br>\therefore &amp;\quad \sum_{y\in Y}P(y|x) = {\sum_{y\in Y}exp(\sum_{i=1}^nw_if_i(x,y))\over exp(1-w_0) } = 1\<br>\therefore &amp;\quad Z_w(x) = exp(1-w_0) = \sum_{y\in Y}exp(\sum_{i=1}^nw_if_i(x,y))\<br>\therefore &amp;\quad P_w(y|x) = {exp(\sum_{i=1}^nw_if_i(x,y))\over Z_w(x)} = {exp(\sum_{i=1}^nw_if_i(x,y))\over \sum_{y\in Y}exp(\sum_{i=1}^nw_if_i(x,y))}<br>\end{aligned}<br>$$<br>其中 $Z_w(x)$ 表示最优化参数 $w$ 下的规范化因子，$P_w(y|x)$ 表示最优化参数 $w$ 下的最大熵模型。</p>
<p>注意到我们使用$Z_w(x)$ 去替换分母$exp(1-w_0)$ 有一个好处就是能说明 $P_w(y|x)$ 的值与 $w_0$ 无关，</p>
<p>或者说$w_0$ 的值是由$w_i,\ i=1,\cdots,n$ 共同决定的。</p>
<p>目前我们只求出了 $P(y|x)$ 关于 $w$ 的表达式 $P_w(y|x)$，我们需要求解出 $w$ 才能真正求出 $P_w$。</p>
<p>或者说我们只求出了对偶问题中的 $I(w)=\underset{P}{min} \ L(P,w) = L(P_w,w)$ ，还需要求解 $w^*=\underset{w}{argmax}\ I(w)$。</p>
<p>那么最大熵模型的学习归结为对偶函数 $I(w)$ 的极大化，最终最大熵模型为 $P_{w^*}(y|x)$。</p>
<p>由于$P_w(y|x)$ 的值与 $w_0$ 无关，且 $w_0[1 - \sum_{x\in X,y\in Y}P(y|x)\tilde{P}(x)]=0$ 对$L(P_w,w)$ 的值没有贡献，</p>
<p>因此此项在化简中可行省略。现在将 $P_w$ 带入$L(P_w,w)$ 并化简:<br>$$<br>\begin{aligned}<br>L(P_w,w) =&amp; \sum_{x\in X,y \in Y}\tilde{P}(x)P_w(y|x)logP_w(y|x) \<br>&amp; +\sum_{i=1}^nw_i[\sum_{x\in X,y\in Y}\tilde{P}(x,y)f_i(x,y) - \sum_{x\in X,y\in Y}\tilde{P}(x)P_w(x|y)f_i(x,y)]\<br>=&amp; \sum_{x\in X,y \in Y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y) + \sum_{x\in X,y\in Y}\tilde{P}(x)P_w(y|x)[logP_w(y|x)-\sum_{i=1}^nw_if_i(x,y)]\<br>=&amp; \sum_{x\in X,y \in Y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y) - \sum_{x\in X,y\in Y}\tilde{P}(x)P_w(y|x)logZ_w(x)\\<br>\because &amp;\quad \sum_yP(y|x) = 1\<br>\therefore &amp;\quad I(w) = L(P_w,w)= \sum_{x\in X,y \in Y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y) - \sum_{x\in X}\tilde{P}(x)logZ_w(x)<br>\end{aligned}<br>$$</p>
<p>统计学习方法在 <strong>6.2.4 极大似然估计</strong>中证明了对偶函数 $I(w)$ 的极大化等价于最大熵模型的极大似然估计。</p>
<p>设条件概率分布$P_w(y|x)$ 的对数似然函数为$L(P_w)$，那么有以下等式关系:<br>$$<br>\begin{aligned}<br>L(P_w) =&amp; log\prod_{x\in X,y\in Y} P_w(y|x)^{\tilde{P}(y,x)} \<br>=&amp; \sum_{x\in X,y\in Y}\tilde{P}(y,x) logP_w(y|x)\<br>=&amp; \sum_{x\in X,y \in Y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y) - \sum_{x\in X}\tilde{P}(x)logZ_w(x)\<br>\therefore &amp;\quad L(P_w) = I(w)<br>\end{aligned}<br>$$<br>这样，最大熵模型的学习问题就转换为具体求解对数似然函数极大化或对偶函数极大化的问题。</p>
<h2 id="模型学习的最优化算法"><a href="#模型学习的最优化算法" class="headerlink" title="模型学习的最优化算法"></a>模型学习的最优化算法</h2><blockquote>
<p>常用的方法有改进的迭代尺度法、梯度下降法、牛顿法或拟牛顿法。</p>
<p>此处主要针对最大熵模型讨论改进的迭代尺度法(IIS)和牛顿法。</p>
<p>相关参考:</p>
<p><a href="https://www.bilibili.com/video/BV1g64y1h7Lc" target="_blank" rel="noopener">深度之眼《李航统计学习方法》课程</a></p>
<p><a href="https://www.cnblogs.com/pinard/p/6093948.html" target="_blank" rel="noopener">最大熵模型原理小结 - 刘建平Pinard</a></p>
</blockquote>
<p>可以想到将$P_w$ 代入原式中再求解 $\nabla_w L(P_w,w) = 0$，</p>
<p>但实际上直接对$L(P_w,w)$ 求 $w$ 的偏导数求解十分困难，需要用到最优化算法求解。</p>
<h3 id="改进的尺度迭代法"><a href="#改进的尺度迭代法" class="headerlink" title="改进的尺度迭代法"></a>改进的尺度迭代法</h3><p>改进的尺度迭代法 (IIS) 一般只用于最大熵模型，</p>
<p>它假设当前的参数向量是 $w$ , 我们希望找到一个新的参数向量 $w+\delta$ , 使得对偶函数 $I(w)$ 增大, </p>
<p>重复此操作, 以达到 $\underset{w}{max}\ I(w)$  的目的。</p>
<p>将这个过程表述为等式:<br>$$<br>\begin{aligned}<br>&amp; I(w+\delta) - I(w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y)-\sum_{x\in X} \tilde{P}(x)log{Z_{w+\delta}(x)\over Z_w(x)}\\</p>
<p>\because &amp; -log\ x \geq 1-x \ ,\ (x&gt;0)\<br>\therefore &amp; \ I(w+\delta) - I(w)  \geq \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x){Z_{w+\delta}(x)\over Z_w(x)}\\</p>
<p>set \ &amp; A(\delta|w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x){Z_{w+\delta}(x)\over Z_w(x)}\<br>&amp; A(\delta|w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x)\sum_{y\in Y}P_w(y|x)exp\sum_{i=1}^n\delta_if_i(x,y)\<br>\therefore \ &amp;I(w+\delta) - I(w) \geq A(\delta|w)<br>\end{aligned}<br>$$<br>我们可以最大化$A()$ 来间接找到能使 $I(w)$ 增大最快的 $\delta$ 。</p>
<p>于是想到求解 $A(\delta|w)$ 的最大值，即求出$A(\delta|w)$ 关于 $\delta$ 的导数，找到零点。</p>
<p>但是如果这么做的话会发现，由于$\delta$ 是和 $w$ 同维度的向量，就需要对每个分量$\delta_i$求导。</p>
<p>那么原式中的 $exp\sum_i^n\delta_if_i(x,y)$ 在对$\delta_i$ 求导后就会变成 $f_i(x,y)exp\sum_i^n\delta_if_i(x,y)$ ,</p>
<p>我们发现由于指数函数的存在求导不能将偏导数摆脱其他 $\delta_j$ 分量，使其成为只关于$\delta_i$ 的函数，</p>
<p>我们不能使用未知的 $\delta_j$ 求解$\delta_i$ 的偏导数零点。</p>
<p>为了解决这个问题我们需要引入一个函数：$f^{ # }(x,y) = \sum_if_i(x,y)$ </p>
<p>以及一个不等式 Jensen不等式: </p>
<p>对于凸函数 $\phi$ 以及满足$\sum_ia_i = 1$ 的权重 $a_i$，那么就有$\phi(\sum_ia_ib_i)\leq \sum_i a_i\phi(b_i)$<br>$$<br>\begin{aligned}<br>&amp; set \ a_i = {f_i(x,y)\over f^{ # }(x,y)} \ ,\ b_i = \delta_if^{ # }(x,y)\<br>&amp; A(\delta|w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x)\sum_{y\in Y}P_w(y|x)exp\sum_{i=1}^n a_ix_i\\</p>
<p>\because &amp; \phi(x) = exp(x)\\<br>\therefore &amp; \phi(\sum_ia_ib_i)\leq \sum_i a_i\phi(b_i)\<br>\therefore &amp; exp(\sum_i^n {f_i(x,y)\over f^{ # }(x,y)}\delta_if^{ # }(x,y)) \leq \sum_i^n {f_i(x,y)\over f^{ # }(x,y)} exp(\delta_if^{ # }(x,y))\\<br>&amp; B(\delta|w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x)\sum_{y\in Y}P_w(y|x)\sum_i^n {f_i(x,y)\over f^{ # }(x,y)} exp(\delta_if^{ # }(x,y))\<br>&amp; A(\delta|w) \geq B(\delta|w)<br>\end{aligned}<br>$$<br>于是我们从 $A(\delta|w)$ 放缩得到 $B(\delta|w)$ , 即有$I(w+\delta) - I(w) \geq B(\delta|w)$ 。</p>
<p>由于现在的指数函数在求和内，那么无关变量$\delta_j$ 就是无关变量对$\delta_i$求导为0，</p>
<p>现在再求$B(\delta|w)$ 对 $\delta_i$ 的偏导数:<br>$$<br>{\part B(\delta|w)\over \part \delta_i} = \sum_{x\in X y\in Y} \tilde{P}(x,y)f_i(x,y) - \sum_{x\in X} \tilde{P}(x)\sum_{y \in Y}P_w(y|x)f_i(x,y)exp(\delta_i f^{ # }(x,y))\<br> set \quad {\part B(\delta|w)\over \part \delta_i} = 0\<br> E_{\tilde{P} }(f_i) = \sum_{x\in X y\in Y} \tilde{P}(x,y)f_i(x,y) = \sum_{x\in X,y\in Y} \tilde{P}(x)P_w(y|x)f_i(x,y)exp(\delta_i f^{ # }(x,y))<br>$$<br>现在只要求解上述关于 $\delta_i$ 的方程就能求出 $w$ 的最优解。</p>
<p>由于$f^{ # }(x,y)$ 并不是对任何$x,y$ 都有 $f^{ # }(x,y)=M$ 因此需要通过牛顿迭代法来求解。</p>
<h3 id="牛顿法与拟牛顿法"><a href="#牛顿法与拟牛顿法" class="headerlink" title="牛顿法与拟牛顿法"></a>牛顿法与拟牛顿法</h3><blockquote>
<p>相关参考:</p>
<p><a href="https://cloud.tencent.com/developer/article/1390228" target="_blank" rel="noopener">优化算法——牛顿法(Newton Method)</a></p>
</blockquote>
<p><strong>首先牛顿法能做什么？</strong></p>
<p>牛顿法可以通过迭代逼近的方法找到函数极值点。</p>
<p><strong>牛顿法如何找到极值点？</strong></p>
<p>牛顿法可以通过泰勒二阶展开推导得到。假设我们要求 $f(x)$ 的极值点, 即 $f’(x)$ 的零点。</p>
<p>我们知道 $f(x)$ 可以通过二阶泰勒展开近似表示为: </p>
<p>$f(x)= f(x_k) + f’(x_k)(x-x_k) + {1\over2}f’’(x_k)(x-x_k)^2$</p>
<p>对上述式子求导并令其为0得到: $f’(x_k) + f’’(x_k)(x-x_k) = 0$ 。 </p>
<p>因此有  $x= x_k- {f’(x_k)\over f’’(x_k)}$, 假设我们已经到达了点$(x_k, f(x_k))$ 我们可以用这个等式迭代毕竟极值点。</p>
<p>当然$f(x)$ 需要存在极值点 即存在 $\nabla f(x) = 0$</p>
<p><strong>那么什么是拟牛顿法?</strong></p>
<p>当 $f(x)$ 是一个关于向量 $x$ 的函数时求解其导数和二阶导数会使问题变得复杂。</p>
<p>当 $x$ 为向量时其二阶泰勒展开变为: $f(x) = f(x_k) + g(x_k)(x-x_k) + {1\over2}(x-x_k)^TH(x_k)(x-x_k) $。</p>
<p>其中 $g(x_k)= \nabla f(x_k)$ , $H(x_k)$ 是 $f(x)$ 的海赛矩阵(Hesse matrix):<br>$$<br>H(x) =<br>\begin{bmatrix}<br>{\part^2f \over \part x_i\part x_j}<br>\end{bmatrix}<em>{n\times n}<br>$$<br>那么迭代公式则改写为: $x</em>{k+1} = x_k - H_k^{-1}g_k$ , 其中 $H_k = H(x_k)$ , $g_k = g(x_k)$</p>
<p>为了求解下一个点$x_{k+1}$ 我们需要反复计算 $n\times n $ 矩阵的逆 $H^{-1}_k$ , 这对计算机非常的不友好。</p>
<p>为了避免求解逆矩阵的运算我们可以将迭代公式稍微变化一下, 于是产生了拟牛顿法。</p>
<p>在统计学习方法的附录中介绍了两种拟牛顿法 DFP算法和 BFGS算法, </p>
<p>其中后者更为流行因此这里仅介绍 BFGS算法。</p>
<p><strong>BFGS算法</strong></p>
<p>记 $y_k = g(x_{k+1}) - g(x_k)$ , $\delta_k = x_{k+1} - x_k$ 。<br>$$<br>\because \nabla f(x) = g(x_k) + H_k(x-x_k),\quad set \ x= x_{k+1}\<br>\therefore \nabla f(x_{k+1}) = g(x_{k+1}) \<br>\therefore g(x_{k+1}) - g(x_k) = H_k(x_{k+1} - x_k)\<br>\therefore y_k = H_k\delta_k<br>$$<br>BFGS算法考虑使用$B_{k+1}$ 逼近 $H_k$  </p>
<p>将原先的迭代公式改为: $B_{k+1} \delta_k= y_k$</p>
<p>我们假设构造的矩阵$B_k$ 存在这样的递推关系: $ B_{k+1} = B_k +P_k+Q_k$</p>
<p>为了满足迭代公式$B_{k+1} \delta_k= y_k$, 则有:<br>$$<br>B_{k+1}\delta_k = B_k\delta_k +P_k\delta_k + Q_k\delta_k\<br> P_k\delta_k = y_k\<br> Q_k\delta_k = - B_k\delta_k\<br> P_k = { y_k y_k^T\over y_k^T\delta_k}\<br> Q_k = { B_k \delta_k\delta_k^T B_k \over \delta_k^T B_k\delta_k}<br>$$<br>当取 $B_0$ 为正定对称矩阵则能保证之后求得的 $B_k$ 都为正定矩阵。</p>
<p>BFGS算法引入了矩阵$B$ 代替海赛矩阵 $H$,   虽然重点推导了$B_k$ 的递推式但是不要忘记</p>
<p>我们最终要求的是令 $g(x_k)=0$ 的解 $x_k$ 。</p>
<p>具体的算法见李航书中附录B，拟牛顿法 —— 算法B.3。</p>
<p><img src="/.io//timg.gif" data-original="BFGS.png"></p>
<p>其中第三步中的 $p_k = \delta_k = x_{k+1} - x_k$ , 这里可能会令人疑惑: </p>
<p>为什么会与 $B_k \delta_k = y_k$ 冲突？因为我们要求令 $g(x_{k+1})=0$ 的解$x_{k+1}$ ,</p>
<p>因此我们令 $y_k = g(x_{k-1}) -g(x_k) = 0 - g(x_k)$ , 于是就有了 $B_kp_k=-g_k$ 。</p>
<p><strong>使用拟牛顿算法求解最大熵模型参数$w$</strong></p>
<p>回到最大熵模型的学习问题上。</p>
<p>我们已经求出了最大熵模型 $P(y|x)$ 关于参数 $w$ 的表达式:<br>$$<br>P_w(y|x) = {exp(\sum_{i=1}^nw_if_i(x,y))\over \sum_{y\in Y} exp(\sum_{i=1}^nw_if_i(x,y))}\<br>$$<br>我们希望通过极大化对偶函数$I(w)$ 或似然函数$L(P_w)$ 找到对应的参数 $w$ 。</p>
<p>于是在 改进的迭代尺度法 中我们通过放缩找到了$I(w+\delta) - I(w)$ 的下界函数 $B(\delta|w)$ :<br>$$<br> B(\delta|w) = \sum_{x\in X, y\in Y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y) + 1 - \sum_{x\in X}\tilde{P}(x)\sum_{y\in Y}P_w(y|x)\sum_i^n {f_i(x,y)\over f^{ # }(x,y)} exp(\delta_if^{ # }(x,y))\<br>$$<br>我们要做的就是求解$B(\delta|w)$ 的最大值。使用拟牛顿法进行迭代求解,</p>
<p>其中$\delta_i^k=w_i^{k+1}-w_i^{k}$ 表示第k次迭代参数$w_i$ 的增量, $\delta^<em>_i$ 为最终解则有:<br>$$<br>g(\delta_i) = {\part B(\delta|w)\over \part \delta_i} \<br>g(\delta_i^</em>) = {\part B(\delta^<em>|w)\over \part \delta_i^</em>}=0\<br>\delta_i^{k+1} = \delta_i^{k} - {g(\delta_i^k) \over g’(\delta_i^k)}<br>$$<br>我们也可以不使用改进的迭代尺度算法(IIS) 而是直接针对对偶函数$I(w)$ 使用拟牛顿法求解参数 $w$。</p>
<p>求解最大熵模型$P_w(y|x)$ 要求我们最大化对偶函数 $I(w)$ , 书中设$f(w) = - I(w)$ 有最小值, </p>
<p>则目标函数为 $\underset{w}{min} \ f(w)$, 对$f(w)$ 的一阶导数向量 $g(w)$, 其中$w$  为n维的向量, $w_i$ 表示第i个分量:<br>$$<br>\underset{w}{min} \ f(w) =  \sum_{x\in X}\tilde{P}(x)logZ_w(x) - \sum_{x\in X,y \in Y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y)\<br>g(w) = { {\part f(w)\over w_1}, \cdots,{\part f(w)\over w_n} }\<br>{\part f(w)\over w_i} = \sum_{x\in X y\in Y} \tilde{P}(x)P_w(y|x)f_i(x,y)-\sum_{x\in X y\in Y} \tilde{P}(x,y)f_i(x,y)\<br>$$<br>使用BFGS算法求解目标函数最优解过程如下:</p>
<p><img src="/.io//timg.gif" data-original="BFGS_for_ME.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
</search>
